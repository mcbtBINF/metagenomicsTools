    dFrame.prep <- as.data.frame(matrix(unlist(allpvals), nrow= length(allpvals),byrow=TRUE)
)
dFrame <- as.data.frame(matrix(unlist(allpvals), nrow= length(allpvals), byrow=TRUE))
    colnames(dFrame) <- unlist(allNames[[1]])
dFrame
index
allNames[[1]]
allNames <- rownames(anova(fullModelLME))[-1]
allNames
                allNames<-c(allNames, "anovaCage", "iccCage")
allNames
allpvals
rm(allpvals)
allpvals[[index]]<-c(allpvals[[index]], anova(fullModelLME, reducedModel)$"p-value"[2], coef(fullModel$modelStruct[1]$corStruct,unconstrained=FALSE)[[1]])
allpvals<-list()
allpvals[[index]]<-c(allpvals[[index]], anova(fullModelLME, reducedModel)$"p-value"[2], coef(fullModel$modelStruct[1]$corStruct,unconstrained=FALSE)[[1]])
            allpvals[[index]] <- anova(fullModelLME)$"p-value"[-1]
                allpvals[[index]]<-c(allpvals[[index]], anova(fullModelLME, reducedModel)$"p-value"[2], coef(fullModel$modelStruct[1]$corStruct,unconstrained=FALSE)[[1]])

allpvals[[1]]
paste("p-", allNames, " = ", format(allpvals[[index]], digits=3), sep="")
paste(c(rep("p-",length(allNames)-1),""), allNames, " = ", format(allpvals[[index]], digits=3), sep="")
paste(c(rep("p-",length(allNames)-1),""), allNames, " = ", format(allpvals[[index]], digits=3), sep="")
paste(names(myT)[1], c(rep("p-",length(allNames)-1),""), allNames, " = ", format(allpvals[[index]], digits=3), sep="")
c(names[1],paste(rep("p-",length(allNames)-1),""), allNames, " = ", format(allpvals[[index]], digits=3), sep="")
c(names[1],paste(rep("p-",length(allNames)-1),""), allNames, " = ", format(allpvals[[index]], digits=3), sep="")
c(names[1], paste(rep("p-",length(allNames)-1),"", allNames, " = ", format(allpvals[[index]], digits=3), sep=""))
c(names[1],"\n", paste(rep("p-",length(allNames)-1),"", allNames, " = ", format(allpvals[[index]], digits=3), sep=""))
paste(names[1],"\n", paste(rep("p-",length(allNames)-1),"", allNames, " = ", format(allpvals[[index]], digits=3), sep=""))
paste(c(names[1],"\n", paste(rep("p-",length(allNames)-1),"", allNames, " = ", format(allpvals[[index]], digits=3), sep="")))
c(names[1], paste(rep("p-",length(allNames)-1),"", allNames, " = ", format(allpvals[[index]], digits=3), sep=""))
help(plot)
graphMain<-c(names[1], paste(rep("p-",length(allNames)-1),"", allNames, " = ", format(allpvals[[index]], digits=3), sep=""))
plot(,main = graphMain)
plot( bug ~ factor(get(allNames[[index]][i])), ylab = names[index],main = graphMain )
j<-1
plot( bug ~ factor(get(allNames[j])), ylab = names[index], main = graphMain )
                    points(factor(get(allNames[j])), bug)
j<-2
plot( bug ~ factor(get(allNames[j])), ylab = names[index])
                    points(factor(get(allNames[j])), bug)
 numPlots <- length(allNames) - 1
            par(mfrow=c(numPlots, 1),
                oma = c(1,1,0,0) + 0.1,
                mar = c(1,4,2.5,0) + 0.1)
for(j in 1:numPlots){
                if(j == 1){
                    plot( bug ~ factor(get(allNames[j])), ylab = names[index], main = graphMain )
                    points(factor(get(allNames[j])), bug)
                }
                else{
                    plot( bug ~ factor(get(allNames[j])), ylab = names[index])
                    points(factor(get(allNames[j])), bug)
                }
            }
allNames
            allNames <- rownames(anova(fullModelLME))[-1]
            allpvals[[index]] <- anova(fullModelLME)$"p-value"[-1]

allpvals
 allNames<-c(allNames, "cage", "iccCage")
                allpvals[[index]]<-c(allpvals[[index]], anova(fullModelLME, reducedModel)$"p-value"[2], coef(fullModel$modelStruct[1]$corStruct,unconstrained=FALSE)[[1]])
graphMain = c(names[1], paste(rep("p-",length(allNames)-1),"", allNames, " = ", format(allpvals[[index]], digits=3), sep=""))
numPlots <- length(allNames) - 1
            par(mfrow=c(numPlots, 1),
                oma = c(1,1,0,0) + 0.1,
                mar = c(1,4,2.5,0) + 0.1)

            for(j in 1:numPlots){
                if(j == 1){
                    plot( bug ~ factor(get(allNames[j])), ylab = names[index], main = graphMain )
                    points(factor(get(allNames[j])), bug)
                }
                else{
                    plot( bug ~ factor(get(allNames[j])), ylab = names[index])
                    points(factor(get(allNames[j])), bug)
                }
            }
fullModelLME <- lm(bug~ treatment*time + batch, x=TRUE)
 time <- myT$StressLength
 fullModelLME <- lm(bug~ treatment*time + batch, x=TRUE)
anova(fullModelLME)
rownames(anova(fullModelLME))
toString(cage)
deparse(cage)
deparse(substitute(cage))
            graphMain = c(names[1], paste(rep("p-",length(allNames)-1),"", allNames, " = ", format(allpvals[[index]], digits=3), sep=""))

allNames
graphMain
numPlots <- length(allNames) - 1
            par(mfrow=c(numPlots, 1),
                oma = c(1,1,0,0) + 0.1,
                mar = c(1,4,2.5,0) + 0.1)

            for(j in 1:numPlots){
                if(j == 1){
                    plot( bug ~ factor(get(allNames[j])), ylab = names[index], main = graphMain )
                    points(factor(get(allNames[j])), bug)
                }
                else{
                    plot( bug ~ factor(get(allNames[j])), ylab = names[index])
                    points(factor(get(allNames[j])), bug)
                }
            }
treatment
anova(fullModelLME)
graphMain
            numPlots <- length(allNames) - 1
            par(mfrow=c(numPlots, 1),
                oma = c(1,1,0,0) + 0.1,
                mar = c(1,4,2.5,0) + 0.1)

            for(j in 1:numPlots){
                if(j == 1){
                    plot( bug ~ factor(get(allNames[j])), ylab = names[index], main = graphMain )
                    points(factor(get(allNames[j])), bug)
                }
                else{
                    plot( bug ~ factor(get(allNames[j])), ylab = names[index])
                    points(factor(get(allNames[j])), bug)
                }
            }

graphMain
toString(graphMain)
 graphMain = c(names[1], "\n", paste(rep("p-",length(allNames)-1),"", allNames, " = ", format(allpvals[[index]], digits=3), sep=""))
           
toString(graphMain)
help(toString
)
help(toString)
 graphMain = c(names[1], paste(rep("p-",length(allNames)-1),"", allNames, " = ", format(allpvals[[index]], digits=3), sep=""))
graphMain
toString(graphMain)
gsub(",","\n",toString(graphMain))
            graphMain = c(paste0(names[1],"\n"), paste(rep("p-",length(allNames)-1),"", allNames, " = ", format(allpvals[[index]], digits=3), sep=""))

graphMain
toString(graphMain)
 numPlots <- length(allNames) - 1
            par(mfrow=c(numPlots, 1),
                oma = c(1,1,0,0) + 0.1,
                mar = c(1,4,2.5,0) + 0.1)

            for(j in 1:numPlots){
                if(j == 1){
                    plot( bug ~ factor(get(allNames[j])), ylab = names[index], main = graphMain )
                    points(factor(get(allNames[j])), bug)
                }
                else{
                    plot( bug ~ factor(get(allNames[j])), ylab = names[index])
                    points(factor(get(allNames[j])), bug)
                }
            }
           
help(rep)
            graphMain = c(names[1], paste(rep("p-",length(allNames)-1),"", allNames, " = ", format(allpvals[[index]], digits=3), rep(c("","\n")) sep=""))

            graphMain = c(names[1], paste(rep("p-",length(allNames)-1),"", allNames, " = ", format(allpvals[[index]], digits=3), rep(c("","\n")), sep=""))

graphMain
            numPlots <- length(allNames) - 1
            par(mfrow=c(numPlots, 1),
                oma = c(1,1,0,0) + 0.1,
                mar = c(1,4,2.5,0) + 0.1)

            for(j in 1:numPlots){
                if(j == 1){
                    plot( bug ~ factor(get(allNames[j])), ylab = names[index], main = graphMain )
                    points(factor(get(allNames[j])), bug)
                }
                else{
                    plot( bug ~ factor(get(allNames[j])), ylab = names[index])
                    points(factor(get(allNames[j])), bug)
                }
            }

            graphMain = c(names[1], paste(rep("p-",length(allNames)-1),"", allNames, " = ", format(allpvals[[index]], digits=3), sep=""))

graphMain
toString(graphMain)
            numPlots <- length(allNames) - 1
            par(mfrow=c(numPlots, 1),
                oma = c(1,1,0,0) + 0.1,
                mar = c(1,4,2.5,0) + 0.1)

            for(j in 1:numPlots){
                if(j == 1){
                    plot( bug ~ factor(get(allNames[j])), ylab = names[index], main = tString(graphMain) )
                    points(factor(get(allNames[j])), bug)
                }
                else{
                    plot( bug ~ factor(get(allNames[j])), ylab = names[index])
                    points(factor(get(allNames[j])), bug)
                }
            }

            numPlots <- length(allNames) - 1
            par(mfrow=c(numPlots, 1),
                oma = c(1,1,0,0) + 0.1,
                mar = c(1,4,2.5,0) + 0.1)

            for(j in 1:numPlots){
                if(j == 1){
                    plot( bug ~ factor(get(allNames[j])), ylab = names[index], main = toString(graphMain) )
                    points(factor(get(allNames[j])), bug)
                }
                else{
                    plot( bug ~ factor(get(allNames[j])), ylab = names[index])
                    points(factor(get(allNames[j])), bug)
                }
            }

graphMain
            graphMain = c(names[1], paste(paste0(rep("p-",length(allNames)-1),""), allNames, " = ", format(allpvals[[index]], digits=3), sep=""))

graphMain
            graphMain = c(names[1], paste(paste0(rep("p-",length(allNames)-1)," "), allNames, " = ", format(allpvals[[index]], digits=3), sep=""))

graphMain
allNames
            graphMain = c(names[1], paste(c(rep("p-",length(allNames)-1),""), allNames, " = ", format(allpvals[[index]], digits=3), sep=""))

graphMain
toString(graphMain)
length(graphMain)
            graphMain = paste0(names[1], paste(c(rep("p-",length(allNames)-1),""), allNames, " = ", format(allpvals[[index]], digits=3), sep=""))

graphMain
            graphMain = c(names[1], paste(c(rep("p-",length(allNames)-1),""), allNames, " = ", format(allpvals[[index]], digits=3), sep=""))

graphMain
graphMain[-1]
            numPlots <- length(allNames) - 1
            par(mfrow=c(numPlots, 1),
                oma = c(1,1,0,0) + 0.1,
                mar = c(1,4,2.5,0) + 0.1)

            for(j in 1:numPlots){
                if(j == 1){
                    plot( bug ~ factor(get(allNames[j])), ylab = names[index], main = names[index] + "\n" + graphMain[-1] )
                    points(factor(get(allNames[j])), bug)
                }
                else{
                    plot( bug ~ factor(get(allNames[j])), ylab = names[index])
                    points(factor(get(allNames[j])), bug)
                }
            }

            numPlots <- length(allNames) - 1
            par(mfrow=c(numPlots, 1),
                oma = c(1,1,0,0) + 0.1,
                mar = c(1,4,2.5,0) + 0.1)

            for(j in 1:numPlots){
                if(j == 1){
                    plot( bug ~ factor(get(allNames[j])), ylab = names[index], main = c(names[index],"\n",graphMain[-1]) )
                    points(factor(get(allNames[j])), bug)
                }
                else{
                    plot( bug ~ factor(get(allNames[j])), ylab = names[index])
                    points(factor(get(allNames[j])), bug)
                }
            }

            numPlots <- length(allNames) - 1
            par(mfrow=c(numPlots, 1),
                oma = c(1,1,0,0) + 0.1,
                mar = c(1,4,2.5,0) + 0.1)

            for(j in 1:numPlots){
                if(j == 1){
                    plot( bug ~ factor(get(allNames[j])), ylab = names[index], main = c(names[index],"\n",toString(graphMain[-1])) )
                    points(factor(get(allNames[j])), bug)
                }
                else{
                    plot( bug ~ factor(get(allNames[j])), ylab = names[index])
                    points(factor(get(allNames[j])), bug)
                }
            }

            numPlots <- length(allNames) - 1
            par(mfrow=c(numPlots, 1),
                oma = c(1,1,0,0) + 0.1,
                mar = c(1,4,2.5,0) + 0.1)

            for(j in 1:numPlots){
                if(j == 1){
                    plot( bug ~ factor(get(allNames[j])), ylab = names[index], main = c(names[index],toString(graphMain[-1])) )
                    points(factor(get(allNames[j])), bug)
                }
                else{
                    plot( bug ~ factor(get(allNames[j])), ylab = names[index])
                    points(factor(get(allNames[j])), bug)
                }
            }

            numPlots <- length(allNames) - 1
            par(mfrow=c(numPlots, 1),
                oma = c(1,1,0,0) + 0.1,
                mar = c(1,4,2,0) + 0.1)

            for(j in 1:numPlots){
                if(j == 1){
                    plot( bug ~ factor(get(allNames[j])), ylab = names[index], main = c(names[index],toString(graphMain[-1])) )
                    points(factor(get(allNames[j])), bug)
                }
                else{
                    plot( bug ~ factor(get(allNames[j])), ylab = names[index])
                    points(factor(get(allNames[j])), bug)
                }
            }

            numPlots <- length(allNames) - 1
            par(mfrow=c(numPlots, 1),
                oma = c(1,1,0,0) + 0.1,
                mar = c(1,4,3,0) + 0.1)

            for(j in 1:numPlots){
                if(j == 1){
                    plot( bug ~ factor(get(allNames[j])), ylab = names[index], main = c(names[index],toString(graphMain[-1])) )
                    points(factor(get(allNames[j])), bug)
                }
                else{
                    plot( bug ~ factor(get(allNames[j])), ylab = names[index])
                    points(factor(get(allNames[j])), bug)
                }
            }

            numPlots <- length(allNames) - 1
            par(mfrow=c(numPlots, 1),
                oma = c(1,1,0,0) + 0.1,
                mar = c(1,3,3,0) + 0.1)

            for(j in 1:numPlots){
                if(j == 1){
                    plot( bug ~ factor(get(allNames[j])), ylab = names[index], main = c(names[index],toString(graphMain[-1])) )
                    points(factor(get(allNames[j])), bug)
                }
                else{
                    plot( bug ~ factor(get(allNames[j])), ylab = names[index])
                    points(factor(get(allNames[j])), bug)
                }
            }

            numPlots <- length(allNames) - 1
            par(mfrow=c(numPlots, 1),
                oma = c(1,1,0,0) + 0.1,
                mar = c(0.5,4,3,0) + 0.1)

            for(j in 1:numPlots){
                if(j == 1){
                    plot( bug ~ factor(get(allNames[j])), ylab = names[index], main = c(names[index],toString(graphMain[-1])) )
                    points(factor(get(allNames[j])), bug)
                }
                else{
                    plot( bug ~ factor(get(allNames[j])), ylab = names[index])
                    points(factor(get(allNames[j])), bug)
                }
            }

mlm<-TRUE
2 - mlm
mlm<-FALSE
2 - mlm
names
    dFrame <- as.data.frame(matrix(unlist(allpvals), nrow= length(allpvals), byrow=TRUE))
    colnames(dFrame) <- unlist(allNames)

dFrame
col(dFrame)
dim(dFrame)[2]
ncol(dFrame)
    for(k in col(dFrame)){
        print(dFrame[,k])
    }

    for(k in col(dFrame)-1){
        print(dFrame[,k])
    }

    for(k in ncol(dFrame)-1){
        print(dFrame[,k])
    }

    for(k in 1:(ncol(dFrame)-1)){
        print(dFrame[,k])
    }

colnames(dFrame)
rm(list=ls())

library("pscl")
library("lmtest")
library("nlme")
library("vegan")

setwd("/Users/mbrown67/Documents/Fodor/Datasets/MarkExperiment/Pooled/")

taxaLevels <- c( "phylum", "class", "order", "family", "genus")

for(taxa in taxaLevels){

    inFileName <- paste( taxa, "LogNormwithMetadata_R1_Pooled.txt", sep ="")
    myT <-read.csv(inFileName,header=TRUE,sep="", na.strings="BLAH")

    numCols <- ncol(myT)
    numMetadataCols <- 20

    ## Reprocessing for correct column data type
    myColClasses <- c("character", rep("numeric", numCols - numMetadataCols), rep("character", 11), "numeric", "numeric", "numeric", "character", "character", "numeric", "character", "character", "character")
    myT <-read.csv(inFileName, header=TRUE, sep="", colClasses=myColClasses, na.strings="BLAH")

    ## Removing unwanted samples {controls, replicates, duplicates, poor quality samples}
    removeControls<-c( "C1", "C2", "N1", "N2", "Neg", "Pos")
    myT<-myT[!(myT$Sample_ID %in% removeControls),]

    removetrs<-c("04_125_tr", "04_101_tr", "04_103_tr", "04_74_tr", "04_70_tr", "04_40_tr", "04_41_tr", "04_84_tr")
    myT<-myT[!(myT$Sample_ID %in% removetrs),]

    removeDups<-c("04-04_S63_L001_R1_001")
    myT<-myT[!(myT$MatchFile %in% removeDups),]

    ## Controls not dropped earlier
    manualDrop <- c("Neg_S40_L001_R1_001", "PCR1Neg_S65_L001_R1_001")
    myT<-myT[!(myT$MatchFile %in% manualDrop),]

    labDrop <- c("Harlan Labs")
    myT<-myT[!(myT$MouseOrigin %in% labDrop),]

    lowSeqDrop <- c("04-55_S32_L001_R1_001")
    myT<-myT[!(myT$MatchFile %in% lowSeqDrop),]
    ## Not sure what to do about this though.
    ### myT$Condition[which(myT$Treatment == "Ctrl", arr.ind = TRUE)]<-"Control"

    names <- vector()
    pValuesMultiway<-vector()
    pValuesSex<- vector()
    pValuesAcuteChronic<- vector()
    pValuesCage<- vector()
    iccCage <- vector()
    iccKeptCounts <- vector()
    pValuesBatch<- vector()
    pValuesTreatment<- vector()
    pValuesStressLength <- vector()
    pValuesInteraction <- vector()
    multiWay <- vector()
    allpvals <- list()
    allNames <- list()

    index <- 1

    for( i in 2:(ncol(myT) - numMetadataCols))
        if( sum(myT[,i] != 0 ) > nrow(myT) / 4 ){
            ## Easy access names
            bug <- myT[,i]
            ac <- myT$Condition
            sex <- myT$Sex
            cage <- myT$Cage
            batch <- myT$Sample_Plate
            date <- myT$Date
            mo <- myT$MouseOrigin
            group <- myT$SpreadsheetGrouping
            treatment <- myT$Treatment
            time <- myT$StressLength
            multiWay <- paste(ac, myT$StressLength)
            multiWay[which(myT$Treatment == "Ctrl", arr.ind = TRUE)]<-"Control"
            names[index] = names(myT)[i]
            ## Some kind of vector for the variables of interest
            myFrame <- data.frame(bug, ac, time, multiWay, sex, cage, treatment, batch, date, mo, date)
            mlm<-TRUE
            if(mlm == TRUE){
                fullModel <- gls( bug~   treatment*time + batch, method="REML",correlation=corCompSymm(form=~1|factor(group)),	data = myFrame )
                reducedModel <- gls( bug~ treatment*time + batch, method="REML", data = myFrame )
                fullModelLME <- lme(bug~  treatment*time + batch, method="REML", random = ~1|factor(group), data = myFrame)
            }
            else{
                fullModelLME <- lm(bug~ treatment*time + batch, x=TRUE)
            }
            ## Potential save time by reducing anova calls
            ## Introduce the goodness of fit tests here
            ## Can streamline vectors to be automatically responsive to changes to the model
            allNames <- rownames(anova(fullModelLME))[-1]
            allpvals[[index]] <- anova(fullModelLME)$"p-value"[-1]

            pValuesAcuteChronic[index] <- anova(fullModelLME)$"p-value"[2]
            pValuesTime[index] <- anova(fullModelLME)$"p-value"[6]
            pValuesInteraction[index] <- anova(fullModelLME)$"p-value"[6]
            pValuesSex[index] <- anova(fullModelLME)$"p-value"[6]
            pValuesExperiment[index] <- anova(fullModelLME)$"p-value"[6]
            pValuesBatch[index] <- anova(fullModelLME)$"p-value"[3]
            pValuesTreatment[index] <- anova(fullModelLME)$"p-value"[6]

            ## Random Effects and Interclass Correlation Coefficient
            if(mlm == TRUE){
                allNames<-c(allNames, "cage", "iccCage")
                allpvals[[index]]<-c(allpvals[[index]], anova(fullModelLME, reducedModel)$"p-value"[2], coef(fullModel$modelStruct[1]$corStruct,unconstrained=FALSE)[[1]])
                pValuesCage[index] <-  anova(fullModelLME, reducedModel)$"p-value"[2]
                ## This is different as it is not corrected for multiple hypothesis testing.
                iccCage[index]<- coef(fullModel$modelStruct[1]$corStruct,unconstrained=FALSE)[[1]]
            }
    ## Nice plotting
            ## Correct so that it uses corrected p-values
            graphMain = c(names[i], paste(c(rep("p-",length(allNames)-1),""), allNames, " = ", format(allpvals[[index]], digits=3), sep=""))
            ## graphMain =  paste( names(myT)[i], "\n",
            ##     ## " pTreatment= ", format(pValuesTreatment[index], digits=3),
            ##     ## " pTime= ", format(pValuesTime[index], digits=3),"\n",
            ##     ## " pTreatmentXTime= ", format(pValuesInteraction[index], digits=3),"\n",
            ##     ## " pSex=", format( pValuesSex[index], digits=3),
            ##     " pCondition= ", format( pValuesAcuteChronic[index],digits=3),
            ##     " pBatch= ", format(pValuesBatch[index], digits=3), "\n",
            ##     ## " pTreatment= ", format(pValuesTreatment[index], digits=3),
            ##     ## " pExperiment= ", format(pValuesExperiment[index], digits=3),
            ##     ## " pShannon= ", format(pValuesShannon[index], digits=3),
            ##     ## " pKeptCounts= ", format(pValuesKeptCounts[index], digits=3),
            ##     " pDate= " , format( pValuesCage[index], digits=3),
            ##     " icc= " , format( iccCage[index], digits=3 ), sep="")

            ## mlm is boolean 1/0 value. Basically, don't graph on icc
            numPlots <- length(allNames) - mlm
            par(mfrow=c(numPlots, 1),
                oma = c(1,1,0,0) + 0.1,
                mar = c(1,4,3,0) + 0.1)

            for(j in 1:numPlots){
                if(j == 1){
                    plot( bug ~ factor(get(allNames[j])), ylab = names[i], main = c(names[index],toString(graphMain[-1])) )
                    points(factor(get(allNames[j])), bug)
                }
                else{
                    plot( bug ~ factor(get(allNames[j])), ylab = names[i])
                    points(factor(get(allNames[j])), bug)
                }
            }
                ##plot( bug ~ factor(ac), ylab = names[index],main = graphMain )
                ##points(factor(ac), bug)

                ## plot ( bug ~ factor(ac) )
                ## points(factor(ac), bug)

                ## plot( bug ~ factor(c( paste( sl, treatment,sep=""))))
                ## points(factor(c( paste( sl, treatment,sep=""))), bug)

                ##plot ( bug ~ factor(batch) )
                ##points(factor(batch), bug)

                ##plot( bug ~ factor(date), ylab=names[index])
                ##points(factor(date), bug)

            index <- index + 1
	}

    ## This should also be dynamic
    dFrame <- as.data.frame(matrix(unlist(allpvals), nrow= length(allpvals), byrow=TRUE))
    colnames(dFrame) <- unlist(allNames)
    rownames(dFrame) <- names
    orgCol <- ncol(dFrame)

    for(k in 1:(orgCol-1)){
        dFrame[, k + orgCol]<-p.adjust(dFrame[,k], method = "BH")
    }
    colnames(dFrame)[(orgCol + 1):length(dFrame)]<-paste0(rep("adjusted_"),colnames(dFrame))
    ## dFrame <- data.frame( names, pValuesTreatment, pValuesBatch, pValuesCage, iccCage)
    ## pValuesTreatment)#, pValuesBatch)#, pValuesExperiment)

    ## dFrame <- dFrame[order(pValuesAcuteChronic),]
    ## dFrame$adjustedAcuteChronic <- p.adjust( dFrame$pValuesAcuteChronic, method = "BH" )
    ## dFrame$adjustedSex<- p.adjust( dFrame$pValuesSex, method = "BH" )
    ## dFrame$adjustedTreatment<- p.adjust( dFrame$pValuesTreatment, method = "BH" )
    ## dFrame$adjustedStressLength <- p.adjust( dFrame$pValuesStressLength, method = "BH")
    ## dFrame$adjustedInteraction <- p.adjust( dFrame$pValuesInteraction, method = "BH" )
    ## dFrame$adjustedBatch<- p.adjust( dFrame$pValuesBatch, method = "BH" )
    ## dFrame$adjustedCage <- p.adjust( dFrame$pValuesCage, method = "BH" )
    ## Try and dynamically generate the name of the plot here...
    write.table(dFrame, file=paste("pValuesForTaxa_bug_condition_batch_byDate_", taxa, ".txt",sep=""), sep="\t",row.names=FALSE)

    ## Get the sig table working
    ## It would also be nice to have a sig-picker for the plots and a combination of all sig results into one plot.
    keepVector <- grep("adj", names(dFrame))
    sigdFrame <-dFrame[which(dFrame[,keepVector] < 0.05,arr.ind=TRUE),]
    write.table(sigdFrame, file=paste("pValuesForTaxa_bug_condition_batch_byDate_sig_", taxa, ".txt",sep=""), sep="\t",row.names=FALSE)

    dev.off()
}

rm(list=ls())

library("pscl")
library("lmtest")
library("nlme")
library("vegan")

setwd("/Users/mbrown67/Documents/Fodor/Datasets/MarkExperiment/Pooled/")

taxaLevels <- c( "phylum", "class", "order", "family", "genus")

for(taxa in taxaLevels){

    inFileName <- paste( taxa, "LogNormwithMetadata_R1_Pooled.txt", sep ="")
    myT <-read.csv(inFileName,header=TRUE,sep="", na.strings="BLAH")

    numCols <- ncol(myT)
    numMetadataCols <- 20

    ## Reprocessing for correct column data type
    myColClasses <- c("character", rep("numeric", numCols - numMetadataCols - 1), rep("character", 11), "numeric", "numeric", "numeric", "character", "character", "numeric", "character", "character", "character")
    myT <-read.csv(inFileName, header=TRUE, sep="", colClasses=myColClasses, na.strings="BLAH")

    ## Removing unwanted samples {controls, replicates, duplicates, poor quality samples}
    removeControls<-c( "C1", "C2", "N1", "N2", "Neg", "Pos")
    myT<-myT[!(myT$Sample_ID %in% removeControls),]

    removetrs<-c("04_125_tr", "04_101_tr", "04_103_tr", "04_74_tr", "04_70_tr", "04_40_tr", "04_41_tr", "04_84_tr")
    myT<-myT[!(myT$Sample_ID %in% removetrs),]

    removeDups<-c("04-04_S63_L001_R1_001")
    myT<-myT[!(myT$MatchFile %in% removeDups),]

    ## Controls not dropped earlier
    manualDrop <- c("Neg_S40_L001_R1_001", "PCR1Neg_S65_L001_R1_001")
    myT<-myT[!(myT$MatchFile %in% manualDrop),]

    labDrop <- c("Harlan Labs")
    myT<-myT[!(myT$MouseOrigin %in% labDrop),]

    lowSeqDrop <- c("04-55_S32_L001_R1_001")
    myT<-myT[!(myT$MatchFile %in% lowSeqDrop),]
    ## Not sure what to do about this though.
    ### myT$Condition[which(myT$Treatment == "Ctrl", arr.ind = TRUE)]<-"Control"

    names <- vector()
    pValuesMultiway<-vector()
    pValuesSex<- vector()
    pValuesAcuteChronic<- vector()
    pValuesCage<- vector()
    iccCage <- vector()
    iccKeptCounts <- vector()
    pValuesBatch<- vector()
    pValuesTreatment<- vector()
    pValuesStressLength <- vector()
    pValuesInteraction <- vector()
    multiWay <- vector()
    allpvals <- list()
    allNames <- list()

    index <- 1

    for( i in 2:(ncol(myT) - numMetadataCols))
        if( sum(myT[,i] != 0 ) > nrow(myT) / 4 ){
            ## Easy access names
            bug <- myT[,i]
            ac <- myT$Condition
            sex <- myT$Sex
            cage <- myT$Cage
            batch <- myT$Sample_Plate
            date <- myT$Date
            mo <- myT$MouseOrigin
            group <- myT$SpreadsheetGrouping
            treatment <- myT$Treatment
            time <- myT$StressLength
            multiWay <- paste(ac, myT$StressLength)
            multiWay[which(myT$Treatment == "Ctrl", arr.ind = TRUE)]<-"Control"
            names[index] = names(myT)[i]
            ## Some kind of vector for the variables of interest
            myFrame <- data.frame(bug, ac, time, multiWay, sex, cage, treatment, batch, date, mo, date)
            mlm<-TRUE
            if(mlm == TRUE){
                fullModel <- gls( bug~   treatment*time + batch, method="REML",correlation=corCompSymm(form=~1|factor(group)),	data = myFrame )
                reducedModel <- gls( bug~ treatment*time + batch, method="REML", data = myFrame )
                fullModelLME <- lme(bug~  treatment*time + batch, method="REML", random = ~1|factor(group), data = myFrame)
            }
            else{
                fullModelLME <- lm(bug~ treatment*time + batch, x=TRUE)
            }
            ## Potential save time by reducing anova calls
            ## Introduce the goodness of fit tests here
            ## Can streamline vectors to be automatically responsive to changes to the model
            allNames <- rownames(anova(fullModelLME))[-1]
            allpvals[[index]] <- anova(fullModelLME)$"p-value"[-1]

            pValuesAcuteChronic[index] <- anova(fullModelLME)$"p-value"[2]
            pValuesTime[index] <- anova(fullModelLME)$"p-value"[6]
            pValuesInteraction[index] <- anova(fullModelLME)$"p-value"[6]
            pValuesSex[index] <- anova(fullModelLME)$"p-value"[6]
            pValuesExperiment[index] <- anova(fullModelLME)$"p-value"[6]
            pValuesBatch[index] <- anova(fullModelLME)$"p-value"[3]
            pValuesTreatment[index] <- anova(fullModelLME)$"p-value"[6]

            ## Random Effects and Interclass Correlation Coefficient
            if(mlm == TRUE){
                allNames<-c(allNames, "cage", "iccCage")
                allpvals[[index]]<-c(allpvals[[index]], anova(fullModelLME, reducedModel)$"p-value"[2], coef(fullModel$modelStruct[1]$corStruct,unconstrained=FALSE)[[1]])
                pValuesCage[index] <-  anova(fullModelLME, reducedModel)$"p-value"[2]
                ## This is different as it is not corrected for multiple hypothesis testing.
                iccCage[index]<- coef(fullModel$modelStruct[1]$corStruct,unconstrained=FALSE)[[1]]
            }
    ## Nice plotting
            ## Correct so that it uses corrected p-values
            graphMain = c(names[i], paste(c(rep("p-",length(allNames)-1),""), allNames, " = ", format(allpvals[[index]], digits=3), sep=""))
            ## graphMain =  paste( names(myT)[i], "\n",
            ##     ## " pTreatment= ", format(pValuesTreatment[index], digits=3),
            ##     ## " pTime= ", format(pValuesTime[index], digits=3),"\n",
            ##     ## " pTreatmentXTime= ", format(pValuesInteraction[index], digits=3),"\n",
            ##     ## " pSex=", format( pValuesSex[index], digits=3),
            ##     " pCondition= ", format( pValuesAcuteChronic[index],digits=3),
            ##     " pBatch= ", format(pValuesBatch[index], digits=3), "\n",
            ##     ## " pTreatment= ", format(pValuesTreatment[index], digits=3),
            ##     ## " pExperiment= ", format(pValuesExperiment[index], digits=3),
            ##     ## " pShannon= ", format(pValuesShannon[index], digits=3),
            ##     ## " pKeptCounts= ", format(pValuesKeptCounts[index], digits=3),
            ##     " pDate= " , format( pValuesCage[index], digits=3),
            ##     " icc= " , format( iccCage[index], digits=3 ), sep="")

            ## mlm is boolean 1/0 value. Basically, don't graph on icc
            numPlots <- length(allNames) - mlm
            par(mfrow=c(numPlots, 1),
                oma = c(1,1,0,0) + 0.1,
                mar = c(1,4,3,0) + 0.1)

            for(j in 1:numPlots){
                if(j == 1){
                    plot( bug ~ factor(get(allNames[j])), ylab = names[i], main = c(names[index],toString(graphMain[-1])) )
                    points(factor(get(allNames[j])), bug)
                }
                else{
                    plot( bug ~ factor(get(allNames[j])), ylab = names[i])
                    points(factor(get(allNames[j])), bug)
                }
            }
                ##plot( bug ~ factor(ac), ylab = names[index],main = graphMain )
                ##points(factor(ac), bug)

                ## plot ( bug ~ factor(ac) )
                ## points(factor(ac), bug)

                ## plot( bug ~ factor(c( paste( sl, treatment,sep=""))))
                ## points(factor(c( paste( sl, treatment,sep=""))), bug)

                ##plot ( bug ~ factor(batch) )
                ##points(factor(batch), bug)

                ##plot( bug ~ factor(date), ylab=names[index])
                ##points(factor(date), bug)

            index <- index + 1
	}

    ## This should also be dynamic
    dFrame <- as.data.frame(matrix(unlist(allpvals), nrow= length(allpvals), byrow=TRUE))
    colnames(dFrame) <- unlist(allNames)
    rownames(dFrame) <- names
    orgCol <- ncol(dFrame)

    for(k in 1:(orgCol-1)){
        dFrame[, k + orgCol]<-p.adjust(dFrame[,k], method = "BH")
    }
    colnames(dFrame)[(orgCol + 1):length(dFrame)]<-paste0(rep("adjusted_"),colnames(dFrame))
    ## dFrame <- data.frame( names, pValuesTreatment, pValuesBatch, pValuesCage, iccCage)
    ## pValuesTreatment)#, pValuesBatch)#, pValuesExperiment)

    ## dFrame <- dFrame[order(pValuesAcuteChronic),]
    ## dFrame$adjustedAcuteChronic <- p.adjust( dFrame$pValuesAcuteChronic, method = "BH" )
    ## dFrame$adjustedSex<- p.adjust( dFrame$pValuesSex, method = "BH" )
    ## dFrame$adjustedTreatment<- p.adjust( dFrame$pValuesTreatment, method = "BH" )
    ## dFrame$adjustedStressLength <- p.adjust( dFrame$pValuesStressLength, method = "BH")
    ## dFrame$adjustedInteraction <- p.adjust( dFrame$pValuesInteraction, method = "BH" )
    ## dFrame$adjustedBatch<- p.adjust( dFrame$pValuesBatch, method = "BH" )
    ## dFrame$adjustedCage <- p.adjust( dFrame$pValuesCage, method = "BH" )
    ## Try and dynamically generate the name of the plot here...
    write.table(dFrame, file=paste("pValuesForTaxa_bug_condition_batch_byDate_", taxa, ".txt",sep=""), sep="\t",row.names=FALSE)

    ## Get the sig table working
    ## It would also be nice to have a sig-picker for the plots and a combination of all sig results into one plot.
    keepVector <- grep("adj", names(dFrame))
    sigdFrame <-dFrame[which(dFrame[,keepVector] < 0.05,arr.ind=TRUE),]
    write.table(sigdFrame, file=paste("pValuesForTaxa_bug_condition_batch_byDate_sig_", taxa, ".txt",sep=""), sep="\t",row.names=FALSE)

    dev.off()
}

rm(list=ls())

library("pscl")
library("lmtest")
library("nlme")
library("vegan")

setwd("/Users/mbrown67/Documents/Fodor/Datasets/MarkExperiment/Pooled/")

taxaLevels <- c( "phylum", "class", "order", "family", "genus")

for(taxa in taxaLevels){

    inFileName <- paste( taxa, "LogNormwithMetadata_R1_Pooled.txt", sep ="")
    myT <-read.csv(inFileName,header=TRUE,sep="", na.strings="BLAH")

    numCols <- ncol(myT)
    numMetadataCols <- 20

    ## Reprocessing for correct column data type
    myColClasses <- c("character", rep("numeric", numCols - numMetadataCols - 1), rep("character", 11), "numeric", "numeric", "numeric", "character", "character", "numeric", "character", "character", "character")
    myT <-read.csv(inFileName, header=TRUE, sep="", colClasses=myColClasses, na.strings="BLAH", comment.char ="@")

    ## Removing unwanted samples {controls, replicates, duplicates, poor quality samples}
    removeControls<-c( "C1", "C2", "N1", "N2", "Neg", "Pos")
    myT<-myT[!(myT$Sample_ID %in% removeControls),]

    removetrs<-c("04_125_tr", "04_101_tr", "04_103_tr", "04_74_tr", "04_70_tr", "04_40_tr", "04_41_tr", "04_84_tr")
    myT<-myT[!(myT$Sample_ID %in% removetrs),]

    removeDups<-c("04-04_S63_L001_R1_001")
    myT<-myT[!(myT$MatchFile %in% removeDups),]

    ## Controls not dropped earlier
    manualDrop <- c("Neg_S40_L001_R1_001", "PCR1Neg_S65_L001_R1_001")
    myT<-myT[!(myT$MatchFile %in% manualDrop),]

    labDrop <- c("Harlan Labs")
    myT<-myT[!(myT$MouseOrigin %in% labDrop),]

    lowSeqDrop <- c("04-55_S32_L001_R1_001")
    myT<-myT[!(myT$MatchFile %in% lowSeqDrop),]
    ## Not sure what to do about this though.
    ### myT$Condition[which(myT$Treatment == "Ctrl", arr.ind = TRUE)]<-"Control"

    names <- vector()
    pValuesMultiway<-vector()
    pValuesSex<- vector()
    pValuesAcuteChronic<- vector()
    pValuesCage<- vector()
    iccCage <- vector()
    iccKeptCounts <- vector()
    pValuesBatch<- vector()
    pValuesTreatment<- vector()
    pValuesStressLength <- vector()
    pValuesInteraction <- vector()
    multiWay <- vector()
    allpvals <- list()
    allNames <- list()

    index <- 1

    for( i in 2:(ncol(myT) - numMetadataCols))
        if( sum(myT[,i] != 0 ) > nrow(myT) / 4 ){
            ## Easy access names
            bug <- myT[,i]
            ac <- myT$Condition
            sex <- myT$Sex
            cage <- myT$Cage
            batch <- myT$Sample_Plate
            date <- myT$Date
            mo <- myT$MouseOrigin
            group <- myT$SpreadsheetGrouping
            treatment <- myT$Treatment
            time <- myT$StressLength
            multiWay <- paste(ac, myT$StressLength)
            multiWay[which(myT$Treatment == "Ctrl", arr.ind = TRUE)]<-"Control"
            names[index] = names(myT)[i]
            ## Some kind of vector for the variables of interest
            myFrame <- data.frame(bug, ac, time, multiWay, sex, cage, treatment, batch, date, mo, date)
            mlm<-TRUE
            if(mlm == TRUE){
                fullModel <- gls( bug~   treatment*time + batch, method="REML",correlation=corCompSymm(form=~1|factor(group)),	data = myFrame )
                reducedModel <- gls( bug~ treatment*time + batch, method="REML", data = myFrame )
                fullModelLME <- lme(bug~  treatment*time + batch, method="REML", random = ~1|factor(group), data = myFrame)
            }
            else{
                fullModelLME <- lm(bug~ treatment*time + batch, x=TRUE)
            }
            ## Potential save time by reducing anova calls
            ## Introduce the goodness of fit tests here
            ## Can streamline vectors to be automatically responsive to changes to the model
            allNames <- rownames(anova(fullModelLME))[-1]
            allpvals[[index]] <- anova(fullModelLME)$"p-value"[-1]

            pValuesAcuteChronic[index] <- anova(fullModelLME)$"p-value"[2]
            pValuesTime[index] <- anova(fullModelLME)$"p-value"[6]
            pValuesInteraction[index] <- anova(fullModelLME)$"p-value"[6]
            pValuesSex[index] <- anova(fullModelLME)$"p-value"[6]
            pValuesExperiment[index] <- anova(fullModelLME)$"p-value"[6]
            pValuesBatch[index] <- anova(fullModelLME)$"p-value"[3]
            pValuesTreatment[index] <- anova(fullModelLME)$"p-value"[6]

            ## Random Effects and Interclass Correlation Coefficient
            if(mlm == TRUE){
                allNames<-c(allNames, "cage", "iccCage")
                allpvals[[index]]<-c(allpvals[[index]], anova(fullModelLME, reducedModel)$"p-value"[2], coef(fullModel$modelStruct[1]$corStruct,unconstrained=FALSE)[[1]])
                pValuesCage[index] <-  anova(fullModelLME, reducedModel)$"p-value"[2]
                ## This is different as it is not corrected for multiple hypothesis testing.
                iccCage[index]<- coef(fullModel$modelStruct[1]$corStruct,unconstrained=FALSE)[[1]]
            }
    ## Nice plotting
            ## Correct so that it uses corrected p-values
            graphMain = c(names[i], paste(c(rep("p-",length(allNames)-1),""), allNames, " = ", format(allpvals[[index]], digits=3), sep=""))
            ## graphMain =  paste( names(myT)[i], "\n",
            ##     ## " pTreatment= ", format(pValuesTreatment[index], digits=3),
            ##     ## " pTime= ", format(pValuesTime[index], digits=3),"\n",
            ##     ## " pTreatmentXTime= ", format(pValuesInteraction[index], digits=3),"\n",
            ##     ## " pSex=", format( pValuesSex[index], digits=3),
            ##     " pCondition= ", format( pValuesAcuteChronic[index],digits=3),
            ##     " pBatch= ", format(pValuesBatch[index], digits=3), "\n",
            ##     ## " pTreatment= ", format(pValuesTreatment[index], digits=3),
            ##     ## " pExperiment= ", format(pValuesExperiment[index], digits=3),
            ##     ## " pShannon= ", format(pValuesShannon[index], digits=3),
            ##     ## " pKeptCounts= ", format(pValuesKeptCounts[index], digits=3),
            ##     " pDate= " , format( pValuesCage[index], digits=3),
            ##     " icc= " , format( iccCage[index], digits=3 ), sep="")

            ## mlm is boolean 1/0 value. Basically, don't graph on icc
            numPlots <- length(allNames) - mlm
            par(mfrow=c(numPlots, 1),
                oma = c(1,1,0,0) + 0.1,
                mar = c(1,4,3,0) + 0.1)

            for(j in 1:numPlots){
                if(j == 1){
                    plot( bug ~ factor(get(allNames[j])), ylab = names[i], main = c(names[index],toString(graphMain[-1])) )
                    points(factor(get(allNames[j])), bug)
                }
                else{
                    plot( bug ~ factor(get(allNames[j])), ylab = names[i])
                    points(factor(get(allNames[j])), bug)
                }
            }
                ##plot( bug ~ factor(ac), ylab = names[index],main = graphMain )
                ##points(factor(ac), bug)

                ## plot ( bug ~ factor(ac) )
                ## points(factor(ac), bug)

                ## plot( bug ~ factor(c( paste( sl, treatment,sep=""))))
                ## points(factor(c( paste( sl, treatment,sep=""))), bug)

                ##plot ( bug ~ factor(batch) )
                ##points(factor(batch), bug)

                ##plot( bug ~ factor(date), ylab=names[index])
                ##points(factor(date), bug)

            index <- index + 1
	}

    ## This should also be dynamic
    dFrame <- as.data.frame(matrix(unlist(allpvals), nrow= length(allpvals), byrow=TRUE))
    colnames(dFrame) <- unlist(allNames)
    rownames(dFrame) <- names
    orgCol <- ncol(dFrame)

    for(k in 1:(orgCol-1)){
        dFrame[, k + orgCol]<-p.adjust(dFrame[,k], method = "BH")
    }
    colnames(dFrame)[(orgCol + 1):length(dFrame)]<-paste0(rep("adjusted_"),colnames(dFrame))
    ## dFrame <- data.frame( names, pValuesTreatment, pValuesBatch, pValuesCage, iccCage)
    ## pValuesTreatment)#, pValuesBatch)#, pValuesExperiment)

    ## dFrame <- dFrame[order(pValuesAcuteChronic),]
    ## dFrame$adjustedAcuteChronic <- p.adjust( dFrame$pValuesAcuteChronic, method = "BH" )
    ## dFrame$adjustedSex<- p.adjust( dFrame$pValuesSex, method = "BH" )
    ## dFrame$adjustedTreatment<- p.adjust( dFrame$pValuesTreatment, method = "BH" )
    ## dFrame$adjustedStressLength <- p.adjust( dFrame$pValuesStressLength, method = "BH")
    ## dFrame$adjustedInteraction <- p.adjust( dFrame$pValuesInteraction, method = "BH" )
    ## dFrame$adjustedBatch<- p.adjust( dFrame$pValuesBatch, method = "BH" )
    ## dFrame$adjustedCage <- p.adjust( dFrame$pValuesCage, method = "BH" )
    ## Try and dynamically generate the name of the plot here...
    write.table(dFrame, file=paste("pValuesForTaxa_bug_condition_batch_byDate_", taxa, ".txt",sep=""), sep="\t",row.names=FALSE)

    ## Get the sig table working
    ## It would also be nice to have a sig-picker for the plots and a combination of all sig results into one plot.
    keepVector <- grep("adj", names(dFrame))
    sigdFrame <-dFrame[which(dFrame[,keepVector] < 0.05,arr.ind=TRUE),]
    write.table(sigdFrame, file=paste("pValuesForTaxa_bug_condition_batch_byDate_sig_", taxa, ".txt",sep=""), sep="\t",row.names=FALSE)

    dev.off()
}

myColClasses
dim(myT)
colnames(myT)
rm(list=ls())

library("pscl")
library("lmtest")
library("nlme")
library("vegan")

setwd("/Users/mbrown67/Documents/Fodor/Datasets/MarkExperiment/Pooled/")

taxaLevels <- c( "phylum", "class", "order", "family", "genus")

for(taxa in taxaLevels){

    inFileName <- paste( taxa, "LogNormwithMetadata_R1_Pooled.txt", sep ="")
    myT <-read.csv(inFileName,header=TRUE,sep="", na.strings="BLAH")

    numCols <- ncol(myT)
    numMetadataCols <- 20

    ## Reprocessing for correct column data type
##    myColClasses <- c("character", rep("numeric", numCols - numMetadataCols - 1), rep("character", 16), "numeric", "numeric", "numeric", "character", "character", "numeric", "character", "character", "character")
##    myT <-read.csv(inFileName, header=TRUE, sep="", colClasses=myColClasses, na.strings="BLAH", comment.char ="@")

    ## Removing unwanted samples {controls, replicates, duplicates, poor quality samples}
    removeControls<-c( "C1", "C2", "N1", "N2", "Neg", "Pos")
    myT<-myT[!(myT$Sample_ID %in% removeControls),]

    removetrs<-c("04_125_tr", "04_101_tr", "04_103_tr", "04_74_tr", "04_70_tr", "04_40_tr", "04_41_tr", "04_84_tr")
    myT<-myT[!(myT$Sample_ID %in% removetrs),]

    removeDups<-c("04-04_S63_L001_R1_001")
    myT<-myT[!(myT$MatchFile %in% removeDups),]

    ## Controls not dropped earlier
    manualDrop <- c("Neg_S40_L001_R1_001", "PCR1Neg_S65_L001_R1_001")
    myT<-myT[!(myT$MatchFile %in% manualDrop),]

    labDrop <- c("Harlan Labs")
    myT<-myT[!(myT$MouseOrigin %in% labDrop),]

    lowSeqDrop <- c("04-55_S32_L001_R1_001")
    myT<-myT[!(myT$MatchFile %in% lowSeqDrop),]
    ## Not sure what to do about this though.
    ### myT$Condition[which(myT$Treatment == "Ctrl", arr.ind = TRUE)]<-"Control"

    names <- vector()
    pValuesMultiway<-vector()
    pValuesSex<- vector()
    pValuesAcuteChronic<- vector()
    pValuesCage<- vector()
    iccCage <- vector()
    iccKeptCounts <- vector()
    pValuesBatch<- vector()
    pValuesTreatment<- vector()
    pValuesStressLength <- vector()
    pValuesInteraction <- vector()
    multiWay <- vector()
    allpvals <- list()
    allNames <- list()

    index <- 1

    for( i in 2:(ncol(myT) - numMetadataCols))
        if( sum(myT[,i] != 0 ) > nrow(myT) / 4 ){
            ## Easy access names
            bug <- myT[,i]
            ac <- myT$Condition
            sex <- myT$Sex
            cage <- myT$Cage
            batch <- myT$Sample_Plate
            date <- myT$Date
            mo <- myT$MouseOrigin
            group <- myT$SpreadsheetGrouping
            treatment <- myT$Treatment
            time <- myT$StressLength
            multiWay <- paste(ac, myT$StressLength)
            multiWay[which(myT$Treatment == "Ctrl", arr.ind = TRUE)]<-"Control"
            names[index] = names(myT)[i]
            ## Some kind of vector for the variables of interest
            myFrame <- data.frame(bug, ac, time, multiWay, sex, cage, treatment, batch, date, mo, date)
            mlm<-TRUE
            if(mlm == TRUE){
                fullModel <- gls( bug~   treatment*time + batch, method="REML",correlation=corCompSymm(form=~1|factor(group)),	data = myFrame )
                reducedModel <- gls( bug~ treatment*time + batch, method="REML", data = myFrame )
                fullModelLME <- lme(bug~  treatment*time + batch, method="REML", random = ~1|factor(group), data = myFrame)
            }
            else{
                fullModelLME <- lm(bug~ treatment*time + batch, x=TRUE)
            }
            ## Potential save time by reducing anova calls
            ## Introduce the goodness of fit tests here
            ## Can streamline vectors to be automatically responsive to changes to the model
            allNames <- rownames(anova(fullModelLME))[-1]
            allpvals[[index]] <- anova(fullModelLME)$"p-value"[-1]

            pValuesAcuteChronic[index] <- anova(fullModelLME)$"p-value"[2]
            pValuesTime[index] <- anova(fullModelLME)$"p-value"[6]
            pValuesInteraction[index] <- anova(fullModelLME)$"p-value"[6]
            pValuesSex[index] <- anova(fullModelLME)$"p-value"[6]
            pValuesExperiment[index] <- anova(fullModelLME)$"p-value"[6]
            pValuesBatch[index] <- anova(fullModelLME)$"p-value"[3]
            pValuesTreatment[index] <- anova(fullModelLME)$"p-value"[6]

            ## Random Effects and Interclass Correlation Coefficient
            if(mlm == TRUE){
                allNames<-c(allNames, "cage", "iccCage")
                allpvals[[index]]<-c(allpvals[[index]], anova(fullModelLME, reducedModel)$"p-value"[2], coef(fullModel$modelStruct[1]$corStruct,unconstrained=FALSE)[[1]])
                pValuesCage[index] <-  anova(fullModelLME, reducedModel)$"p-value"[2]
                ## This is different as it is not corrected for multiple hypothesis testing.
                iccCage[index]<- coef(fullModel$modelStruct[1]$corStruct,unconstrained=FALSE)[[1]]
            }
    ## Nice plotting
            ## Correct so that it uses corrected p-values
            graphMain = c(names[i], paste(c(rep("p-",length(allNames)-1),""), allNames, " = ", format(allpvals[[index]], digits=3), sep=""))
            ## graphMain =  paste( names(myT)[i], "\n",
            ##     ## " pTreatment= ", format(pValuesTreatment[index], digits=3),
            ##     ## " pTime= ", format(pValuesTime[index], digits=3),"\n",
            ##     ## " pTreatmentXTime= ", format(pValuesInteraction[index], digits=3),"\n",
            ##     ## " pSex=", format( pValuesSex[index], digits=3),
            ##     " pCondition= ", format( pValuesAcuteChronic[index],digits=3),
            ##     " pBatch= ", format(pValuesBatch[index], digits=3), "\n",
            ##     ## " pTreatment= ", format(pValuesTreatment[index], digits=3),
            ##     ## " pExperiment= ", format(pValuesExperiment[index], digits=3),
            ##     ## " pShannon= ", format(pValuesShannon[index], digits=3),
            ##     ## " pKeptCounts= ", format(pValuesKeptCounts[index], digits=3),
            ##     " pDate= " , format( pValuesCage[index], digits=3),
            ##     " icc= " , format( iccCage[index], digits=3 ), sep="")

            ## mlm is boolean 1/0 value. Basically, don't graph on icc
            numPlots <- length(allNames) - mlm
            par(mfrow=c(numPlots, 1),
                oma = c(1,1,0,0) + 0.1,
                mar = c(1,4,3,0) + 0.1)

            for(j in 1:numPlots){
                if(j == 1){
                    plot( bug ~ factor(get(allNames[j])), ylab = names[i], main = c(names[index],toString(graphMain[-1])) )
                    points(factor(get(allNames[j])), bug)
                }
                else{
                    plot( bug ~ factor(get(allNames[j])), ylab = names[i])
                    points(factor(get(allNames[j])), bug)
                }
            }
                ##plot( bug ~ factor(ac), ylab = names[index],main = graphMain )
                ##points(factor(ac), bug)

                ## plot ( bug ~ factor(ac) )
                ## points(factor(ac), bug)

                ## plot( bug ~ factor(c( paste( sl, treatment,sep=""))))
                ## points(factor(c( paste( sl, treatment,sep=""))), bug)

                ##plot ( bug ~ factor(batch) )
                ##points(factor(batch), bug)

                ##plot( bug ~ factor(date), ylab=names[index])
                ##points(factor(date), bug)

            index <- index + 1
	}

    ## This should also be dynamic
    dFrame <- as.data.frame(matrix(unlist(allpvals), nrow= length(allpvals), byrow=TRUE))
    colnames(dFrame) <- unlist(allNames)
    rownames(dFrame) <- names
    orgCol <- ncol(dFrame)

    for(k in 1:(orgCol-1)){
        dFrame[, k + orgCol]<-p.adjust(dFrame[,k], method = "BH")
    }
    colnames(dFrame)[(orgCol + 1):length(dFrame)]<-paste0(rep("adjusted_"),colnames(dFrame))
    ## dFrame <- data.frame( names, pValuesTreatment, pValuesBatch, pValuesCage, iccCage)
    ## pValuesTreatment)#, pValuesBatch)#, pValuesExperiment)

    ## dFrame <- dFrame[order(pValuesAcuteChronic),]
    ## dFrame$adjustedAcuteChronic <- p.adjust( dFrame$pValuesAcuteChronic, method = "BH" )
    ## dFrame$adjustedSex<- p.adjust( dFrame$pValuesSex, method = "BH" )
    ## dFrame$adjustedTreatment<- p.adjust( dFrame$pValuesTreatment, method = "BH" )
    ## dFrame$adjustedStressLength <- p.adjust( dFrame$pValuesStressLength, method = "BH")
    ## dFrame$adjustedInteraction <- p.adjust( dFrame$pValuesInteraction, method = "BH" )
    ## dFrame$adjustedBatch<- p.adjust( dFrame$pValuesBatch, method = "BH" )
    ## dFrame$adjustedCage <- p.adjust( dFrame$pValuesCage, method = "BH" )
    ## Try and dynamically generate the name of the plot here...
    write.table(dFrame, file=paste("pValuesForTaxa_bug_condition_batch_byDate_", taxa, ".txt",sep=""), sep="\t",row.names=FALSE)

    ## Get the sig table working
    ## It would also be nice to have a sig-picker for the plots and a combination of all sig results into one plot.
    keepVector <- grep("adj", names(dFrame))
    sigdFrame <-dFrame[which(dFrame[,keepVector] < 0.05,arr.ind=TRUE),]
    write.table(sigdFrame, file=paste("pValuesForTaxa_bug_condition_batch_byDate_sig_", taxa, ".txt",sep=""), sep="\t",row.names=FALSE)

    dev.off()
}

rm(list=ls())

library("pscl")
library("lmtest")
library("nlme")
library("vegan")

setwd("/Users/mbrown67/Documents/Fodor/Datasets/MarkExperiment/Pooled/")

taxaLevels <- c( "phylum", "class", "order", "family", "genus")

for(taxa in taxaLevels){

    inFileName <- paste( taxa, "LogNormwithMetadata_R1_Pooled.txt", sep ="")
    myT <-read.csv(inFileName,header=TRUE,sep="", na.strings="BLAH")

    numCols <- ncol(myT)
    numMetadataCols <- 20

    ## Reprocessing for correct column data type
##    myColClasses <- c("character", rep("numeric", numCols - numMetadataCols - 1), rep("character", 16), "numeric", "numeric", "numeric", "character", "character", "numeric", "character", "character", "character")
##    myT <-read.csv(inFileName, header=TRUE, sep="", colClasses=myColClasses, na.strings="BLAH", comment.char ="@")

    ## Removing unwanted samples {controls, replicates, duplicates, poor quality samples}
    removeControls<-c( "C1", "C2", "N1", "N2", "Neg", "Pos")
    myT<-myT[!(myT$Sample_ID %in% removeControls),]

    removetrs<-c("04_125_tr", "04_101_tr", "04_103_tr", "04_74_tr", "04_70_tr", "04_40_tr", "04_41_tr", "04_84_tr")
    myT<-myT[!(myT$Sample_ID %in% removetrs),]

    removeDups<-c("04-04_S63_L001_R1_001")
    myT<-myT[!(myT$MatchFile %in% removeDups),]

    ## Controls not dropped earlier
    manualDrop <- c("Neg_S40_L001_R1_001", "PCR1Neg_S65_L001_R1_001")
    myT<-myT[!(myT$MatchFile %in% manualDrop),]

    labDrop <- c("Harlan Labs")
    myT<-myT[!(myT$MouseOrigin %in% labDrop),]

    lowSeqDrop <- c("04-55_S32_L001_R1_001")
    myT<-myT[!(myT$MatchFile %in% lowSeqDrop),]
    ## Not sure what to do about this though.
    ### myT$Condition[which(myT$Treatment == "Ctrl", arr.ind = TRUE)]<-"Control"

    names <- vector()
    pValuesSex<- vector()
    pValuesAcuteChronic<- vector()
    pValuesCage<- vector()
    iccCage <- vector()
    iccKeptCounts <- vector()
    pValuesBatch<- vector()
    pValuesTreatment<- vector()
    pValuesTime <- vector()
    pValuesStressLength <- vector()
    pValuesInteraction <- vector()
    allpvals <- list()

    index <- 1

    for( i in 2:(ncol(myT) - numMetadataCols))
        if( sum(myT[,i] != 0 ) > nrow(myT) / 4 ){
            ## Easy access names
            bug <- myT[,i]
            ac <- myT$Condition
            sex <- myT$Sex
            cage <- myT$Cage
            batch <- myT$Sample_Plate
            date <- myT$Date
            mo <- myT$MouseOrigin
            group <- myT$SpreadsheetGrouping
            treatment <- myT$Treatment
            time <- myT$StressLength
            multiWay <- paste(ac, myT$StressLength)
            multiWay[which(myT$Treatment == "Ctrl", arr.ind = TRUE)]<-"Control"
            names[index] = names(myT)[i]
            ## Some kind of vector for the variables of interest
            myFrame <- data.frame(bug, ac, time, multiWay, sex, cage, treatment, batch, date, mo, date)
            mlm<-TRUE
            if(mlm == TRUE){
                fullModel <- gls( bug~   treatment*time + batch, method="REML",correlation=corCompSymm(form=~1|factor(group)),	data = myFrame )
                reducedModel <- gls( bug~ treatment*time + batch, method="REML", data = myFrame )
                fullModelLME <- lme(bug~  treatment*time + batch, method="REML", random = ~1|factor(group), data = myFrame)
            }
            else{
                fullModelLME <- lm(bug~ treatment*time + batch, x=TRUE)
            }
            ## Potential save time by reducing anova calls
            ## Introduce the goodness of fit tests here
            ## Can streamline vectors to be automatically responsive to changes to the model
            allNames <- rownames(anova(fullModelLME))[-1]
            allpvals[[index]] <- anova(fullModelLME)$"p-value"[-1]

            pValuesAcuteChronic[index] <- anova(fullModelLME)$"p-value"[2]
            pValuesTime[index] <- anova(fullModelLME)$"p-value"[6]
            pValuesInteraction[index] <- anova(fullModelLME)$"p-value"[6]
            pValuesSex[index] <- anova(fullModelLME)$"p-value"[6]
            pValuesExperiment[index] <- anova(fullModelLME)$"p-value"[6]
            pValuesBatch[index] <- anova(fullModelLME)$"p-value"[3]
            pValuesTreatment[index] <- anova(fullModelLME)$"p-value"[6]

            ## Random Effects and Interclass Correlation Coefficient
            if(mlm == TRUE){
                allNames<-c(allNames, "cage", "iccCage")
                allpvals[[index]]<-c(allpvals[[index]], anova(fullModelLME, reducedModel)$"p-value"[2], coef(fullModel$modelStruct[1]$corStruct,unconstrained=FALSE)[[1]])
                pValuesCage[index] <-  anova(fullModelLME, reducedModel)$"p-value"[2]
                ## This is different as it is not corrected for multiple hypothesis testing.
                iccCage[index]<- coef(fullModel$modelStruct[1]$corStruct,unconstrained=FALSE)[[1]]
            }
    ## Nice plotting
            ## Correct so that it uses corrected p-values
            graphMain = c(names[i], paste(c(rep("p-",length(allNames)-1),""), allNames, " = ", format(allpvals[[index]], digits=3), sep=""))
            ## graphMain =  paste( names(myT)[i], "\n",
            ##     ## " pTreatment= ", format(pValuesTreatment[index], digits=3),
            ##     ## " pTime= ", format(pValuesTime[index], digits=3),"\n",
            ##     ## " pTreatmentXTime= ", format(pValuesInteraction[index], digits=3),"\n",
            ##     ## " pSex=", format( pValuesSex[index], digits=3),
            ##     " pCondition= ", format( pValuesAcuteChronic[index],digits=3),
            ##     " pBatch= ", format(pValuesBatch[index], digits=3), "\n",
            ##     ## " pTreatment= ", format(pValuesTreatment[index], digits=3),
            ##     ## " pExperiment= ", format(pValuesExperiment[index], digits=3),
            ##     ## " pShannon= ", format(pValuesShannon[index], digits=3),
            ##     ## " pKeptCounts= ", format(pValuesKeptCounts[index], digits=3),
            ##     " pDate= " , format( pValuesCage[index], digits=3),
            ##     " icc= " , format( iccCage[index], digits=3 ), sep="")

            ## mlm is boolean 1/0 value. Basically, don't graph on icc
            numPlots <- length(allNames) - mlm
            par(mfrow=c(numPlots, 1),
                oma = c(1,1,0,0) + 0.1,
                mar = c(1,4,3,0) + 0.1)

            for(j in 1:numPlots){
                if(j == 1){
                    plot( bug ~ factor(get(allNames[j])), ylab = names[i], main = c(names[index],toString(graphMain[-1])) )
                    points(factor(get(allNames[j])), bug)
                }
                else{
                    plot( bug ~ factor(get(allNames[j])), ylab = names[i])
                    points(factor(get(allNames[j])), bug)
                }
            }
                ##plot( bug ~ factor(ac), ylab = names[index],main = graphMain )
                ##points(factor(ac), bug)

                ## plot ( bug ~ factor(ac) )
                ## points(factor(ac), bug)

                ## plot( bug ~ factor(c( paste( sl, treatment,sep=""))))
                ## points(factor(c( paste( sl, treatment,sep=""))), bug)

                ##plot ( bug ~ factor(batch) )
                ##points(factor(batch), bug)

                ##plot( bug ~ factor(date), ylab=names[index])
                ##points(factor(date), bug)

            index <- index + 1
	}

    ## This should also be dynamic
    dFrame <- as.data.frame(matrix(unlist(allpvals), nrow= length(allpvals), byrow=TRUE))
    colnames(dFrame) <- unlist(allNames)
    rownames(dFrame) <- names
    orgCol <- ncol(dFrame)

    for(k in 1:(orgCol-1)){
        dFrame[, k + orgCol]<-p.adjust(dFrame[,k], method = "BH")
    }
    colnames(dFrame)[(orgCol + 1):length(dFrame)]<-paste0(rep("adjusted_"),colnames(dFrame))
    ## dFrame <- data.frame( names, pValuesTreatment, pValuesBatch, pValuesCage, iccCage)
    ## pValuesTreatment)#, pValuesBatch)#, pValuesExperiment)

    ## dFrame <- dFrame[order(pValuesAcuteChronic),]
    ## dFrame$adjustedAcuteChronic <- p.adjust( dFrame$pValuesAcuteChronic, method = "BH" )
    ## dFrame$adjustedSex<- p.adjust( dFrame$pValuesSex, method = "BH" )
    ## dFrame$adjustedTreatment<- p.adjust( dFrame$pValuesTreatment, method = "BH" )
    ## dFrame$adjustedStressLength <- p.adjust( dFrame$pValuesStressLength, method = "BH")
    ## dFrame$adjustedInteraction <- p.adjust( dFrame$pValuesInteraction, method = "BH" )
    ## dFrame$adjustedBatch<- p.adjust( dFrame$pValuesBatch, method = "BH" )
    ## dFrame$adjustedCage <- p.adjust( dFrame$pValuesCage, method = "BH" )
    ## Try and dynamically generate the name of the plot here...
    write.table(dFrame, file=paste("pValuesForTaxa_bug_condition_batch_byDate_", taxa, ".txt",sep=""), sep="\t",row.names=FALSE)

    ## Get the sig table working
    ## It would also be nice to have a sig-picker for the plots and a combination of all sig results into one plot.
    keepVector <- grep("adj", names(dFrame))
    sigdFrame <-dFrame[which(dFrame[,keepVector] < 0.05,arr.ind=TRUE),]
    write.table(sigdFrame, file=paste("pValuesForTaxa_bug_condition_batch_byDate_sig_", taxa, ".txt",sep=""), sep="\t",row.names=FALSE)

    dev.off()
}

rm(list=ls())

library("pscl")
library("lmtest")
library("nlme")
library("vegan")

setwd("/Users/mbrown67/Documents/Fodor/Datasets/MarkExperiment/Pooled/")

taxaLevels <- c( "phylum", "class", "order", "family", "genus")

for(taxa in taxaLevels){

    inFileName <- paste( taxa, "LogNormwithMetadata_R1_Pooled.txt", sep ="")
    myT <-read.csv(inFileName,header=TRUE,sep="", na.strings="BLAH")

    numCols <- ncol(myT)
    numMetadataCols <- 20

    ## Reprocessing for correct column data type
##    myColClasses <- c("character", rep("numeric", numCols - numMetadataCols - 1), rep("character", 16), "numeric", "numeric", "numeric", "character", "character", "numeric", "character", "character", "character")
##    myT <-read.csv(inFileName, header=TRUE, sep="", colClasses=myColClasses, na.strings="BLAH", comment.char ="@")

    ## Removing unwanted samples {controls, replicates, duplicates, poor quality samples}
    removeControls<-c( "C1", "C2", "N1", "N2", "Neg", "Pos")
    myT<-myT[!(myT$Sample_ID %in% removeControls),]

    removetrs<-c("04_125_tr", "04_101_tr", "04_103_tr", "04_74_tr", "04_70_tr", "04_40_tr", "04_41_tr", "04_84_tr")
    myT<-myT[!(myT$Sample_ID %in% removetrs),]

    removeDups<-c("04-04_S63_L001_R1_001")
    myT<-myT[!(myT$MatchFile %in% removeDups),]

    ## Controls not dropped earlier
    manualDrop <- c("Neg_S40_L001_R1_001", "PCR1Neg_S65_L001_R1_001")
    myT<-myT[!(myT$MatchFile %in% manualDrop),]

    labDrop <- c("Harlan Labs")
    myT<-myT[!(myT$MouseOrigin %in% labDrop),]

    lowSeqDrop <- c("04-55_S32_L001_R1_001")
    myT<-myT[!(myT$MatchFile %in% lowSeqDrop),]
    ## Not sure what to do about this though.
    ### myT$Condition[which(myT$Treatment == "Ctrl", arr.ind = TRUE)]<-"Control"

    names <- vector()
    pValuesSex<- vector()
    pValuesAcuteChronic<- vector()
    pValuesCage<- vector()
    iccCage <- vector()
    iccKeptCounts <- vector()
    pValuesBatch<- vector()
    pValuesTreatment<- vector()
    pValuesTime <- vector()
    pValuesStressLength <- vector()
    pValuesInteraction <- vector()
    allpvals <- list()

    index <- 1

    for( i in 2:(ncol(myT) - numMetadataCols))
        if( sum(myT[,i] != 0 ) > nrow(myT) / 4 ){
            ## Easy access names
            bug <- myT[,i]
            ac <- myT$Condition
            sex <- myT$Sex
            cage <- myT$Cage
            batch <- myT$Sample_Plate
            date <- myT$Date
            mo <- myT$MouseOrigin
            group <- myT$SpreadsheetGrouping
            treatment <- myT$Treatment
            time <- myT$StressLength
            multiWay <- paste(ac, myT$StressLength)
            multiWay[which(myT$Treatment == "Ctrl", arr.ind = TRUE)]<-"Control"
            names[index] = names(myT)[i]
            ## Some kind of vector for the variables of interest
            myFrame <- data.frame(bug, ac, time, multiWay, sex, cage, treatment, batch, date, mo, date)
            mlm<-TRUE
            if(mlm == TRUE){
                fullModel <- gls( bug~   treatment*time + batch, method="REML",correlation=corCompSymm(form=~1|factor(group)),	data = myFrame )
                reducedModel <- gls( bug~ treatment*time + batch, method="REML", data = myFrame )
                fullModelLME <- lme(bug~  treatment*time + batch, method="REML", random = ~1|factor(group), data = myFrame)
            }
            else{
                fullModelLME <- lm(bug~ treatment*time + batch, x=TRUE)
            }
            ## Potential save time by reducing anova calls
            ## Introduce the goodness of fit tests here
            ## Can streamline vectors to be automatically responsive to changes to the model
            allNames <- rownames(anova(fullModelLME))[-1]
            allpvals[[index]] <- anova(fullModelLME)$"p-value"[-1]

            ## pValuesAcuteChronic[index] <- anova(fullModelLME)$"p-value"[2]
            ## pValuesTime[index] <- anova(fullModelLME)$"p-value"[6]
            ## pValuesInteraction[index] <- anova(fullModelLME)$"p-value"[6]
            ## pValuesSex[index] <- anova(fullModelLME)$"p-value"[6]
            ## pValuesExperiment[index] <- anova(fullModelLME)$"p-value"[6]
            ## pValuesBatch[index] <- anova(fullModelLME)$"p-value"[3]
            ## pValuesTreatment[index] <- anova(fullModelLME)$"p-value"[6]

            ## Random Effects and Interclass Correlation Coefficient
            if(mlm == TRUE){
                allNames<-c(allNames, "cage", "iccCage")
                allpvals[[index]]<-c(allpvals[[index]], anova(fullModelLME, reducedModel)$"p-value"[2], coef(fullModel$modelStruct[1]$corStruct,unconstrained=FALSE)[[1]])
                pValuesCage[index] <-  anova(fullModelLME, reducedModel)$"p-value"[2]
                ## This is different as it is not corrected for multiple hypothesis testing.
                iccCage[index]<- coef(fullModel$modelStruct[1]$corStruct,unconstrained=FALSE)[[1]]
            }
    ## Nice plotting
            ## Correct so that it uses corrected p-values
            graphMain = c(names[i], paste(c(rep("p-",length(allNames)-1),""), allNames, " = ", format(allpvals[[index]], digits=3), sep=""))
            ## graphMain =  paste( names(myT)[i], "\n",
            ##     ## " pTreatment= ", format(pValuesTreatment[index], digits=3),
            ##     ## " pTime= ", format(pValuesTime[index], digits=3),"\n",
            ##     ## " pTreatmentXTime= ", format(pValuesInteraction[index], digits=3),"\n",
            ##     ## " pSex=", format( pValuesSex[index], digits=3),
            ##     " pCondition= ", format( pValuesAcuteChronic[index],digits=3),
            ##     " pBatch= ", format(pValuesBatch[index], digits=3), "\n",
            ##     ## " pTreatment= ", format(pValuesTreatment[index], digits=3),
            ##     ## " pExperiment= ", format(pValuesExperiment[index], digits=3),
            ##     ## " pShannon= ", format(pValuesShannon[index], digits=3),
            ##     ## " pKeptCounts= ", format(pValuesKeptCounts[index], digits=3),
            ##     " pDate= " , format( pValuesCage[index], digits=3),
            ##     " icc= " , format( iccCage[index], digits=3 ), sep="")

            ## mlm is boolean 1/0 value. Basically, don't graph on icc
            numPlots <- length(allNames) - mlm
            par(mfrow=c(numPlots, 1),
                oma = c(1,1,0,0) + 0.1,
                mar = c(1,4,3,0) + 0.1)

            for(j in 1:numPlots){
                if(j == 1){
                    plot( bug ~ factor(get(allNames[j])), ylab = names[i], main = c(names[index],toString(graphMain[-1])) )
                    points(factor(get(allNames[j])), bug)
                }
                else{
                    plot( bug ~ factor(get(allNames[j])), ylab = names[i])
                    points(factor(get(allNames[j])), bug)
                }
            }
                ##plot( bug ~ factor(ac), ylab = names[index],main = graphMain )
                ##points(factor(ac), bug)

                ## plot ( bug ~ factor(ac) )
                ## points(factor(ac), bug)

                ## plot( bug ~ factor(c( paste( sl, treatment,sep=""))))
                ## points(factor(c( paste( sl, treatment,sep=""))), bug)

                ##plot ( bug ~ factor(batch) )
                ##points(factor(batch), bug)

                ##plot( bug ~ factor(date), ylab=names[index])
                ##points(factor(date), bug)

            index <- index + 1
	}

    ## This should also be dynamic
    dFrame <- as.data.frame(matrix(unlist(allpvals), nrow= length(allpvals), byrow=TRUE))
    colnames(dFrame) <- unlist(allNames)
    rownames(dFrame) <- names
    orgCol <- ncol(dFrame)

    for(k in 1:(orgCol-1)){
        dFrame[, k + orgCol]<-p.adjust(dFrame[,k], method = "BH")
    }
    colnames(dFrame)[(orgCol + 1):length(dFrame)]<-paste0(rep("adjusted_"),colnames(dFrame))
    ## dFrame <- data.frame( names, pValuesTreatment, pValuesBatch, pValuesCage, iccCage)
    ## pValuesTreatment)#, pValuesBatch)#, pValuesExperiment)

    ## dFrame <- dFrame[order(pValuesAcuteChronic),]
    ## dFrame$adjustedAcuteChronic <- p.adjust( dFrame$pValuesAcuteChronic, method = "BH" )
    ## dFrame$adjustedSex<- p.adjust( dFrame$pValuesSex, method = "BH" )
    ## dFrame$adjustedTreatment<- p.adjust( dFrame$pValuesTreatment, method = "BH" )
    ## dFrame$adjustedStressLength <- p.adjust( dFrame$pValuesStressLength, method = "BH")
    ## dFrame$adjustedInteraction <- p.adjust( dFrame$pValuesInteraction, method = "BH" )
    ## dFrame$adjustedBatch<- p.adjust( dFrame$pValuesBatch, method = "BH" )
    ## dFrame$adjustedCage <- p.adjust( dFrame$pValuesCage, method = "BH" )
    ## Try and dynamically generate the name of the plot here...
    write.table(dFrame, file=paste("pValuesForTaxa_bug_condition_batch_byDate_", taxa, ".txt",sep=""), sep="\t",row.names=FALSE)

    ## Get the sig table working
    ## It would also be nice to have a sig-picker for the plots and a combination of all sig results into one plot.
    keepVector <- grep("adj", names(dFrame))
    sigdFrame <-dFrame[which(dFrame[,keepVector] < 0.05,arr.ind=TRUE),]
    write.table(sigdFrame, file=paste("pValuesForTaxa_bug_condition_batch_byDate_sig_", taxa, ".txt",sep=""), sep="\t",row.names=FALSE)

    dev.off()
}

allNames
get("treatment:time")
ls()
grep(":", allNames)
grep("?", allNames)
grep("freq", allNames)
if(grep(":", allNames))
{}
if(grep(":", allNames)!=0){}


{}
if(grep(":", allNames) > 0){print("check")}
if(grep("freq", allNames) > 0){print("check")}
if(grep("freq", allNames)){print("check")}
if(length(grep("freq", allNames))){print("check")}
if(length(grep(":", allNames))){print("check")}
strsplit(allNames[grep(":",allNames)],split=":")
unlist(strsplit(allNames[grep(":",allNames)],split=":"))
rm(list=ls())

library("pscl")
library("lmtest")
library("nlme")
library("vegan")

setwd("/Users/mbrown67/Documents/Fodor/Datasets/MarkExperiment/Pooled/")

taxaLevels <- c( "phylum", "class", "order", "family", "genus")

for(taxa in taxaLevels){

    inFileName <- paste( taxa, "LogNormwithMetadata_R1_Pooled.txt", sep ="")
    myT <-read.csv(inFileName,header=TRUE,sep="", na.strings="BLAH")

    numCols <- ncol(myT)
    numMetadataCols <- 20

    ## Reprocessing for correct column data type
##    myColClasses <- c("character", rep("numeric", numCols - numMetadataCols - 1), rep("character", 16), "numeric", "numeric", "numeric", "character", "character", "numeric", "character", "character", "character")
##    myT <-read.csv(inFileName, header=TRUE, sep="", colClasses=myColClasses, na.strings="BLAH", comment.char ="@")

    ## Removing unwanted samples {controls, replicates, duplicates, poor quality samples}
    removeControls<-c( "C1", "C2", "N1", "N2", "Neg", "Pos")
    myT<-myT[!(myT$Sample_ID %in% removeControls),]

    removetrs<-c("04_125_tr", "04_101_tr", "04_103_tr", "04_74_tr", "04_70_tr", "04_40_tr", "04_41_tr", "04_84_tr")
    myT<-myT[!(myT$Sample_ID %in% removetrs),]

    removeDups<-c("04-04_S63_L001_R1_001")
    myT<-myT[!(myT$MatchFile %in% removeDups),]

    ## Controls not dropped earlier
    manualDrop <- c("Neg_S40_L001_R1_001", "PCR1Neg_S65_L001_R1_001")
    myT<-myT[!(myT$MatchFile %in% manualDrop),]

    labDrop <- c("Harlan Labs")
    myT<-myT[!(myT$MouseOrigin %in% labDrop),]

    lowSeqDrop <- c("04-55_S32_L001_R1_001")
    myT<-myT[!(myT$MatchFile %in% lowSeqDrop),]
    ## Not sure what to do about this though.
    ### myT$Condition[which(myT$Treatment == "Ctrl", arr.ind = TRUE)]<-"Control"

    names <- vector()
    pValuesSex<- vector()
    pValuesAcuteChronic<- vector()
    pValuesCage<- vector()
    iccCage <- vector()
    iccKeptCounts <- vector()
    pValuesBatch<- vector()
    pValuesTreatment<- vector()
    pValuesTime <- vector()
    pValuesStressLength <- vector()
    pValuesInteraction <- vector()
    allpvals <- list()

    index <- 1

    for( i in 2:(ncol(myT) - numMetadataCols))
        if( sum(myT[,i] != 0 ) > nrow(myT) / 4 ){
            ## Easy access names
            bug <- myT[,i]
            ac <- myT$Condition
            sex <- myT$Sex
            cage <- myT$Cage
            batch <- myT$Sample_Plate
            date <- myT$Date
            mo <- myT$MouseOrigin
            group <- myT$SpreadsheetGrouping
            treatment <- myT$Treatment
            time <- myT$StressLength
            multiWay <- paste(ac, myT$StressLength)
            multiWay[which(myT$Treatment == "Ctrl", arr.ind = TRUE)]<-"Control"
            names[index] = names(myT)[i]
            ## Some kind of vector for the variables of interest
            myFrame <- data.frame(bug, ac, time, multiWay, sex, cage, treatment, batch, date, mo, date)
            mlm<-TRUE
            if(mlm == TRUE){
                fullModel <- gls( bug~   treatment*time + batch, method="REML",correlation=corCompSymm(form=~1|factor(group)),	data = myFrame )
                reducedModel <- gls( bug~ treatment*time + batch, method="REML", data = myFrame )
                fullModelLME <- lme(bug~  treatment*time + batch, method="REML", random = ~1|factor(group), data = myFrame)
            }
            else{
                fullModelLME <- lm(bug~ treatment*time + batch, x=TRUE)
            }
            ## Potential save time by reducing anova calls
            ## Introduce the goodness of fit tests here
            ## Can streamline vectors to be automatically responsive to changes to the model
            allNames <- rownames(anova(fullModelLME))[-1]
            allpvals[[index]] <- anova(fullModelLME)$"p-value"[-1]

            ## pValuesAcuteChronic[index] <- anova(fullModelLME)$"p-value"[2]
            ## pValuesTime[index] <- anova(fullModelLME)$"p-value"[6]
            ## pValuesInteraction[index] <- anova(fullModelLME)$"p-value"[6]
            ## pValuesSex[index] <- anova(fullModelLME)$"p-value"[6]
            ## pValuesExperiment[index] <- anova(fullModelLME)$"p-value"[6]
            ## pValuesBatch[index] <- anova(fullModelLME)$"p-value"[3]
            ## pValuesTreatment[index] <- anova(fullModelLME)$"p-value"[6]

            ## Random Effects and Interclass Correlation Coefficient
            if(mlm == TRUE){
                allNames<-c(allNames, "cage", "iccCage")
                allpvals[[index]]<-c(allpvals[[index]], anova(fullModelLME, reducedModel)$"p-value"[2], coef(fullModel$modelStruct[1]$corStruct,unconstrained=FALSE)[[1]])
                pValuesCage[index] <-  anova(fullModelLME, reducedModel)$"p-value"[2]
                ## This is different as it is not corrected for multiple hypothesis testing.
                iccCage[index]<- coef(fullModel$modelStruct[1]$corStruct,unconstrained=FALSE)[[1]]
            }
    ## Nice plotting
            ## Correct so that it uses corrected p-values
            graphMain = c(names[i], paste(c(rep("p-",length(allNames)-1),""), allNames, " = ", format(allpvals[[index]], digits=3), sep=""))
            ## graphMain =  paste( names(myT)[i], "\n",
            ##     ## " pTreatment= ", format(pValuesTreatment[index], digits=3),
            ##     ## " pTime= ", format(pValuesTime[index], digits=3),"\n",
            ##     ## " pTreatmentXTime= ", format(pValuesInteraction[index], digits=3),"\n",
            ##     ## " pSex=", format( pValuesSex[index], digits=3),
            ##     " pCondition= ", format( pValuesAcuteChronic[index],digits=3),
            ##     " pBatch= ", format(pValuesBatch[index], digits=3), "\n",
            ##     ## " pTreatment= ", format(pValuesTreatment[index], digits=3),
            ##     ## " pExperiment= ", format(pValuesExperiment[index], digits=3),
            ##     ## " pShannon= ", format(pValuesShannon[index], digits=3),
            ##     ## " pKeptCounts= ", format(pValuesKeptCounts[index], digits=3),
            ##     " pDate= " , format( pValuesCage[index], digits=3),
            ##     " icc= " , format( iccCage[index], digits=3 ), sep="")

            ## mlm is boolean 1/0 value. Basically, don't graph on icc
            ## need a correction for interaction terms as well
            numPlots <- length(allNames) - mlm
            par(mfrow=c(numPlots, 1),
                oma = c(1,1,0,0) + 0.1,
                mar = c(1,4,3,0) + 0.1)

            for(j in 1:numPlots){
                if(j == 1){
                    plot( bug ~ factor(get(allNames[j])), ylab = names[i], main = c(names[index],toString(graphMain[-1])) )
                    points(factor(get(allNames[j])), bug)
                }
                else{
                    testInteract <- grep(":", allNames)
                    if(length(testInteract) > 0){
                        if(j == testInteract){
                            intSplit <- unlist(strsplit(allNames[grep(":",allNames)],split=":"))
                            plot( bug ~ factor(c( paste( get(intSplit[1]), get(intSplit[2]),sep=""))))
                            points(factor(c( paste( get(intSplit[1], get(intSplit[2]),sep=""))), bug)
                        }
                    }
                    else{
                        plot( bug ~ factor(get(allNames[j])), ylab = names[i])
                        points(factor(get(allNames[j])), bug)
                    }
                }
            }
                ##plot( bug ~ factor(ac), ylab = names[index],main = graphMain )
                ##points(factor(ac), bug)

                ## plot ( bug ~ factor(ac) )
                ## points(factor(ac), bug)

                ## plot( bug ~ factor(c( paste( sl, treatment,sep=""))))
                ## points(factor(c( paste( sl, treatment,sep=""))), bug)

                ##plot ( bug ~ factor(batch) )
                ##points(factor(batch), bug)

                ##plot( bug ~ factor(date), ylab=names[index])
                ##points(factor(date), bug)

            index <- index + 1
	}

    ## This should also be dynamic
    dFrame <- as.data.frame(matrix(unlist(allpvals), nrow= length(allpvals), byrow=TRUE))
    colnames(dFrame) <- unlist(allNames)
    rownames(dFrame) <- names
    orgCol <- ncol(dFrame)

    for(k in 1:(orgCol-1)){
        dFrame[, k + orgCol]<-p.adjust(dFrame[,k], method = "BH")
    }
    colnames(dFrame)[(orgCol + 1):length(dFrame)]<-paste0(rep("adjusted_"),colnames(dFrame))
    ## dFrame <- data.frame( names, pValuesTreatment, pValuesBatch, pValuesCage, iccCage)
    ## pValuesTreatment)#, pValuesBatch)#, pValuesExperiment)

    ## dFrame <- dFrame[order(pValuesAcuteChronic),]
    ## dFrame$adjustedAcuteChronic <- p.adjust( dFrame$pValuesAcuteChronic, method = "BH" )
    ## dFrame$adjustedSex<- p.adjust( dFrame$pValuesSex, method = "BH" )
    ## dFrame$adjustedTreatment<- p.adjust( dFrame$pValuesTreatment, method = "BH" )
    ## dFrame$adjustedStressLength <- p.adjust( dFrame$pValuesStressLength, method = "BH")
    ## dFrame$adjustedInteraction <- p.adjust( dFrame$pValuesInteraction, method = "BH" )
    ## dFrame$adjustedBatch<- p.adjust( dFrame$pValuesBatch, method = "BH" )
    ## dFrame$adjustedCage <- p.adjust( dFrame$pValuesCage, method = "BH" )
    ## Try and dynamically generate the name of the plot here...
    write.table(dFrame, file=paste("pValuesForTaxa_bug_condition_batch_byDate_", taxa, ".txt",sep=""), sep="\t",row.names=FALSE)

    ## Get the sig table working
    ## It would also be nice to have a sig-picker for the plots and a combination of all sig results into one plot.
    keepVector <- grep("adj", names(dFrame))
    sigdFrame <-dFrame[which(dFrame[,keepVector] < 0.05,arr.ind=TRUE),]
    write.table(sigdFrame, file=paste("pValuesForTaxa_bug_condition_batch_byDate_sig_", taxa, ".txt",sep=""), sep="\t",row.names=FALSE)

    dev.off()
}

rm(list=ls())

library("pscl")
library("lmtest")
library("nlme")
library("vegan")

setwd("/Users/mbrown67/Documents/Fodor/Datasets/MarkExperiment/Pooled/")

taxaLevels <- c( "phylum", "class", "order", "family", "genus")

for(taxa in taxaLevels){

    inFileName <- paste( taxa, "LogNormwithMetadata_R1_Pooled.txt", sep ="")
    myT <-read.csv(inFileName,header=TRUE,sep="", na.strings="BLAH")

    numCols <- ncol(myT)
    numMetadataCols <- 20

    ## Reprocessing for correct column data type
##    myColClasses <- c("character", rep("numeric", numCols - numMetadataCols - 1), rep("character", 16), "numeric", "numeric", "numeric", "character", "character", "numeric", "character", "character", "character")
##    myT <-read.csv(inFileName, header=TRUE, sep="", colClasses=myColClasses, na.strings="BLAH", comment.char ="@")

    ## Removing unwanted samples {controls, replicates, duplicates, poor quality samples}
    removeControls<-c( "C1", "C2", "N1", "N2", "Neg", "Pos")
    myT<-myT[!(myT$Sample_ID %in% removeControls),]

    removetrs<-c("04_125_tr", "04_101_tr", "04_103_tr", "04_74_tr", "04_70_tr", "04_40_tr", "04_41_tr", "04_84_tr")
    myT<-myT[!(myT$Sample_ID %in% removetrs),]

    removeDups<-c("04-04_S63_L001_R1_001")
    myT<-myT[!(myT$MatchFile %in% removeDups),]

    ## Controls not dropped earlier
    manualDrop <- c("Neg_S40_L001_R1_001", "PCR1Neg_S65_L001_R1_001")
    myT<-myT[!(myT$MatchFile %in% manualDrop),]

    labDrop <- c("Harlan Labs")
    myT<-myT[!(myT$MouseOrigin %in% labDrop),]

    lowSeqDrop <- c("04-55_S32_L001_R1_001")
    myT<-myT[!(myT$MatchFile %in% lowSeqDrop),]
    ## Not sure what to do about this though.
    ### myT$Condition[which(myT$Treatment == "Ctrl", arr.ind = TRUE)]<-"Control"

    names <- vector()
    pValuesSex<- vector()
    pValuesAcuteChronic<- vector()
    pValuesCage<- vector()
    iccCage <- vector()
    iccKeptCounts <- vector()
    pValuesBatch<- vector()
    pValuesTreatment<- vector()
    pValuesTime <- vector()
    pValuesStressLength <- vector()
    pValuesInteraction <- vector()
    allpvals <- list()

    index <- 1

    for( i in 2:(ncol(myT) - numMetadataCols))
        if( sum(myT[,i] != 0 ) > nrow(myT) / 4 ){
            ## Easy access names
            bug <- myT[,i]
            ac <- myT$Condition
            sex <- myT$Sex
            cage <- myT$Cage
            batch <- myT$Sample_Plate
            date <- myT$Date
            mo <- myT$MouseOrigin
            group <- myT$SpreadsheetGrouping
            treatment <- myT$Treatment
            time <- myT$StressLength
            multiWay <- paste(ac, myT$StressLength)
            multiWay[which(myT$Treatment == "Ctrl", arr.ind = TRUE)]<-"Control"
            names[index] = names(myT)[i]
            ## Some kind of vector for the variables of interest
            myFrame <- data.frame(bug, ac, time, multiWay, sex, cage, treatment, batch, date, mo, date)
            mlm<-TRUE
            if(mlm == TRUE){
                fullModel <- gls( bug~   treatment*time + batch, method="REML",correlation=corCompSymm(form=~1|factor(group)),	data = myFrame )
                reducedModel <- gls( bug~ treatment*time + batch, method="REML", data = myFrame )
                fullModelLME <- lme(bug~  treatment*time + batch, method="REML", random = ~1|factor(group), data = myFrame)
            }
            else{
                fullModelLME <- lm(bug~ treatment*time + batch, x=TRUE)
            }
            ## Potential save time by reducing anova calls
            ## Introduce the goodness of fit tests here
            ## Can streamline vectors to be automatically responsive to changes to the model
            allNames <- rownames(anova(fullModelLME))[-1]
            allpvals[[index]] <- anova(fullModelLME)$"p-value"[-1]

            ## pValuesAcuteChronic[index] <- anova(fullModelLME)$"p-value"[2]
            ## pValuesTime[index] <- anova(fullModelLME)$"p-value"[6]
            ## pValuesInteraction[index] <- anova(fullModelLME)$"p-value"[6]
            ## pValuesSex[index] <- anova(fullModelLME)$"p-value"[6]
            ## pValuesExperiment[index] <- anova(fullModelLME)$"p-value"[6]
            ## pValuesBatch[index] <- anova(fullModelLME)$"p-value"[3]
            ## pValuesTreatment[index] <- anova(fullModelLME)$"p-value"[6]

            ## Random Effects and Interclass Correlation Coefficient
            if(mlm == TRUE){
                allNames<-c(allNames, "cage", "iccCage")
                allpvals[[index]]<-c(allpvals[[index]], anova(fullModelLME, reducedModel)$"p-value"[2], coef(fullModel$modelStruct[1]$corStruct,unconstrained=FALSE)[[1]])
                pValuesCage[index] <-  anova(fullModelLME, reducedModel)$"p-value"[2]
                ## This is different as it is not corrected for multiple hypothesis testing.
                iccCage[index]<- coef(fullModel$modelStruct[1]$corStruct,unconstrained=FALSE)[[1]]
            }
    ## Nice plotting
            ## Correct so that it uses corrected p-values
            graphMain = c(names[i], paste(c(rep("p-",length(allNames)-1),""), allNames, " = ", format(allpvals[[index]], digits=3), sep=""))
            ## graphMain =  paste( names(myT)[i], "\n",
            ##     ## " pTreatment= ", format(pValuesTreatment[index], digits=3),
            ##     ## " pTime= ", format(pValuesTime[index], digits=3),"\n",
            ##     ## " pTreatmentXTime= ", format(pValuesInteraction[index], digits=3),"\n",
            ##     ## " pSex=", format( pValuesSex[index], digits=3),
            ##     " pCondition= ", format( pValuesAcuteChronic[index],digits=3),
            ##     " pBatch= ", format(pValuesBatch[index], digits=3), "\n",
            ##     ## " pTreatment= ", format(pValuesTreatment[index], digits=3),
            ##     ## " pExperiment= ", format(pValuesExperiment[index], digits=3),
            ##     ## " pShannon= ", format(pValuesShannon[index], digits=3),
            ##     ## " pKeptCounts= ", format(pValuesKeptCounts[index], digits=3),
            ##     " pDate= " , format( pValuesCage[index], digits=3),
            ##     " icc= " , format( iccCage[index], digits=3 ), sep="")

            ## mlm is boolean 1/0 value. Basically, don't graph on icc
            ## need a correction for interaction terms as well
            numPlots <- length(allNames) - mlm
            par(mfrow=c(numPlots, 1),
                oma = c(1,1,0,0) + 0.1,
                mar = c(1,4,3,0) + 0.1)

            for(j in 1:numPlots){
                if(j == 1){
                    plot( bug ~ factor(get(allNames[j])), ylab = names[i], main = c(names[index],toString(graphMain[-1])) )
                    points(factor(get(allNames[j])), bug)
                }
                else{
                    testInteract <- grep(":", allNames)
                    if(length(testInteract) > 0){
                        if(j == testInteract){
                            intSplit <- unlist(strsplit(allNames[grep(":",allNames)],split=":"))
                            plot( bug ~ factor(c( paste( get(intSplit[1]), get(intSplit[2]),sep=""))))
                            points(factor(c( paste( get(intSplit[1]), get(intSplit[2]),sep=""))), bug)
                        }
                    }
                    else{
                        plot( bug ~ factor(get(allNames[j])), ylab = names[i])
                        points(factor(get(allNames[j])), bug)
                    }
                }
            }
                ##plot( bug ~ factor(ac), ylab = names[index],main = graphMain )
                ##points(factor(ac), bug)

                ## plot ( bug ~ factor(ac) )
                ## points(factor(ac), bug)

                ## plot( bug ~ factor(c( paste( sl, treatment,sep=""))))
                ## points(factor(c( paste( sl, treatment,sep=""))), bug)

                ##plot ( bug ~ factor(batch) )
                ##points(factor(batch), bug)

                ##plot( bug ~ factor(date), ylab=names[index])
                ##points(factor(date), bug)

            index <- index + 1
	}

    ## This should also be dynamic
    dFrame <- as.data.frame(matrix(unlist(allpvals), nrow= length(allpvals), byrow=TRUE))
    colnames(dFrame) <- unlist(allNames)
    rownames(dFrame) <- names
    orgCol <- ncol(dFrame)

    for(k in 1:(orgCol-1)){
        dFrame[, k + orgCol]<-p.adjust(dFrame[,k], method = "BH")
    }
    colnames(dFrame)[(orgCol + 1):length(dFrame)]<-paste0(rep("adjusted_"),colnames(dFrame))
    ## dFrame <- data.frame( names, pValuesTreatment, pValuesBatch, pValuesCage, iccCage)
    ## pValuesTreatment)#, pValuesBatch)#, pValuesExperiment)

    ## dFrame <- dFrame[order(pValuesAcuteChronic),]
    ## dFrame$adjustedAcuteChronic <- p.adjust( dFrame$pValuesAcuteChronic, method = "BH" )
    ## dFrame$adjustedSex<- p.adjust( dFrame$pValuesSex, method = "BH" )
    ## dFrame$adjustedTreatment<- p.adjust( dFrame$pValuesTreatment, method = "BH" )
    ## dFrame$adjustedStressLength <- p.adjust( dFrame$pValuesStressLength, method = "BH")
    ## dFrame$adjustedInteraction <- p.adjust( dFrame$pValuesInteraction, method = "BH" )
    ## dFrame$adjustedBatch<- p.adjust( dFrame$pValuesBatch, method = "BH" )
    ## dFrame$adjustedCage <- p.adjust( dFrame$pValuesCage, method = "BH" )
    ## Try and dynamically generate the name of the plot here...
    write.table(dFrame, file=paste("pValuesForTaxa_bug_condition_batch_byDate_", taxa, ".txt",sep=""), sep="\t",row.names=FALSE)

    ## Get the sig table working
    ## It would also be nice to have a sig-picker for the plots and a combination of all sig results into one plot.
    keepVector <- grep("adj", names(dFrame))
    sigdFrame <-dFrame[which(dFrame[,keepVector] < 0.05,arr.ind=TRUE),]
    write.table(sigdFrame, file=paste("pValuesForTaxa_bug_condition_batch_byDate_sig_", taxa, ".txt",sep=""), sep="\t",row.names=FALSE)

    dev.off()
}

dFrame
dim(dFrame)
anova(fullModelLME)
allpvals[[1]]
length(allpvals[[1]]
)
dFrame[1,]
    dFrame <- as.data.frame(matrix(unlist(allpvals), nrow= length(allpvals), byrow=TRUE))
    colnames(dFrame) <- unlist(allNames)
    rownames(dFrame) <- names
    orgCol <- ncol(dFrame)

    for(k in 1:(orgCol-1)){
        dFrame[, k + orgCol]<-p.adjust(dFrame[,k], method = "BH")
    }
    colnames(dFrame)[(orgCol + 1):length(dFrame)]<-paste0(rep("adjusted_"),colnames(dFrame)[1:(orgCol - 1)])

rm(list=ls())

library("pscl")
library("lmtest")
library("nlme")
library("vegan")

setwd("/Users/mbrown67/Documents/Fodor/Datasets/MarkExperiment/Pooled/")

taxaLevels <- c( "phylum", "class", "order", "family", "genus")

for(taxa in taxaLevels){

    inFileName <- paste( taxa, "LogNormwithMetadata_R1_Pooled.txt", sep ="")
    myT <-read.csv(inFileName,header=TRUE,sep="", na.strings="BLAH")

    numCols <- ncol(myT)
    numMetadataCols <- 20

    ## Reprocessing for correct column data type
##    myColClasses <- c("character", rep("numeric", numCols - numMetadataCols - 1), rep("character", 16), "numeric", "numeric", "numeric", "character", "character", "numeric", "character", "character", "character")
##    myT <-read.csv(inFileName, header=TRUE, sep="", colClasses=myColClasses, na.strings="BLAH", comment.char ="@")

    ## Removing unwanted samples {controls, replicates, duplicates, poor quality samples}
    removeControls<-c( "C1", "C2", "N1", "N2", "Neg", "Pos")
    myT<-myT[!(myT$Sample_ID %in% removeControls),]

    removetrs<-c("04_125_tr", "04_101_tr", "04_103_tr", "04_74_tr", "04_70_tr", "04_40_tr", "04_41_tr", "04_84_tr")
    myT<-myT[!(myT$Sample_ID %in% removetrs),]

    removeDups<-c("04-04_S63_L001_R1_001")
    myT<-myT[!(myT$MatchFile %in% removeDups),]

    ## Controls not dropped earlier
    manualDrop <- c("Neg_S40_L001_R1_001", "PCR1Neg_S65_L001_R1_001")
    myT<-myT[!(myT$MatchFile %in% manualDrop),]

    labDrop <- c("Harlan Labs")
    myT<-myT[!(myT$MouseOrigin %in% labDrop),]

    lowSeqDrop <- c("04-55_S32_L001_R1_001")
    myT<-myT[!(myT$MatchFile %in% lowSeqDrop),]
    ## Not sure what to do about this though.
    ### myT$Condition[which(myT$Treatment == "Ctrl", arr.ind = TRUE)]<-"Control"

    names <- vector()
    pValuesSex<- vector()
    pValuesAcuteChronic<- vector()
    pValuesCage<- vector()
    iccCage <- vector()
    iccKeptCounts <- vector()
    pValuesBatch<- vector()
    pValuesTreatment<- vector()
    pValuesTime <- vector()
    pValuesStressLength <- vector()
    pValuesInteraction <- vector()
    allpvals <- list()

    index <- 1

    for( i in 2:(ncol(myT) - numMetadataCols))
        if( sum(myT[,i] != 0 ) > nrow(myT) / 4 ){
            ## Easy access names
            bug <- myT[,i]
            ac <- myT$Condition
            sex <- myT$Sex
            cage <- myT$Cage
            batch <- myT$Sample_Plate
            date <- myT$Date
            mo <- myT$MouseOrigin
            group <- myT$SpreadsheetGrouping
            treatment <- myT$Treatment
            time <- myT$StressLength
            multiWay <- paste(ac, myT$StressLength)
            multiWay[which(myT$Treatment == "Ctrl", arr.ind = TRUE)]<-"Control"
            names[index] = names(myT)[i]
            ## Some kind of vector for the variables of interest
            myFrame <- data.frame(bug, ac, time, multiWay, sex, cage, treatment, batch, date, mo, date)
            mlm<-TRUE
            if(mlm == TRUE){
                fullModel <- gls( bug~   treatment*time + batch, method="REML",correlation=corCompSymm(form=~1|factor(group)),	data = myFrame )
                reducedModel <- gls( bug~ treatment*time + batch, method="REML", data = myFrame )
                fullModelLME <- lme(bug~  treatment*time + batch, method="REML", random = ~1|factor(group), data = myFrame)
            }
            else{
                fullModelLME <- lm(bug~ treatment*time + batch, x=TRUE)
            }
            ## Potential save time by reducing anova calls
            ## Introduce the goodness of fit tests here
            ## Can streamline vectors to be automatically responsive to changes to the model
            allNames <- rownames(anova(fullModelLME))[-1]
            allpvals[[index]] <- anova(fullModelLME)$"p-value"[-1]

            ## pValuesAcuteChronic[index] <- anova(fullModelLME)$"p-value"[2]
            ## pValuesTime[index] <- anova(fullModelLME)$"p-value"[6]
            ## pValuesInteraction[index] <- anova(fullModelLME)$"p-value"[6]
            ## pValuesSex[index] <- anova(fullModelLME)$"p-value"[6]
            ## pValuesExperiment[index] <- anova(fullModelLME)$"p-value"[6]
            ## pValuesBatch[index] <- anova(fullModelLME)$"p-value"[3]
            ## pValuesTreatment[index] <- anova(fullModelLME)$"p-value"[6]

            ## Random Effects and Interclass Correlation Coefficient
            if(mlm == TRUE){
                allNames<-c(allNames, "cage", "iccCage")
                allpvals[[index]]<-c(allpvals[[index]], anova(fullModelLME, reducedModel)$"p-value"[2], coef(fullModel$modelStruct[1]$corStruct,unconstrained=FALSE)[[1]])
                pValuesCage[index] <-  anova(fullModelLME, reducedModel)$"p-value"[2]
                ## This is different as it is not corrected for multiple hypothesis testing.
                iccCage[index]<- coef(fullModel$modelStruct[1]$corStruct,unconstrained=FALSE)[[1]]
            }
    ## Nice plotting
            ## Correct so that it uses corrected p-values
            graphMain = c(names[i], paste(c(rep("p-",length(allNames)-1),""), allNames, " = ", format(allpvals[[index]], digits=3), sep=""))
            ## graphMain =  paste( names(myT)[i], "\n",
            ##     ## " pTreatment= ", format(pValuesTreatment[index], digits=3),
            ##     ## " pTime= ", format(pValuesTime[index], digits=3),"\n",
            ##     ## " pTreatmentXTime= ", format(pValuesInteraction[index], digits=3),"\n",
            ##     ## " pSex=", format( pValuesSex[index], digits=3),
            ##     " pCondition= ", format( pValuesAcuteChronic[index],digits=3),
            ##     " pBatch= ", format(pValuesBatch[index], digits=3), "\n",
            ##     ## " pTreatment= ", format(pValuesTreatment[index], digits=3),
            ##     ## " pExperiment= ", format(pValuesExperiment[index], digits=3),
            ##     ## " pShannon= ", format(pValuesShannon[index], digits=3),
            ##     ## " pKeptCounts= ", format(pValuesKeptCounts[index], digits=3),
            ##     " pDate= " , format( pValuesCage[index], digits=3),
            ##     " icc= " , format( iccCage[index], digits=3 ), sep="")

            ## mlm is boolean 1/0 value. Basically, don't graph on icc
            ## need a correction for interaction terms as well
            numPlots <- length(allNames) - mlm
            par(mfrow=c(numPlots, 1),
                oma = c(1,1,0,0) + 0.1,
                mar = c(1,4,3,0) + 0.1)

            for(j in 1:numPlots){
                if(j == 1){
                    plot( bug ~ factor(get(allNames[j])), ylab = names[i], main = c(names[index],toString(graphMain[-1])) )
                    points(factor(get(allNames[j])), bug)
                }
                else{
                    testInteract <- grep(":", allNames)
                    if(length(testInteract) > 0){
                        if(j == testInteract){
                            intSplit <- unlist(strsplit(allNames[grep(":",allNames)],split=":"))
                            plot( bug ~ factor(c( paste( get(intSplit[1]), get(intSplit[2]),sep=""))))
                            points(factor(c( paste( get(intSplit[1]), get(intSplit[2]),sep=""))), bug)
                        }
                    }
                    else{
                        plot( bug ~ factor(get(allNames[j])), ylab = names[i])
                        points(factor(get(allNames[j])), bug)
                    }
                }
            }
                ##plot( bug ~ factor(ac), ylab = names[index],main = graphMain )
                ##points(factor(ac), bug)

                ## plot ( bug ~ factor(ac) )
                ## points(factor(ac), bug)

                ## plot( bug ~ factor(c( paste( sl, treatment,sep=""))))
                ## points(factor(c( paste( sl, treatment,sep=""))), bug)

                ##plot ( bug ~ factor(batch) )
                ##points(factor(batch), bug)

                ##plot( bug ~ factor(date), ylab=names[index])
                ##points(factor(date), bug)

            index <- index + 1
	}

    ## This should also be dynamic
    dFrame <- as.data.frame(matrix(unlist(allpvals), nrow= length(allpvals), byrow=TRUE))
    colnames(dFrame) <- unlist(allNames)
    rownames(dFrame) <- names
    orgCol <- ncol(dFrame)

    for(k in 1:(orgCol-1)){
        dFrame[, k + orgCol]<-p.adjust(dFrame[,k], method = "BH")
    }
    colnames(dFrame)[(orgCol + 1):length(dFrame)]<-paste0(rep("adjusted_"),colnames(dFrame)[1:(orgCol - 1)])
    ## dFrame <- data.frame( names, pValuesTreatment, pValuesBatch, pValuesCage, iccCage)
    ## pValuesTreatment)#, pValuesBatch)#, pValuesExperiment)

    ## dFrame <- dFrame[order(pValuesAcuteChronic),]
    ## dFrame$adjustedAcuteChronic <- p.adjust( dFrame$pValuesAcuteChronic, method = "BH" )
    ## dFrame$adjustedSex<- p.adjust( dFrame$pValuesSex, method = "BH" )
    ## dFrame$adjustedTreatment<- p.adjust( dFrame$pValuesTreatment, method = "BH" )
    ## dFrame$adjustedStressLength <- p.adjust( dFrame$pValuesStressLength, method = "BH")
    ## dFrame$adjustedInteraction <- p.adjust( dFrame$pValuesInteraction, method = "BH" )
    ## dFrame$adjustedBatch<- p.adjust( dFrame$pValuesBatch, method = "BH" )
    ## dFrame$adjustedCage <- p.adjust( dFrame$pValuesCage, method = "BH" )
    ## Try and dynamically generate the name of the plot here...
    write.table(dFrame, file=paste("pValuesForTaxa_bug_condition_batch_byDate_", taxa, ".txt",sep=""), sep="\t",row.names=FALSE)

    ## Get the sig table working
    ## It would also be nice to have a sig-picker for the plots and a combination of all sig results into one plot.
    keepVector <- grep("adj", names(dFrame))
    sigdFrame <-dFrame[which(dFrame[,keepVector] < 0.05,arr.ind=TRUE),]
    write.table(sigdFrame, file=paste("pValuesForTaxa_bug_condition_batch_byDate_sig_", taxa, ".txt",sep=""), sep="\t",row.names=FALSE)

    dev.off()
}

colnames(myT)
class(myT[,1])
class(myT[,2])
class(myT$Abiotrophia)
class(myT$StressLength)
as.numeric(myT$StressLength)
help(class)
class(myT$StressLength)<-"numeric"
as.numeric(myT$StressLength)
myT$StressLength
rm(list=ls())

library("pscl")
library("lmtest")
library("nlme")
library("vegan")

setwd("/Users/mbrown67/Documents/Fodor/Datasets/MarkExperiment/Pooled/")

taxaLevels <- c( "phylum", "class", "order", "family", "genus")

for(taxa in taxaLevels){

    inFileName <- paste( taxa, "LogNormwithMetadata_R1_Pooled.txt", sep ="")
    myT <-read.csv(inFileName,header=TRUE,sep="", na.strings="BLAH")

    numCols <- ncol(myT)
    numMetadataCols <- 20

    ## Reprocessing for correct column data type
    myColClasses <- c("character", rep("numeric", numCols - numMetadataCols - 1), rep("character", 16), "numeric", "numeric", "numeric", "character", "character", "numeric", "character", "character", "character")
    myT <-read.csv(inFileName, header=TRUE, sep="", colClasses=myColClasses, na.strings="BLAH", comment.char ="@")

    ## Removing unwanted samples {controls, replicates, duplicates, poor quality samples}
    removeControls<-c( "C1", "C2", "N1", "N2", "Neg", "Pos")
    myT<-myT[!(myT$Sample_ID %in% removeControls),]

    removetrs<-c("04_125_tr", "04_101_tr", "04_103_tr", "04_74_tr", "04_70_tr", "04_40_tr", "04_41_tr", "04_84_tr")
    myT<-myT[!(myT$Sample_ID %in% removetrs),]

    removeDups<-c("04-04_S63_L001_R1_001")
    myT<-myT[!(myT$MatchFile %in% removeDups),]

    ## Controls not dropped earlier
    manualDrop <- c("Neg_S40_L001_R1_001", "PCR1Neg_S65_L001_R1_001")
    myT<-myT[!(myT$MatchFile %in% manualDrop),]

    labDrop <- c("Harlan Labs")
    myT<-myT[!(myT$MouseOrigin %in% labDrop),]

    lowSeqDrop <- c("04-55_S32_L001_R1_001")
    myT<-myT[!(myT$MatchFile %in% lowSeqDrop),]
    ## Not sure what to do about this though.
    ### myT$Condition[which(myT$Treatment == "Ctrl", arr.ind = TRUE)]<-"Control"

    names <- vector()
    pValuesSex<- vector()
    pValuesAcuteChronic<- vector()
    pValuesCage<- vector()
    iccCage <- vector()
    iccKeptCounts <- vector()
    pValuesBatch<- vector()
    pValuesTreatment<- vector()
    pValuesTime <- vector()
    pValuesStressLength <- vector()
    pValuesInteraction <- vector()
    allpvals <- list()

    index <- 1

    pdf( paste(taxa, "_treatmentItime_batch_byGroup_boxplots.pdf", sep=""))

    for( i in 2:(ncol(myT) - numMetadataCols))
        if( sum(myT[,i] != 0 ) > nrow(myT) / 4 ){
            ## Easy access names
            bug <- myT[,i]
            ac <- myT$Condition
            sex <- myT$Sex
            cage <- myT$Cage
            batch <- myT$Sample_Plate
            date <- myT$Date
            mo <- myT$MouseOrigin
            group <- myT$SpreadsheetGrouping
            treatment <- myT$Treatment
            time <- myT$StressLength
            multiWay <- paste(ac, myT$StressLength)
            multiWay[which(myT$Treatment == "Ctrl", arr.ind = TRUE)]<-"Control"
            names[index] = names(myT)[i]
            ## Some kind of vector for the variables of interest
            myFrame <- data.frame(bug, ac, time, multiWay, sex, cage, treatment, batch, date, mo, date)
            mlm<-TRUE
            if(mlm == TRUE){
                fullModel <- gls( bug~   treatment*time + batch, method="REML",correlation=corCompSymm(form=~1|factor(group)),	data = myFrame )
                reducedModel <- gls( bug~ treatment*time + batch, method="REML", data = myFrame )
                fullModelLME <- lme(bug~  treatment*time + batch, method="REML", random = ~1|factor(group), data = myFrame)
            }
            else{
                fullModelLME <- lm(bug~ treatment*time + batch, x=TRUE)
            }
            ## Potential save time by reducing anova calls
            ## Introduce the goodness of fit tests here
            ## Can streamline vectors to be automatically responsive to changes to the model
            allNames <- rownames(anova(fullModelLME))[-1]
            allpvals[[index]] <- anova(fullModelLME)$"p-value"[-1]

            ## pValuesAcuteChronic[index] <- anova(fullModelLME)$"p-value"[2]
            ## pValuesTime[index] <- anova(fullModelLME)$"p-value"[6]
            ## pValuesInteraction[index] <- anova(fullModelLME)$"p-value"[6]
            ## pValuesSex[index] <- anova(fullModelLME)$"p-value"[6]
            ## pValuesExperiment[index] <- anova(fullModelLME)$"p-value"[6]
            ## pValuesBatch[index] <- anova(fullModelLME)$"p-value"[3]
            ## pValuesTreatment[index] <- anova(fullModelLME)$"p-value"[6]

            ## Random Effects and Interclass Correlation Coefficient
            if(mlm == TRUE){
                allNames<-c(allNames, "cage", "iccCage")
                allpvals[[index]]<-c(allpvals[[index]], anova(fullModelLME, reducedModel)$"p-value"[2], coef(fullModel$modelStruct[1]$corStruct,unconstrained=FALSE)[[1]])
                pValuesCage[index] <-  anova(fullModelLME, reducedModel)$"p-value"[2]
                ## This is different as it is not corrected for multiple hypothesis testing.
                iccCage[index]<- coef(fullModel$modelStruct[1]$corStruct,unconstrained=FALSE)[[1]]
            }
    ## Nice plotting
            ## Correct so that it uses corrected p-values
            graphMain = c(names[i], paste(c(rep("p-",length(allNames)-1),""), allNames, " = ", format(allpvals[[index]], digits=3), sep=""))
            ## graphMain =  paste( names(myT)[i], "\n",
            ##     ## " pTreatment= ", format(pValuesTreatment[index], digits=3),
            ##     ## " pTime= ", format(pValuesTime[index], digits=3),"\n",
            ##     ## " pTreatmentXTime= ", format(pValuesInteraction[index], digits=3),"\n",
            ##     ## " pSex=", format( pValuesSex[index], digits=3),
            ##     " pCondition= ", format( pValuesAcuteChronic[index],digits=3),
            ##     " pBatch= ", format(pValuesBatch[index], digits=3), "\n",
            ##     ## " pTreatment= ", format(pValuesTreatment[index], digits=3),
            ##     ## " pExperiment= ", format(pValuesExperiment[index], digits=3),
            ##     ## " pShannon= ", format(pValuesShannon[index], digits=3),
            ##     ## " pKeptCounts= ", format(pValuesKeptCounts[index], digits=3),
            ##     " pDate= " , format( pValuesCage[index], digits=3),
            ##     " icc= " , format( iccCage[index], digits=3 ), sep="")

            ## mlm is boolean 1/0 value. Basically, don't graph on icc
            ## need a correction for interaction terms as well
            numPlots <- length(allNames) - mlm
            par(mfrow=c(numPlots, 1),
                oma = c(1,1,0,0) + 0.1,
                mar = c(1,4,3,0) + 0.1)

            for(j in 1:numPlots){
                if(j == 1){
                    plot( bug ~ factor(get(allNames[j])), ylab = names[i], main = c(names[index],toString(graphMain[-1])) )
                    points(factor(get(allNames[j])), bug)
                }
                else{
                    testInteract <- grep(":", allNames)
                    if(length(testInteract) > 0){
                        if(j == testInteract){
                            intSplit <- unlist(strsplit(allNames[grep(":",allNames)],split=":"))
                            plot( bug ~ factor(c( paste( get(intSplit[1]), get(intSplit[2]),sep=""))))
                            points(factor(c( paste( get(intSplit[1]), get(intSplit[2]),sep=""))), bug)
                        }
                    }
                    else{
                        plot( bug ~ factor(get(allNames[j])), ylab = names[i])
                        points(factor(get(allNames[j])), bug)
                    }
                }
            }
                ##plot( bug ~ factor(ac), ylab = names[index],main = graphMain )
                ##points(factor(ac), bug)

                ## plot ( bug ~ factor(ac) )
                ## points(factor(ac), bug)

                ## plot( bug ~ factor(c( paste( sl, treatment,sep=""))))
                ## points(factor(c( paste( sl, treatment,sep=""))), bug)

                ##plot ( bug ~ factor(batch) )
                ##points(factor(batch), bug)

                ##plot( bug ~ factor(date), ylab=names[index])
                ##points(factor(date), bug)

            index <- index + 1
	}

    ## This should also be dynamic
    dFrame <- as.data.frame(matrix(unlist(allpvals), nrow= length(allpvals), byrow=TRUE))
    colnames(dFrame) <- unlist(allNames)
    rownames(dFrame) <- names
    orgCol <- ncol(dFrame)

    for(k in 1:(orgCol-1)){
        dFrame[, k + orgCol]<-p.adjust(dFrame[,k], method = "BH")
    }
    colnames(dFrame)[(orgCol + 1):length(dFrame)]<-paste0(rep("adjusted_"),colnames(dFrame)[1:(orgCol - 1)])
    ## dFrame <- data.frame( names, pValuesTreatment, pValuesBatch, pValuesCage, iccCage)
    ## pValuesTreatment)#, pValuesBatch)#, pValuesExperiment)

    ## dFrame <- dFrame[order(pValuesAcuteChronic),]
    ## dFrame$adjustedAcuteChronic <- p.adjust( dFrame$pValuesAcuteChronic, method = "BH" )
    ## dFrame$adjustedSex<- p.adjust( dFrame$pValuesSex, method = "BH" )
    ## dFrame$adjustedTreatment<- p.adjust( dFrame$pValuesTreatment, method = "BH" )
    ## dFrame$adjustedStressLength <- p.adjust( dFrame$pValuesStressLength, method = "BH")
    ## dFrame$adjustedInteraction <- p.adjust( dFrame$pValuesInteraction, method = "BH" )
    ## dFrame$adjustedBatch<- p.adjust( dFrame$pValuesBatch, method = "BH" )
    ## dFrame$adjustedCage <- p.adjust( dFrame$pValuesCage, method = "BH" )
    ## Try and dynamically generate the name of the plot here...
    write.table(dFrame, file=paste("pValuesForTaxa_bug_treatmentItime_batch_byGroup_", taxa, ".txt",sep=""), sep="\t",row.names=FALSE)

    ## Get the sig table working
    ## It would also be nice to have a sig-picker for the plots and a combination of all sig results into one plot.
    keepVector <- grep("adj", names(dFrame))
    sigdFrame <-dFrame[which(dFrame[,keepVector] < 0.05,arr.ind=TRUE),]
    write.table(sigdFrame, file=paste("pValuesForTaxa_bug_treatmentItime_batch_byGroup_sig_", taxa, ".txt",sep=""), sep="\t",row.names=FALSE)

    dev.off()
}

myT[1,]
dim(myT)
myT[,numCols - numMetadataCols]
myT[,numCols - numMetadataCols - 1]
myT[,numCols - numMetadataCols + 1]
rm(list=ls())

library("pscl")
library("lmtest")
library("nlme")
library("vegan")

setwd("/Users/mbrown67/Documents/Fodor/Datasets/MarkExperiment/Pooled/")

taxaLevels <- c( "phylum", "class", "order", "family", "genus")

for(taxa in taxaLevels){

    inFileName <- paste( taxa, "LogNormwithMetadata_R1_Pooled.txt", sep ="")
    myT <-read.csv(inFileName,header=TRUE,sep="", na.strings="BLAH")

    numCols <- ncol(myT)
    numMetadataCols <- 20

    ## Reprocessing for correct column data type
    myColClasses <- c("character", rep("numeric", numCols - numMetadataCols + 1), rep("character", 16), "numeric", "numeric", "numeric", "character", "character", "numeric", "character", "character", "character")
    myT <-read.csv(inFileName, header=TRUE, sep="", colClasses=myColClasses, na.strings="BLAH", comment.char ="@")

    ## Removing unwanted samples {controls, replicates, duplicates, poor quality samples}
    removeControls<-c( "C1", "C2", "N1", "N2", "Neg", "Pos")
    myT<-myT[!(myT$Sample_ID %in% removeControls),]

    removetrs<-c("04_125_tr", "04_101_tr", "04_103_tr", "04_74_tr", "04_70_tr", "04_40_tr", "04_41_tr", "04_84_tr")
    myT<-myT[!(myT$Sample_ID %in% removetrs),]

    removeDups<-c("04-04_S63_L001_R1_001")
    myT<-myT[!(myT$MatchFile %in% removeDups),]

    ## Controls not dropped earlier
    manualDrop <- c("Neg_S40_L001_R1_001", "PCR1Neg_S65_L001_R1_001")
    myT<-myT[!(myT$MatchFile %in% manualDrop),]

    labDrop <- c("Harlan Labs")
    myT<-myT[!(myT$MouseOrigin %in% labDrop),]

    lowSeqDrop <- c("04-55_S32_L001_R1_001")
    myT<-myT[!(myT$MatchFile %in% lowSeqDrop),]
    ## Not sure what to do about this though.
    ### myT$Condition[which(myT$Treatment == "Ctrl", arr.ind = TRUE)]<-"Control"

    names <- vector()
    pValuesSex<- vector()
    pValuesAcuteChronic<- vector()
    pValuesCage<- vector()
    iccCage <- vector()
    iccKeptCounts <- vector()
    pValuesBatch<- vector()
    pValuesTreatment<- vector()
    pValuesTime <- vector()
    pValuesStressLength <- vector()
    pValuesInteraction <- vector()
    allpvals <- list()

    index <- 1

    pdf( paste(taxa, "_treatmentItime_batch_byGroup_boxplots.pdf", sep=""))

    for( i in 2:(ncol(myT) - numMetadataCols))
        if( sum(myT[,i] != 0 ) > nrow(myT) / 4 ){
            ## Easy access names
            bug <- myT[,i]
            ac <- myT$Condition
            sex <- myT$Sex
            cage <- myT$Cage
            batch <- myT$Sample_Plate
            date <- myT$Date
            mo <- myT$MouseOrigin
            group <- myT$SpreadsheetGrouping
            treatment <- myT$Treatment
            time <- myT$StressLength
            multiWay <- paste(ac, myT$StressLength)
            multiWay[which(myT$Treatment == "Ctrl", arr.ind = TRUE)]<-"Control"
            names[index] = names(myT)[i]
            ## Some kind of vector for the variables of interest
            myFrame <- data.frame(bug, ac, time, multiWay, sex, cage, treatment, batch, date, mo, date)
            mlm<-TRUE
            if(mlm == TRUE){
                fullModel <- gls( bug~   treatment*time + batch, method="REML",correlation=corCompSymm(form=~1|factor(group)),	data = myFrame )
                reducedModel <- gls( bug~ treatment*time + batch, method="REML", data = myFrame )
                fullModelLME <- lme(bug~  treatment*time + batch, method="REML", random = ~1|factor(group), data = myFrame)
            }
            else{
                fullModelLME <- lm(bug~ treatment*time + batch, x=TRUE)
            }
            ## Potential save time by reducing anova calls
            ## Introduce the goodness of fit tests here
            ## Can streamline vectors to be automatically responsive to changes to the model
            allNames <- rownames(anova(fullModelLME))[-1]
            allpvals[[index]] <- anova(fullModelLME)$"p-value"[-1]

            ## pValuesAcuteChronic[index] <- anova(fullModelLME)$"p-value"[2]
            ## pValuesTime[index] <- anova(fullModelLME)$"p-value"[6]
            ## pValuesInteraction[index] <- anova(fullModelLME)$"p-value"[6]
            ## pValuesSex[index] <- anova(fullModelLME)$"p-value"[6]
            ## pValuesExperiment[index] <- anova(fullModelLME)$"p-value"[6]
            ## pValuesBatch[index] <- anova(fullModelLME)$"p-value"[3]
            ## pValuesTreatment[index] <- anova(fullModelLME)$"p-value"[6]

            ## Random Effects and Interclass Correlation Coefficient
            if(mlm == TRUE){
                allNames<-c(allNames, "cage", "iccCage")
                allpvals[[index]]<-c(allpvals[[index]], anova(fullModelLME, reducedModel)$"p-value"[2], coef(fullModel$modelStruct[1]$corStruct,unconstrained=FALSE)[[1]])
                pValuesCage[index] <-  anova(fullModelLME, reducedModel)$"p-value"[2]
                ## This is different as it is not corrected for multiple hypothesis testing.
                iccCage[index]<- coef(fullModel$modelStruct[1]$corStruct,unconstrained=FALSE)[[1]]
            }
    ## Nice plotting
            ## Correct so that it uses corrected p-values
            graphMain = c(names[i], paste(c(rep("p-",length(allNames)-1),""), allNames, " = ", format(allpvals[[index]], digits=3), sep=""))
            ## graphMain =  paste( names(myT)[i], "\n",
            ##     ## " pTreatment= ", format(pValuesTreatment[index], digits=3),
            ##     ## " pTime= ", format(pValuesTime[index], digits=3),"\n",
            ##     ## " pTreatmentXTime= ", format(pValuesInteraction[index], digits=3),"\n",
            ##     ## " pSex=", format( pValuesSex[index], digits=3),
            ##     " pCondition= ", format( pValuesAcuteChronic[index],digits=3),
            ##     " pBatch= ", format(pValuesBatch[index], digits=3), "\n",
            ##     ## " pTreatment= ", format(pValuesTreatment[index], digits=3),
            ##     ## " pExperiment= ", format(pValuesExperiment[index], digits=3),
            ##     ## " pShannon= ", format(pValuesShannon[index], digits=3),
            ##     ## " pKeptCounts= ", format(pValuesKeptCounts[index], digits=3),
            ##     " pDate= " , format( pValuesCage[index], digits=3),
            ##     " icc= " , format( iccCage[index], digits=3 ), sep="")

            ## mlm is boolean 1/0 value. Basically, don't graph on icc
            ## need a correction for interaction terms as well
            numPlots <- length(allNames) - mlm
            par(mfrow=c(numPlots, 1),
                oma = c(1,1,0,0) + 0.1,
                mar = c(1,4,3,0) + 0.1)

            for(j in 1:numPlots){
                if(j == 1){
                    plot( bug ~ factor(get(allNames[j])), ylab = names[i], main = c(names[index],toString(graphMain[-1])) )
                    points(factor(get(allNames[j])), bug)
                }
                else{
                    testInteract <- grep(":", allNames)
                    if(length(testInteract) > 0){
                        if(j == testInteract){
                            intSplit <- unlist(strsplit(allNames[grep(":",allNames)],split=":"))
                            plot( bug ~ factor(c( paste( get(intSplit[1]), get(intSplit[2]),sep=""))))
                            points(factor(c( paste( get(intSplit[1]), get(intSplit[2]),sep=""))), bug)
                        }
                    }
                    else{
                        plot( bug ~ factor(get(allNames[j])), ylab = names[i])
                        points(factor(get(allNames[j])), bug)
                    }
                }
            }
                ##plot( bug ~ factor(ac), ylab = names[index],main = graphMain )
                ##points(factor(ac), bug)

                ## plot ( bug ~ factor(ac) )
                ## points(factor(ac), bug)

                ## plot( bug ~ factor(c( paste( sl, treatment,sep=""))))
                ## points(factor(c( paste( sl, treatment,sep=""))), bug)

                ##plot ( bug ~ factor(batch) )
                ##points(factor(batch), bug)

                ##plot( bug ~ factor(date), ylab=names[index])
                ##points(factor(date), bug)

            index <- index + 1
	}

    ## This should also be dynamic
    dFrame <- as.data.frame(matrix(unlist(allpvals), nrow= length(allpvals), byrow=TRUE))
    colnames(dFrame) <- unlist(allNames)
    rownames(dFrame) <- names
    orgCol <- ncol(dFrame)

    for(k in 1:(orgCol-1)){
        dFrame[, k + orgCol]<-p.adjust(dFrame[,k], method = "BH")
    }
    colnames(dFrame)[(orgCol + 1):length(dFrame)]<-paste0(rep("adjusted_"),colnames(dFrame)[1:(orgCol - 1)])
    ## dFrame <- data.frame( names, pValuesTreatment, pValuesBatch, pValuesCage, iccCage)
    ## pValuesTreatment)#, pValuesBatch)#, pValuesExperiment)

    ## dFrame <- dFrame[order(pValuesAcuteChronic),]
    ## dFrame$adjustedAcuteChronic <- p.adjust( dFrame$pValuesAcuteChronic, method = "BH" )
    ## dFrame$adjustedSex<- p.adjust( dFrame$pValuesSex, method = "BH" )
    ## dFrame$adjustedTreatment<- p.adjust( dFrame$pValuesTreatment, method = "BH" )
    ## dFrame$adjustedStressLength <- p.adjust( dFrame$pValuesStressLength, method = "BH")
    ## dFrame$adjustedInteraction <- p.adjust( dFrame$pValuesInteraction, method = "BH" )
    ## dFrame$adjustedBatch<- p.adjust( dFrame$pValuesBatch, method = "BH" )
    ## dFrame$adjustedCage <- p.adjust( dFrame$pValuesCage, method = "BH" )
    ## Try and dynamically generate the name of the plot here...
    write.table(dFrame, file=paste("pValuesForTaxa_bug_treatmentItime_batch_byGroup_", taxa, ".txt",sep=""), sep="\t",row.names=FALSE)

    ## Get the sig table working
    ## It would also be nice to have a sig-picker for the plots and a combination of all sig results into one plot.
    keepVector <- grep("adj", names(dFrame))
    sigdFrame <-dFrame[which(dFrame[,keepVector] < 0.05,arr.ind=TRUE),]
    write.table(sigdFrame, file=paste("pValuesForTaxa_bug_treatmentItime_batch_byGroup_sig_", taxa, ".txt",sep=""), sep="\t",row.names=FALSE)

    dev.off()
}

myColClasses
myT[,51]
myT[,50]
rm(list=ls())

library("pscl")
library("lmtest")
library("nlme")
library("vegan")

setwd("/Users/mbrown67/Documents/Fodor/Datasets/MarkExperiment/Pooled/")

taxaLevels <- c( "phylum", "class", "order", "family", "genus")

for(taxa in taxaLevels){

    inFileName <- paste( taxa, "LogNormwithMetadata_R1_Pooled.txt", sep ="")
    myT <-read.csv(inFileName,header=TRUE,sep="", na.strings="BLAH")

    numCols <- ncol(myT)
    numMetadataCols <- 20

    ## Reprocessing for correct column data type
    myColClasses <- c("character", rep("numeric", numCols - numMetadataCols + 2), rep("character", 16), "numeric", "numeric", "numeric", "character", "character", "numeric", "character", "character", "character")
    myT <-read.csv(inFileName, header=TRUE, sep="", colClasses=myColClasses, na.strings="BLAH", comment.char ="@")

    ## Removing unwanted samples {controls, replicates, duplicates, poor quality samples}
    removeControls<-c( "C1", "C2", "N1", "N2", "Neg", "Pos")
    myT<-myT[!(myT$Sample_ID %in% removeControls),]

    removetrs<-c("04_125_tr", "04_101_tr", "04_103_tr", "04_74_tr", "04_70_tr", "04_40_tr", "04_41_tr", "04_84_tr")
    myT<-myT[!(myT$Sample_ID %in% removetrs),]

    removeDups<-c("04-04_S63_L001_R1_001")
    myT<-myT[!(myT$MatchFile %in% removeDups),]

    ## Controls not dropped earlier
    manualDrop <- c("Neg_S40_L001_R1_001", "PCR1Neg_S65_L001_R1_001")
    myT<-myT[!(myT$MatchFile %in% manualDrop),]

    labDrop <- c("Harlan Labs")
    myT<-myT[!(myT$MouseOrigin %in% labDrop),]

    lowSeqDrop <- c("04-55_S32_L001_R1_001")
    myT<-myT[!(myT$MatchFile %in% lowSeqDrop),]
    ## Not sure what to do about this though.
    ### myT$Condition[which(myT$Treatment == "Ctrl", arr.ind = TRUE)]<-"Control"

    names <- vector()
    pValuesSex<- vector()
    pValuesAcuteChronic<- vector()
    pValuesCage<- vector()
    iccCage <- vector()
    iccKeptCounts <- vector()
    pValuesBatch<- vector()
    pValuesTreatment<- vector()
    pValuesTime <- vector()
    pValuesStressLength <- vector()
    pValuesInteraction <- vector()
    allpvals <- list()

    index <- 1

    pdf( paste(taxa, "_treatmentItime_batch_byGroup_boxplots.pdf", sep=""))

    for( i in 2:(ncol(myT) - numMetadataCols))
        if( sum(myT[,i] != 0 ) > nrow(myT) / 4 ){
            ## Easy access names
            bug <- myT[,i]
            ac <- myT$Condition
            sex <- myT$Sex
            cage <- myT$Cage
            batch <- myT$Sample_Plate
            date <- myT$Date
            mo <- myT$MouseOrigin
            group <- myT$SpreadsheetGrouping
            treatment <- myT$Treatment
            time <- myT$StressLength
            multiWay <- paste(ac, myT$StressLength)
            multiWay[which(myT$Treatment == "Ctrl", arr.ind = TRUE)]<-"Control"
            names[index] = names(myT)[i]
            ## Some kind of vector for the variables of interest
            myFrame <- data.frame(bug, ac, time, multiWay, sex, cage, treatment, batch, date, mo, date)
            mlm<-TRUE
            if(mlm == TRUE){
                fullModel <- gls( bug~   treatment*time + batch, method="REML",correlation=corCompSymm(form=~1|factor(group)),	data = myFrame )
                reducedModel <- gls( bug~ treatment*time + batch, method="REML", data = myFrame )
                fullModelLME <- lme(bug~  treatment*time + batch, method="REML", random = ~1|factor(group), data = myFrame)
            }
            else{
                fullModelLME <- lm(bug~ treatment*time + batch, x=TRUE)
            }
            ## Potential save time by reducing anova calls
            ## Introduce the goodness of fit tests here
            ## Can streamline vectors to be automatically responsive to changes to the model
            allNames <- rownames(anova(fullModelLME))[-1]
            allpvals[[index]] <- anova(fullModelLME)$"p-value"[-1]

            ## pValuesAcuteChronic[index] <- anova(fullModelLME)$"p-value"[2]
            ## pValuesTime[index] <- anova(fullModelLME)$"p-value"[6]
            ## pValuesInteraction[index] <- anova(fullModelLME)$"p-value"[6]
            ## pValuesSex[index] <- anova(fullModelLME)$"p-value"[6]
            ## pValuesExperiment[index] <- anova(fullModelLME)$"p-value"[6]
            ## pValuesBatch[index] <- anova(fullModelLME)$"p-value"[3]
            ## pValuesTreatment[index] <- anova(fullModelLME)$"p-value"[6]

            ## Random Effects and Interclass Correlation Coefficient
            if(mlm == TRUE){
                allNames<-c(allNames, "cage", "iccCage")
                allpvals[[index]]<-c(allpvals[[index]], anova(fullModelLME, reducedModel)$"p-value"[2], coef(fullModel$modelStruct[1]$corStruct,unconstrained=FALSE)[[1]])
                pValuesCage[index] <-  anova(fullModelLME, reducedModel)$"p-value"[2]
                ## This is different as it is not corrected for multiple hypothesis testing.
                iccCage[index]<- coef(fullModel$modelStruct[1]$corStruct,unconstrained=FALSE)[[1]]
            }
    ## Nice plotting
            ## Correct so that it uses corrected p-values
            graphMain = c(names[i], paste(c(rep("p-",length(allNames)-1),""), allNames, " = ", format(allpvals[[index]], digits=3), sep=""))
            ## graphMain =  paste( names(myT)[i], "\n",
            ##     ## " pTreatment= ", format(pValuesTreatment[index], digits=3),
            ##     ## " pTime= ", format(pValuesTime[index], digits=3),"\n",
            ##     ## " pTreatmentXTime= ", format(pValuesInteraction[index], digits=3),"\n",
            ##     ## " pSex=", format( pValuesSex[index], digits=3),
            ##     " pCondition= ", format( pValuesAcuteChronic[index],digits=3),
            ##     " pBatch= ", format(pValuesBatch[index], digits=3), "\n",
            ##     ## " pTreatment= ", format(pValuesTreatment[index], digits=3),
            ##     ## " pExperiment= ", format(pValuesExperiment[index], digits=3),
            ##     ## " pShannon= ", format(pValuesShannon[index], digits=3),
            ##     ## " pKeptCounts= ", format(pValuesKeptCounts[index], digits=3),
            ##     " pDate= " , format( pValuesCage[index], digits=3),
            ##     " icc= " , format( iccCage[index], digits=3 ), sep="")

            ## mlm is boolean 1/0 value. Basically, don't graph on icc
            ## need a correction for interaction terms as well
            numPlots <- length(allNames) - mlm
            par(mfrow=c(numPlots, 1),
                oma = c(1,1,0,0) + 0.1,
                mar = c(1,4,3,0) + 0.1)

            for(j in 1:numPlots){
                if(j == 1){
                    plot( bug ~ factor(get(allNames[j])), ylab = names[i], main = c(names[index],toString(graphMain[-1])) )
                    points(factor(get(allNames[j])), bug)
                }
                else{
                    testInteract <- grep(":", allNames)
                    if(length(testInteract) > 0){
                        if(j == testInteract){
                            intSplit <- unlist(strsplit(allNames[grep(":",allNames)],split=":"))
                            plot( bug ~ factor(c( paste( get(intSplit[1]), get(intSplit[2]),sep=""))))
                            points(factor(c( paste( get(intSplit[1]), get(intSplit[2]),sep=""))), bug)
                        }
                    }
                    else{
                        plot( bug ~ factor(get(allNames[j])), ylab = names[i])
                        points(factor(get(allNames[j])), bug)
                    }
                }
            }
                ##plot( bug ~ factor(ac), ylab = names[index],main = graphMain )
                ##points(factor(ac), bug)

                ## plot ( bug ~ factor(ac) )
                ## points(factor(ac), bug)

                ## plot( bug ~ factor(c( paste( sl, treatment,sep=""))))
                ## points(factor(c( paste( sl, treatment,sep=""))), bug)

                ##plot ( bug ~ factor(batch) )
                ##points(factor(batch), bug)

                ##plot( bug ~ factor(date), ylab=names[index])
                ##points(factor(date), bug)

            index <- index + 1
	}

    ## This should also be dynamic
    dFrame <- as.data.frame(matrix(unlist(allpvals), nrow= length(allpvals), byrow=TRUE))
    colnames(dFrame) <- unlist(allNames)
    rownames(dFrame) <- names
    orgCol <- ncol(dFrame)

    for(k in 1:(orgCol-1)){
        dFrame[, k + orgCol]<-p.adjust(dFrame[,k], method = "BH")
    }
    colnames(dFrame)[(orgCol + 1):length(dFrame)]<-paste0(rep("adjusted_"),colnames(dFrame)[1:(orgCol - 1)])
    ## dFrame <- data.frame( names, pValuesTreatment, pValuesBatch, pValuesCage, iccCage)
    ## pValuesTreatment)#, pValuesBatch)#, pValuesExperiment)

    ## dFrame <- dFrame[order(pValuesAcuteChronic),]
    ## dFrame$adjustedAcuteChronic <- p.adjust( dFrame$pValuesAcuteChronic, method = "BH" )
    ## dFrame$adjustedSex<- p.adjust( dFrame$pValuesSex, method = "BH" )
    ## dFrame$adjustedTreatment<- p.adjust( dFrame$pValuesTreatment, method = "BH" )
    ## dFrame$adjustedStressLength <- p.adjust( dFrame$pValuesStressLength, method = "BH")
    ## dFrame$adjustedInteraction <- p.adjust( dFrame$pValuesInteraction, method = "BH" )
    ## dFrame$adjustedBatch<- p.adjust( dFrame$pValuesBatch, method = "BH" )
    ## dFrame$adjustedCage <- p.adjust( dFrame$pValuesCage, method = "BH" )
    ## Try and dynamically generate the name of the plot here...
    write.table(dFrame, file=paste("pValuesForTaxa_bug_treatmentItime_batch_byGroup_", taxa, ".txt",sep=""), sep="\t",row.names=FALSE)

    ## Get the sig table working
    ## It would also be nice to have a sig-picker for the plots and a combination of all sig results into one plot.
    keepVector <- grep("adj", names(dFrame))
    sigdFrame <-dFrame[which(dFrame[,keepVector] < 0.05,arr.ind=TRUE),]
    write.table(sigdFrame, file=paste("pValuesForTaxa_bug_treatmentItime_batch_byGroup_sig_", taxa, ".txt",sep=""), sep="\t",row.names=FALSE)

    dev.off()
}

myColClasses
rm(list=ls())

library("pscl")
library("lmtest")
library("nlme")
library("vegan")

setwd("/Users/mbrown67/Documents/Fodor/Datasets/MarkExperiment/Pooled/")

taxaLevels <- c( "phylum", "class", "order", "family", "genus")

for(taxa in taxaLevels){

    inFileName <- paste( taxa, "LogNormwithMetadata_R1_Pooled.txt", sep ="")
    myT <-read.csv(inFileName,header=TRUE,sep="", na.strings="BLAH")

    numCols <- ncol(myT)
    numMetadataCols <- 20

    ## Reprocessing for correct column data type
    myColClasses <- c("character", rep("numeric", numCols - numMetadataCols - 2), rep("character", 16), "numeric", "numeric", "numeric", "character", "character", "numeric", "character", "character", "character")
    myT <-read.csv(inFileName, header=TRUE, sep="", colClasses=myColClasses, na.strings="BLAH", comment.char ="@")

    ## Removing unwanted samples {controls, replicates, duplicates, poor quality samples}
    removeControls<-c( "C1", "C2", "N1", "N2", "Neg", "Pos")
    myT<-myT[!(myT$Sample_ID %in% removeControls),]

    removetrs<-c("04_125_tr", "04_101_tr", "04_103_tr", "04_74_tr", "04_70_tr", "04_40_tr", "04_41_tr", "04_84_tr")
    myT<-myT[!(myT$Sample_ID %in% removetrs),]

    removeDups<-c("04-04_S63_L001_R1_001")
    myT<-myT[!(myT$MatchFile %in% removeDups),]

    ## Controls not dropped earlier
    manualDrop <- c("Neg_S40_L001_R1_001", "PCR1Neg_S65_L001_R1_001")
    myT<-myT[!(myT$MatchFile %in% manualDrop),]

    labDrop <- c("Harlan Labs")
    myT<-myT[!(myT$MouseOrigin %in% labDrop),]

    lowSeqDrop <- c("04-55_S32_L001_R1_001")
    myT<-myT[!(myT$MatchFile %in% lowSeqDrop),]
    ## Not sure what to do about this though.
    ### myT$Condition[which(myT$Treatment == "Ctrl", arr.ind = TRUE)]<-"Control"

    names <- vector()
    pValuesSex<- vector()
    pValuesAcuteChronic<- vector()
    pValuesCage<- vector()
    iccCage <- vector()
    iccKeptCounts <- vector()
    pValuesBatch<- vector()
    pValuesTreatment<- vector()
    pValuesTime <- vector()
    pValuesStressLength <- vector()
    pValuesInteraction <- vector()
    allpvals <- list()

    index <- 1

    pdf( paste(taxa, "_treatmentItime_batch_byGroup_boxplots.pdf", sep=""))

    for( i in 2:(ncol(myT) - numMetadataCols))
        if( sum(myT[,i] != 0 ) > nrow(myT) / 4 ){
            ## Easy access names
            bug <- myT[,i]
            ac <- myT$Condition
            sex <- myT$Sex
            cage <- myT$Cage
            batch <- myT$Sample_Plate
            date <- myT$Date
            mo <- myT$MouseOrigin
            group <- myT$SpreadsheetGrouping
            treatment <- myT$Treatment
            time <- myT$StressLength
            multiWay <- paste(ac, myT$StressLength)
            multiWay[which(myT$Treatment == "Ctrl", arr.ind = TRUE)]<-"Control"
            names[index] = names(myT)[i]
            ## Some kind of vector for the variables of interest
            myFrame <- data.frame(bug, ac, time, multiWay, sex, cage, treatment, batch, date, mo, date)
            mlm<-TRUE
            if(mlm == TRUE){
                fullModel <- gls( bug~   treatment*time + batch, method="REML",correlation=corCompSymm(form=~1|factor(group)),	data = myFrame )
                reducedModel <- gls( bug~ treatment*time + batch, method="REML", data = myFrame )
                fullModelLME <- lme(bug~  treatment*time + batch, method="REML", random = ~1|factor(group), data = myFrame)
            }
            else{
                fullModelLME <- lm(bug~ treatment*time + batch, x=TRUE)
            }
            ## Potential save time by reducing anova calls
            ## Introduce the goodness of fit tests here
            ## Can streamline vectors to be automatically responsive to changes to the model
            allNames <- rownames(anova(fullModelLME))[-1]
            allpvals[[index]] <- anova(fullModelLME)$"p-value"[-1]

            ## pValuesAcuteChronic[index] <- anova(fullModelLME)$"p-value"[2]
            ## pValuesTime[index] <- anova(fullModelLME)$"p-value"[6]
            ## pValuesInteraction[index] <- anova(fullModelLME)$"p-value"[6]
            ## pValuesSex[index] <- anova(fullModelLME)$"p-value"[6]
            ## pValuesExperiment[index] <- anova(fullModelLME)$"p-value"[6]
            ## pValuesBatch[index] <- anova(fullModelLME)$"p-value"[3]
            ## pValuesTreatment[index] <- anova(fullModelLME)$"p-value"[6]

            ## Random Effects and Interclass Correlation Coefficient
            if(mlm == TRUE){
                allNames<-c(allNames, "cage", "iccCage")
                allpvals[[index]]<-c(allpvals[[index]], anova(fullModelLME, reducedModel)$"p-value"[2], coef(fullModel$modelStruct[1]$corStruct,unconstrained=FALSE)[[1]])
                pValuesCage[index] <-  anova(fullModelLME, reducedModel)$"p-value"[2]
                ## This is different as it is not corrected for multiple hypothesis testing.
                iccCage[index]<- coef(fullModel$modelStruct[1]$corStruct,unconstrained=FALSE)[[1]]
            }
    ## Nice plotting
            ## Correct so that it uses corrected p-values
            graphMain = c(names[i], paste(c(rep("p-",length(allNames)-1),""), allNames, " = ", format(allpvals[[index]], digits=3), sep=""))
            ## graphMain =  paste( names(myT)[i], "\n",
            ##     ## " pTreatment= ", format(pValuesTreatment[index], digits=3),
            ##     ## " pTime= ", format(pValuesTime[index], digits=3),"\n",
            ##     ## " pTreatmentXTime= ", format(pValuesInteraction[index], digits=3),"\n",
            ##     ## " pSex=", format( pValuesSex[index], digits=3),
            ##     " pCondition= ", format( pValuesAcuteChronic[index],digits=3),
            ##     " pBatch= ", format(pValuesBatch[index], digits=3), "\n",
            ##     ## " pTreatment= ", format(pValuesTreatment[index], digits=3),
            ##     ## " pExperiment= ", format(pValuesExperiment[index], digits=3),
            ##     ## " pShannon= ", format(pValuesShannon[index], digits=3),
            ##     ## " pKeptCounts= ", format(pValuesKeptCounts[index], digits=3),
            ##     " pDate= " , format( pValuesCage[index], digits=3),
            ##     " icc= " , format( iccCage[index], digits=3 ), sep="")

            ## mlm is boolean 1/0 value. Basically, don't graph on icc
            ## need a correction for interaction terms as well
            numPlots <- length(allNames) - mlm
            par(mfrow=c(numPlots, 1),
                oma = c(1,1,0,0) + 0.1,
                mar = c(1,4,3,0) + 0.1)

            for(j in 1:numPlots){
                if(j == 1){
                    plot( bug ~ factor(get(allNames[j])), ylab = names[i], main = c(names[index],toString(graphMain[-1])) )
                    points(factor(get(allNames[j])), bug)
                }
                else{
                    testInteract <- grep(":", allNames)
                    if(length(testInteract) > 0){
                        if(j == testInteract){
                            intSplit <- unlist(strsplit(allNames[grep(":",allNames)],split=":"))
                            plot( bug ~ factor(c( paste( get(intSplit[1]), get(intSplit[2]),sep=""))))
                            points(factor(c( paste( get(intSplit[1]), get(intSplit[2]),sep=""))), bug)
                        }
                    }
                    else{
                        plot( bug ~ factor(get(allNames[j])), ylab = names[i])
                        points(factor(get(allNames[j])), bug)
                    }
                }
            }
                ##plot( bug ~ factor(ac), ylab = names[index],main = graphMain )
                ##points(factor(ac), bug)

                ## plot ( bug ~ factor(ac) )
                ## points(factor(ac), bug)

                ## plot( bug ~ factor(c( paste( sl, treatment,sep=""))))
                ## points(factor(c( paste( sl, treatment,sep=""))), bug)

                ##plot ( bug ~ factor(batch) )
                ##points(factor(batch), bug)

                ##plot( bug ~ factor(date), ylab=names[index])
                ##points(factor(date), bug)

            index <- index + 1
	}

    ## This should also be dynamic
    dFrame <- as.data.frame(matrix(unlist(allpvals), nrow= length(allpvals), byrow=TRUE))
    colnames(dFrame) <- unlist(allNames)
    rownames(dFrame) <- names
    orgCol <- ncol(dFrame)

    for(k in 1:(orgCol-1)){
        dFrame[, k + orgCol]<-p.adjust(dFrame[,k], method = "BH")
    }
    colnames(dFrame)[(orgCol + 1):length(dFrame)]<-paste0(rep("adjusted_"),colnames(dFrame)[1:(orgCol - 1)])
    ## dFrame <- data.frame( names, pValuesTreatment, pValuesBatch, pValuesCage, iccCage)
    ## pValuesTreatment)#, pValuesBatch)#, pValuesExperiment)

    ## dFrame <- dFrame[order(pValuesAcuteChronic),]
    ## dFrame$adjustedAcuteChronic <- p.adjust( dFrame$pValuesAcuteChronic, method = "BH" )
    ## dFrame$adjustedSex<- p.adjust( dFrame$pValuesSex, method = "BH" )
    ## dFrame$adjustedTreatment<- p.adjust( dFrame$pValuesTreatment, method = "BH" )
    ## dFrame$adjustedStressLength <- p.adjust( dFrame$pValuesStressLength, method = "BH")
    ## dFrame$adjustedInteraction <- p.adjust( dFrame$pValuesInteraction, method = "BH" )
    ## dFrame$adjustedBatch<- p.adjust( dFrame$pValuesBatch, method = "BH" )
    ## dFrame$adjustedCage <- p.adjust( dFrame$pValuesCage, method = "BH" )
    ## Try and dynamically generate the name of the plot here...
    write.table(dFrame, file=paste("pValuesForTaxa_bug_treatmentItime_batch_byGroup_", taxa, ".txt",sep=""), sep="\t",row.names=FALSE)

    ## Get the sig table working
    ## It would also be nice to have a sig-picker for the plots and a combination of all sig results into one plot.
    keepVector <- grep("adj", names(dFrame))
    sigdFrame <-dFrame[which(dFrame[,keepVector] < 0.05,arr.ind=TRUE),]
    write.table(sigdFrame, file=paste("pValuesForTaxa_bug_treatmentItime_batch_byGroup_sig_", taxa, ".txt",sep=""), sep="\t",row.names=FALSE)

    dev.off()
}

myT[1,]
colnames(myT)
rm(list=ls())

library("pscl")
library("lmtest")
library("nlme")
library("vegan")

setwd("/Users/mbrown67/Documents/Fodor/Datasets/MarkExperiment/Pooled/")

taxaLevels <- c( "phylum", "class", "order", "family", "genus")

for(taxa in taxaLevels){

    inFileName <- paste( taxa, "LogNormwithMetadata_R1_Pooled.txt", sep ="")
    myT <-read.csv(inFileName,header=TRUE,sep="", na.strings="BLAH")

    numCols <- ncol(myT)
    numMetadataCols <- 20

    ## Reprocessing for correct column data type
    myColClasses <- c("character", rep("numeric", numCols - numMetadataCols - 2), rep("character", 11), "numeric", "numeric", "numeric", "character", "character", "character", "character", "character", "character")
    myT <-read.csv(inFileName, header=TRUE, sep="", colClasses=myColClasses, na.strings="BLAH", comment.char ="@")

    ## Removing unwanted samples {controls, replicates, duplicates, poor quality samples}
    removeControls<-c( "C1", "C2", "N1", "N2", "Neg", "Pos")
    myT<-myT[!(myT$Sample_ID %in% removeControls),]

    removetrs<-c("04_125_tr", "04_101_tr", "04_103_tr", "04_74_tr", "04_70_tr", "04_40_tr", "04_41_tr", "04_84_tr")
    myT<-myT[!(myT$Sample_ID %in% removetrs),]

    removeDups<-c("04-04_S63_L001_R1_001")
    myT<-myT[!(myT$MatchFile %in% removeDups),]

    ## Controls not dropped earlier
    manualDrop <- c("Neg_S40_L001_R1_001", "PCR1Neg_S65_L001_R1_001")
    myT<-myT[!(myT$MatchFile %in% manualDrop),]

    labDrop <- c("Harlan Labs")
    myT<-myT[!(myT$MouseOrigin %in% labDrop),]

    lowSeqDrop <- c("04-55_S32_L001_R1_001")
    myT<-myT[!(myT$MatchFile %in% lowSeqDrop),]
    ## Not sure what to do about this though.
    ### myT$Condition[which(myT$Treatment == "Ctrl", arr.ind = TRUE)]<-"Control"

    names <- vector()
    pValuesSex<- vector()
    pValuesAcuteChronic<- vector()
    pValuesCage<- vector()
    iccCage <- vector()
    iccKeptCounts <- vector()
    pValuesBatch<- vector()
    pValuesTreatment<- vector()
    pValuesTime <- vector()
    pValuesStressLength <- vector()
    pValuesInteraction <- vector()
    allpvals <- list()

    index <- 1

    pdf( paste(taxa, "_treatmentItime_batch_byGroup_boxplots.pdf", sep=""))

    for( i in 2:(ncol(myT) - numMetadataCols))
        if( sum(myT[,i] != 0 ) > nrow(myT) / 4 ){
            ## Easy access names
            bug <- myT[,i]
            ac <- myT$Condition
            sex <- myT$Sex
            cage <- myT$Cage
            batch <- myT$Sample_Plate
            date <- myT$Date
            mo <- myT$MouseOrigin
            group <- myT$SpreadsheetGrouping
            treatment <- myT$Treatment
            time <- myT$StressLength
            multiWay <- paste(ac, myT$StressLength)
            multiWay[which(myT$Treatment == "Ctrl", arr.ind = TRUE)]<-"Control"
            names[index] = names(myT)[i]
            ## Some kind of vector for the variables of interest
            myFrame <- data.frame(bug, ac, time, multiWay, sex, cage, treatment, batch, date, mo, date)
            mlm<-TRUE
            if(mlm == TRUE){
                fullModel <- gls( bug~   treatment*time + batch, method="REML",correlation=corCompSymm(form=~1|factor(group)),	data = myFrame )
                reducedModel <- gls( bug~ treatment*time + batch, method="REML", data = myFrame )
                fullModelLME <- lme(bug~  treatment*time + batch, method="REML", random = ~1|factor(group), data = myFrame)
            }
            else{
                fullModelLME <- lm(bug~ treatment*time + batch, x=TRUE)
            }
            ## Potential save time by reducing anova calls
            ## Introduce the goodness of fit tests here
            ## Can streamline vectors to be automatically responsive to changes to the model
            allNames <- rownames(anova(fullModelLME))[-1]
            allpvals[[index]] <- anova(fullModelLME)$"p-value"[-1]

            ## pValuesAcuteChronic[index] <- anova(fullModelLME)$"p-value"[2]
            ## pValuesTime[index] <- anova(fullModelLME)$"p-value"[6]
            ## pValuesInteraction[index] <- anova(fullModelLME)$"p-value"[6]
            ## pValuesSex[index] <- anova(fullModelLME)$"p-value"[6]
            ## pValuesExperiment[index] <- anova(fullModelLME)$"p-value"[6]
            ## pValuesBatch[index] <- anova(fullModelLME)$"p-value"[3]
            ## pValuesTreatment[index] <- anova(fullModelLME)$"p-value"[6]

            ## Random Effects and Interclass Correlation Coefficient
            if(mlm == TRUE){
                allNames<-c(allNames, "cage", "iccCage")
                allpvals[[index]]<-c(allpvals[[index]], anova(fullModelLME, reducedModel)$"p-value"[2], coef(fullModel$modelStruct[1]$corStruct,unconstrained=FALSE)[[1]])
                pValuesCage[index] <-  anova(fullModelLME, reducedModel)$"p-value"[2]
                ## This is different as it is not corrected for multiple hypothesis testing.
                iccCage[index]<- coef(fullModel$modelStruct[1]$corStruct,unconstrained=FALSE)[[1]]
            }
    ## Nice plotting
            ## Correct so that it uses corrected p-values
            graphMain = c(names[i], paste(c(rep("p-",length(allNames)-1),""), allNames, " = ", format(allpvals[[index]], digits=3), sep=""))
            ## graphMain =  paste( names(myT)[i], "\n",
            ##     ## " pTreatment= ", format(pValuesTreatment[index], digits=3),
            ##     ## " pTime= ", format(pValuesTime[index], digits=3),"\n",
            ##     ## " pTreatmentXTime= ", format(pValuesInteraction[index], digits=3),"\n",
            ##     ## " pSex=", format( pValuesSex[index], digits=3),
            ##     " pCondition= ", format( pValuesAcuteChronic[index],digits=3),
            ##     " pBatch= ", format(pValuesBatch[index], digits=3), "\n",
            ##     ## " pTreatment= ", format(pValuesTreatment[index], digits=3),
            ##     ## " pExperiment= ", format(pValuesExperiment[index], digits=3),
            ##     ## " pShannon= ", format(pValuesShannon[index], digits=3),
            ##     ## " pKeptCounts= ", format(pValuesKeptCounts[index], digits=3),
            ##     " pDate= " , format( pValuesCage[index], digits=3),
            ##     " icc= " , format( iccCage[index], digits=3 ), sep="")

            ## mlm is boolean 1/0 value. Basically, don't graph on icc
            ## need a correction for interaction terms as well
            numPlots <- length(allNames) - mlm
            par(mfrow=c(numPlots, 1),
                oma = c(1,1,0,0) + 0.1,
                mar = c(1,4,3,0) + 0.1)

            for(j in 1:numPlots){
                if(j == 1){
                    plot( bug ~ factor(get(allNames[j])), ylab = names[i], main = c(names[index],toString(graphMain[-1])) )
                    points(factor(get(allNames[j])), bug)
                }
                else{
                    testInteract <- grep(":", allNames)
                    if(length(testInteract) > 0){
                        if(j == testInteract){
                            intSplit <- unlist(strsplit(allNames[grep(":",allNames)],split=":"))
                            plot( bug ~ factor(c( paste( get(intSplit[1]), get(intSplit[2]),sep=""))))
                            points(factor(c( paste( get(intSplit[1]), get(intSplit[2]),sep=""))), bug)
                        }
                    }
                    else{
                        plot( bug ~ factor(get(allNames[j])), ylab = names[i])
                        points(factor(get(allNames[j])), bug)
                    }
                }
            }
                ##plot( bug ~ factor(ac), ylab = names[index],main = graphMain )
                ##points(factor(ac), bug)

                ## plot ( bug ~ factor(ac) )
                ## points(factor(ac), bug)

                ## plot( bug ~ factor(c( paste( sl, treatment,sep=""))))
                ## points(factor(c( paste( sl, treatment,sep=""))), bug)

                ##plot ( bug ~ factor(batch) )
                ##points(factor(batch), bug)

                ##plot( bug ~ factor(date), ylab=names[index])
                ##points(factor(date), bug)

            index <- index + 1
	}

    ## This should also be dynamic
    dFrame <- as.data.frame(matrix(unlist(allpvals), nrow= length(allpvals), byrow=TRUE))
    colnames(dFrame) <- unlist(allNames)
    rownames(dFrame) <- names
    orgCol <- ncol(dFrame)

    for(k in 1:(orgCol-1)){
        dFrame[, k + orgCol]<-p.adjust(dFrame[,k], method = "BH")
    }
    colnames(dFrame)[(orgCol + 1):length(dFrame)]<-paste0(rep("adjusted_"),colnames(dFrame)[1:(orgCol - 1)])
    ## dFrame <- data.frame( names, pValuesTreatment, pValuesBatch, pValuesCage, iccCage)
    ## pValuesTreatment)#, pValuesBatch)#, pValuesExperiment)

    ## dFrame <- dFrame[order(pValuesAcuteChronic),]
    ## dFrame$adjustedAcuteChronic <- p.adjust( dFrame$pValuesAcuteChronic, method = "BH" )
    ## dFrame$adjustedSex<- p.adjust( dFrame$pValuesSex, method = "BH" )
    ## dFrame$adjustedTreatment<- p.adjust( dFrame$pValuesTreatment, method = "BH" )
    ## dFrame$adjustedStressLength <- p.adjust( dFrame$pValuesStressLength, method = "BH")
    ## dFrame$adjustedInteraction <- p.adjust( dFrame$pValuesInteraction, method = "BH" )
    ## dFrame$adjustedBatch<- p.adjust( dFrame$pValuesBatch, method = "BH" )
    ## dFrame$adjustedCage <- p.adjust( dFrame$pValuesCage, method = "BH" )
    ## Try and dynamically generate the name of the plot here...
    write.table(dFrame, file=paste("pValuesForTaxa_bug_treatmentItime_batch_byGroup_", taxa, ".txt",sep=""), sep="\t",row.names=FALSE)

    ## Get the sig table working
    ## It would also be nice to have a sig-picker for the plots and a combination of all sig results into one plot.
    keepVector <- grep("adj", names(dFrame))
    sigdFrame <-dFrame[which(dFrame[,keepVector] < 0.05,arr.ind=TRUE),]
    write.table(sigdFrame, file=paste("pValuesForTaxa_bug_treatmentItime_batch_byGroup_sig_", taxa, ".txt",sep=""), sep="\t",row.names=FALSE)

    dev.off()
}

colnames(myT)
colnames(myT)[numCols - numMetadataCols - 2]
class(myT[,numCols - numMetadataCols - 2])
class(myT[,numCols - numMetadataCols - 1])
colnames(myT)[,numCols - numMetadataCols - 2]
colnames(myT)[numCols - numMetadataCols - 1]
colnames(myT)[numCols - numMetadataCols]
colnames(myT)[numCols - numMetadataCols + 1]
class(myT)[numCols - numMetadataCols]
class(myT)[numCols - numMetadataCols + 1]
class(myT[,numCols - numMetadataCols + 1])
rm(list=ls())

library("pscl")
library("lmtest")
library("nlme")
library("vegan")

setwd("/Users/mbrown67/Documents/Fodor/Datasets/MarkExperiment/Pooled/")

taxaLevels <- c( "phylum", "class", "order", "family", "genus")

for(taxa in taxaLevels){

    inFileName <- paste( taxa, "LogNormwithMetadata_R1_Pooled.txt", sep ="")
    myT <-read.csv(inFileName,header=TRUE,sep="", na.strings="BLAH")

    numCols <- ncol(myT)
    numMetadataCols <- 20

    ## Reprocessing for correct column data type
    myColClasses <- c("character", rep("numeric", numCols - numMetadataCols), rep("character", 11), "numeric", "numeric", "numeric", "character", "character", "character", "character", "character", "character")
    myT <-read.csv(inFileName, header=TRUE, sep="", colClasses=myColClasses, na.strings="BLAH", comment.char ="@")

    ## Removing unwanted samples {controls, replicates, duplicates, poor quality samples}
    removeControls<-c( "C1", "C2", "N1", "N2", "Neg", "Pos")
    myT<-myT[!(myT$Sample_ID %in% removeControls),]

    removetrs<-c("04_125_tr", "04_101_tr", "04_103_tr", "04_74_tr", "04_70_tr", "04_40_tr", "04_41_tr", "04_84_tr")
    myT<-myT[!(myT$Sample_ID %in% removetrs),]

    removeDups<-c("04-04_S63_L001_R1_001")
    myT<-myT[!(myT$MatchFile %in% removeDups),]

    ## Controls not dropped earlier
    manualDrop <- c("Neg_S40_L001_R1_001", "PCR1Neg_S65_L001_R1_001")
    myT<-myT[!(myT$MatchFile %in% manualDrop),]

    labDrop <- c("Harlan Labs")
    myT<-myT[!(myT$MouseOrigin %in% labDrop),]

    lowSeqDrop <- c("04-55_S32_L001_R1_001")
    myT<-myT[!(myT$MatchFile %in% lowSeqDrop),]
    ## Not sure what to do about this though.
    ### myT$Condition[which(myT$Treatment == "Ctrl", arr.ind = TRUE)]<-"Control"

    names <- vector()
    pValuesSex<- vector()
    pValuesAcuteChronic<- vector()
    pValuesCage<- vector()
    iccCage <- vector()
    iccKeptCounts <- vector()
    pValuesBatch<- vector()
    pValuesTreatment<- vector()
    pValuesTime <- vector()
    pValuesStressLength <- vector()
    pValuesInteraction <- vector()
    allpvals <- list()

    index <- 1

    pdf( paste(taxa, "_treatmentItime_batch_byGroup_boxplots.pdf", sep=""))

    for( i in 2:(ncol(myT) - numMetadataCols))
        if( sum(myT[,i] != 0 ) > nrow(myT) / 4 ){
            ## Easy access names
            bug <- myT[,i]
            ac <- myT$Condition
            sex <- myT$Sex
            cage <- myT$Cage
            batch <- myT$Sample_Plate
            date <- myT$Date
            mo <- myT$MouseOrigin
            group <- myT$SpreadsheetGrouping
            treatment <- myT$Treatment
            time <- myT$StressLength
            multiWay <- paste(ac, myT$StressLength)
            multiWay[which(myT$Treatment == "Ctrl", arr.ind = TRUE)]<-"Control"
            names[index] = names(myT)[i]
            ## Some kind of vector for the variables of interest
            myFrame <- data.frame(bug, ac, time, multiWay, sex, cage, treatment, batch, date, mo, date)
            mlm<-TRUE
            if(mlm == TRUE){
                fullModel <- gls( bug~   treatment*time + batch, method="REML",correlation=corCompSymm(form=~1|factor(group)),	data = myFrame )
                reducedModel <- gls( bug~ treatment*time + batch, method="REML", data = myFrame )
                fullModelLME <- lme(bug~  treatment*time + batch, method="REML", random = ~1|factor(group), data = myFrame)
            }
            else{
                fullModelLME <- lm(bug~ treatment*time + batch, x=TRUE)
            }
            ## Potential save time by reducing anova calls
            ## Introduce the goodness of fit tests here
            ## Can streamline vectors to be automatically responsive to changes to the model
            allNames <- rownames(anova(fullModelLME))[-1]
            allpvals[[index]] <- anova(fullModelLME)$"p-value"[-1]

            ## pValuesAcuteChronic[index] <- anova(fullModelLME)$"p-value"[2]
            ## pValuesTime[index] <- anova(fullModelLME)$"p-value"[6]
            ## pValuesInteraction[index] <- anova(fullModelLME)$"p-value"[6]
            ## pValuesSex[index] <- anova(fullModelLME)$"p-value"[6]
            ## pValuesExperiment[index] <- anova(fullModelLME)$"p-value"[6]
            ## pValuesBatch[index] <- anova(fullModelLME)$"p-value"[3]
            ## pValuesTreatment[index] <- anova(fullModelLME)$"p-value"[6]

            ## Random Effects and Interclass Correlation Coefficient
            if(mlm == TRUE){
                allNames<-c(allNames, "cage", "iccCage")
                allpvals[[index]]<-c(allpvals[[index]], anova(fullModelLME, reducedModel)$"p-value"[2], coef(fullModel$modelStruct[1]$corStruct,unconstrained=FALSE)[[1]])
                pValuesCage[index] <-  anova(fullModelLME, reducedModel)$"p-value"[2]
                ## This is different as it is not corrected for multiple hypothesis testing.
                iccCage[index]<- coef(fullModel$modelStruct[1]$corStruct,unconstrained=FALSE)[[1]]
            }
    ## Nice plotting
            ## Correct so that it uses corrected p-values
            graphMain = c(names[i], paste(c(rep("p-",length(allNames)-1),""), allNames, " = ", format(allpvals[[index]], digits=3), sep=""))
            ## graphMain =  paste( names(myT)[i], "\n",
            ##     ## " pTreatment= ", format(pValuesTreatment[index], digits=3),
            ##     ## " pTime= ", format(pValuesTime[index], digits=3),"\n",
            ##     ## " pTreatmentXTime= ", format(pValuesInteraction[index], digits=3),"\n",
            ##     ## " pSex=", format( pValuesSex[index], digits=3),
            ##     " pCondition= ", format( pValuesAcuteChronic[index],digits=3),
            ##     " pBatch= ", format(pValuesBatch[index], digits=3), "\n",
            ##     ## " pTreatment= ", format(pValuesTreatment[index], digits=3),
            ##     ## " pExperiment= ", format(pValuesExperiment[index], digits=3),
            ##     ## " pShannon= ", format(pValuesShannon[index], digits=3),
            ##     ## " pKeptCounts= ", format(pValuesKeptCounts[index], digits=3),
            ##     " pDate= " , format( pValuesCage[index], digits=3),
            ##     " icc= " , format( iccCage[index], digits=3 ), sep="")

            ## mlm is boolean 1/0 value. Basically, don't graph on icc
            ## need a correction for interaction terms as well
            numPlots <- length(allNames) - mlm
            par(mfrow=c(numPlots, 1),
                oma = c(1,1,0,0) + 0.1,
                mar = c(1,4,3,0) + 0.1)

            for(j in 1:numPlots){
                if(j == 1){
                    plot( bug ~ factor(get(allNames[j])), ylab = names[i], main = c(names[index],toString(graphMain[-1])) )
                    points(factor(get(allNames[j])), bug)
                }
                else{
                    testInteract <- grep(":", allNames)
                    if(length(testInteract) > 0){
                        if(j == testInteract){
                            intSplit <- unlist(strsplit(allNames[grep(":",allNames)],split=":"))
                            plot( bug ~ factor(c( paste( get(intSplit[1]), get(intSplit[2]),sep=""))))
                            points(factor(c( paste( get(intSplit[1]), get(intSplit[2]),sep=""))), bug)
                        }
                    }
                    else{
                        plot( bug ~ factor(get(allNames[j])), ylab = names[i])
                        points(factor(get(allNames[j])), bug)
                    }
                }
            }
                ##plot( bug ~ factor(ac), ylab = names[index],main = graphMain )
                ##points(factor(ac), bug)

                ## plot ( bug ~ factor(ac) )
                ## points(factor(ac), bug)

                ## plot( bug ~ factor(c( paste( sl, treatment,sep=""))))
                ## points(factor(c( paste( sl, treatment,sep=""))), bug)

                ##plot ( bug ~ factor(batch) )
                ##points(factor(batch), bug)

                ##plot( bug ~ factor(date), ylab=names[index])
                ##points(factor(date), bug)

            index <- index + 1
	}

    ## This should also be dynamic
    dFrame <- as.data.frame(matrix(unlist(allpvals), nrow= length(allpvals), byrow=TRUE))
    colnames(dFrame) <- unlist(allNames)
    rownames(dFrame) <- names
    orgCol <- ncol(dFrame)

    for(k in 1:(orgCol-1)){
        dFrame[, k + orgCol]<-p.adjust(dFrame[,k], method = "BH")
    }
    colnames(dFrame)[(orgCol + 1):length(dFrame)]<-paste0(rep("adjusted_"),colnames(dFrame)[1:(orgCol - 1)])
    ## dFrame <- data.frame( names, pValuesTreatment, pValuesBatch, pValuesCage, iccCage)
    ## pValuesTreatment)#, pValuesBatch)#, pValuesExperiment)

    ## dFrame <- dFrame[order(pValuesAcuteChronic),]
    ## dFrame$adjustedAcuteChronic <- p.adjust( dFrame$pValuesAcuteChronic, method = "BH" )
    ## dFrame$adjustedSex<- p.adjust( dFrame$pValuesSex, method = "BH" )
    ## dFrame$adjustedTreatment<- p.adjust( dFrame$pValuesTreatment, method = "BH" )
    ## dFrame$adjustedStressLength <- p.adjust( dFrame$pValuesStressLength, method = "BH")
    ## dFrame$adjustedInteraction <- p.adjust( dFrame$pValuesInteraction, method = "BH" )
    ## dFrame$adjustedBatch<- p.adjust( dFrame$pValuesBatch, method = "BH" )
    ## dFrame$adjustedCage <- p.adjust( dFrame$pValuesCage, method = "BH" )
    ## Try and dynamically generate the name of the plot here...
    write.table(dFrame, file=paste("pValuesForTaxa_bug_treatmentItime_batch_byGroup_", taxa, ".txt",sep=""), sep="\t",row.names=FALSE)

    ## Get the sig table working
    ## It would also be nice to have a sig-picker for the plots and a combination of all sig results into one plot.
    keepVector <- grep("adj", names(dFrame))
    sigdFrame <-dFrame[which(dFrame[,keepVector] < 0.05,arr.ind=TRUE),]
    write.table(sigdFrame, file=paste("pValuesForTaxa_bug_treatmentItime_batch_byGroup_sig_", taxa, ".txt",sep=""), sep="\t",row.names=FALSE)

    dev.off()
}

class(myT[1,])
colnames(myT)
myColClasses
class(myT$Sample_ID)
class(myT[,48])
myT[,48]
class(myT[,49])
myT[,49]
colnames(myT)
rm(list=ls())

library("pscl")
library("lmtest")
library("nlme")
library("vegan")

setwd("/Users/mbrown67/Documents/Fodor/Datasets/MarkExperiment/Pooled/")

taxaLevels <- c( "phylum", "class", "order", "family", "genus")

for(taxa in taxaLevels){

    inFileName <- paste( taxa, "LogNormwithMetadata_R1_Pooled.txt", sep ="")
    myT <-read.csv(inFileName,header=TRUE,sep="", na.strings="BLAH")

    numCols <- ncol(myT)
    numMetadataCols <- 20

    ## Reprocessing for correct column data type
    myColClasses <- c("character", rep("numeric", numCols - numMetadataCols - 1), rep("character", 11), "numeric", "numeric", "numeric", "character", "character", "character", "character", "character", "character")
    myT <-read.csv(inFileName, header=TRUE, sep="", colClasses=myColClasses, na.strings="BLAH", comment.char ="@")

    ## Removing unwanted samples {controls, replicates, duplicates, poor quality samples}
    removeControls<-c( "C1", "C2", "N1", "N2", "Neg", "Pos")
    myT<-myT[!(myT$Sample_ID %in% removeControls),]

    removetrs<-c("04_125_tr", "04_101_tr", "04_103_tr", "04_74_tr", "04_70_tr", "04_40_tr", "04_41_tr", "04_84_tr")
    myT<-myT[!(myT$Sample_ID %in% removetrs),]

    removeDups<-c("04-04_S63_L001_R1_001")
    myT<-myT[!(myT$MatchFile %in% removeDups),]

    ## Controls not dropped earlier
    manualDrop <- c("Neg_S40_L001_R1_001", "PCR1Neg_S65_L001_R1_001")
    myT<-myT[!(myT$MatchFile %in% manualDrop),]

    labDrop <- c("Harlan Labs")
    myT<-myT[!(myT$MouseOrigin %in% labDrop),]

    lowSeqDrop <- c("04-55_S32_L001_R1_001")
    myT<-myT[!(myT$MatchFile %in% lowSeqDrop),]
    ## Not sure what to do about this though.
    ### myT$Condition[which(myT$Treatment == "Ctrl", arr.ind = TRUE)]<-"Control"

    names <- vector()
    pValuesSex<- vector()
    pValuesAcuteChronic<- vector()
    pValuesCage<- vector()
    iccCage <- vector()
    iccKeptCounts <- vector()
    pValuesBatch<- vector()
    pValuesTreatment<- vector()
    pValuesTime <- vector()
    pValuesStressLength <- vector()
    pValuesInteraction <- vector()
    allpvals <- list()

    index <- 1

    pdf( paste(taxa, "_treatmentItime_batch_byGroup_boxplots.pdf", sep=""))

    for( i in 2:(ncol(myT) - numMetadataCols))
        if( sum(myT[,i] != 0 ) > nrow(myT) / 4 ){
            ## Easy access names
            bug <- myT[,i]
            ac <- myT$Condition
            sex <- myT$Sex
            cage <- myT$Cage
            batch <- myT$Sample_Plate
            date <- myT$Date
            mo <- myT$MouseOrigin
            group <- myT$SpreadsheetGrouping
            treatment <- myT$Treatment
            time <- myT$StressLength
            multiWay <- paste(ac, myT$StressLength)
            multiWay[which(myT$Treatment == "Ctrl", arr.ind = TRUE)]<-"Control"
            names[index] = names(myT)[i]
            ## Some kind of vector for the variables of interest
            myFrame <- data.frame(bug, ac, time, multiWay, sex, cage, treatment, batch, date, mo, date)
            mlm<-TRUE
            if(mlm == TRUE){
                fullModel <- gls( bug~   treatment*time + batch, method="REML",correlation=corCompSymm(form=~1|factor(group)),	data = myFrame )
                reducedModel <- gls( bug~ treatment*time + batch, method="REML", data = myFrame )
                fullModelLME <- lme(bug~  treatment*time + batch, method="REML", random = ~1|factor(group), data = myFrame)
            }
            else{
                fullModelLME <- lm(bug~ treatment*time + batch, x=TRUE)
            }
            ## Potential save time by reducing anova calls
            ## Introduce the goodness of fit tests here
            ## Can streamline vectors to be automatically responsive to changes to the model
            allNames <- rownames(anova(fullModelLME))[-1]
            allpvals[[index]] <- anova(fullModelLME)$"p-value"[-1]

            ## pValuesAcuteChronic[index] <- anova(fullModelLME)$"p-value"[2]
            ## pValuesTime[index] <- anova(fullModelLME)$"p-value"[6]
            ## pValuesInteraction[index] <- anova(fullModelLME)$"p-value"[6]
            ## pValuesSex[index] <- anova(fullModelLME)$"p-value"[6]
            ## pValuesExperiment[index] <- anova(fullModelLME)$"p-value"[6]
            ## pValuesBatch[index] <- anova(fullModelLME)$"p-value"[3]
            ## pValuesTreatment[index] <- anova(fullModelLME)$"p-value"[6]

            ## Random Effects and Interclass Correlation Coefficient
            if(mlm == TRUE){
                allNames<-c(allNames, "cage", "iccCage")
                allpvals[[index]]<-c(allpvals[[index]], anova(fullModelLME, reducedModel)$"p-value"[2], coef(fullModel$modelStruct[1]$corStruct,unconstrained=FALSE)[[1]])
                pValuesCage[index] <-  anova(fullModelLME, reducedModel)$"p-value"[2]
                ## This is different as it is not corrected for multiple hypothesis testing.
                iccCage[index]<- coef(fullModel$modelStruct[1]$corStruct,unconstrained=FALSE)[[1]]
            }
    ## Nice plotting
            ## Correct so that it uses corrected p-values
            graphMain = c(names[i], paste(c(rep("p-",length(allNames)-1),""), allNames, " = ", format(allpvals[[index]], digits=3), sep=""))
            ## graphMain =  paste( names(myT)[i], "\n",
            ##     ## " pTreatment= ", format(pValuesTreatment[index], digits=3),
            ##     ## " pTime= ", format(pValuesTime[index], digits=3),"\n",
            ##     ## " pTreatmentXTime= ", format(pValuesInteraction[index], digits=3),"\n",
            ##     ## " pSex=", format( pValuesSex[index], digits=3),
            ##     " pCondition= ", format( pValuesAcuteChronic[index],digits=3),
            ##     " pBatch= ", format(pValuesBatch[index], digits=3), "\n",
            ##     ## " pTreatment= ", format(pValuesTreatment[index], digits=3),
            ##     ## " pExperiment= ", format(pValuesExperiment[index], digits=3),
            ##     ## " pShannon= ", format(pValuesShannon[index], digits=3),
            ##     ## " pKeptCounts= ", format(pValuesKeptCounts[index], digits=3),
            ##     " pDate= " , format( pValuesCage[index], digits=3),
            ##     " icc= " , format( iccCage[index], digits=3 ), sep="")

            ## mlm is boolean 1/0 value. Basically, don't graph on icc
            ## need a correction for interaction terms as well
            numPlots <- length(allNames) - mlm
            par(mfrow=c(numPlots, 1),
                oma = c(1,1,0,0) + 0.1,
                mar = c(1,4,3,0) + 0.1)

            for(j in 1:numPlots){
                if(j == 1){
                    plot( bug ~ factor(get(allNames[j])), ylab = names[i], main = c(names[index],toString(graphMain[-1])) )
                    points(factor(get(allNames[j])), bug)
                }
                else{
                    testInteract <- grep(":", allNames)
                    if(length(testInteract) > 0){
                        if(j == testInteract){
                            intSplit <- unlist(strsplit(allNames[grep(":",allNames)],split=":"))
                            plot( bug ~ factor(c( paste( get(intSplit[1]), get(intSplit[2]),sep=""))))
                            points(factor(c( paste( get(intSplit[1]), get(intSplit[2]),sep=""))), bug)
                        }
                    }
                    else{
                        plot( bug ~ factor(get(allNames[j])), ylab = names[i])
                        points(factor(get(allNames[j])), bug)
                    }
                }
            }
                ##plot( bug ~ factor(ac), ylab = names[index],main = graphMain )
                ##points(factor(ac), bug)

                ## plot ( bug ~ factor(ac) )
                ## points(factor(ac), bug)

                ## plot( bug ~ factor(c( paste( sl, treatment,sep=""))))
                ## points(factor(c( paste( sl, treatment,sep=""))), bug)

                ##plot ( bug ~ factor(batch) )
                ##points(factor(batch), bug)

                ##plot( bug ~ factor(date), ylab=names[index])
                ##points(factor(date), bug)

            index <- index + 1
	}

    ## This should also be dynamic
    dFrame <- as.data.frame(matrix(unlist(allpvals), nrow= length(allpvals), byrow=TRUE))
    colnames(dFrame) <- unlist(allNames)
    rownames(dFrame) <- names
    orgCol <- ncol(dFrame)

    for(k in 1:(orgCol-1)){
        dFrame[, k + orgCol]<-p.adjust(dFrame[,k], method = "BH")
    }
    colnames(dFrame)[(orgCol + 1):length(dFrame)]<-paste0(rep("adjusted_"),colnames(dFrame)[1:(orgCol - 1)])
    ## dFrame <- data.frame( names, pValuesTreatment, pValuesBatch, pValuesCage, iccCage)
    ## pValuesTreatment)#, pValuesBatch)#, pValuesExperiment)

    ## dFrame <- dFrame[order(pValuesAcuteChronic),]
    ## dFrame$adjustedAcuteChronic <- p.adjust( dFrame$pValuesAcuteChronic, method = "BH" )
    ## dFrame$adjustedSex<- p.adjust( dFrame$pValuesSex, method = "BH" )
    ## dFrame$adjustedTreatment<- p.adjust( dFrame$pValuesTreatment, method = "BH" )
    ## dFrame$adjustedStressLength <- p.adjust( dFrame$pValuesStressLength, method = "BH")
    ## dFrame$adjustedInteraction <- p.adjust( dFrame$pValuesInteraction, method = "BH" )
    ## dFrame$adjustedBatch<- p.adjust( dFrame$pValuesBatch, method = "BH" )
    ## dFrame$adjustedCage <- p.adjust( dFrame$pValuesCage, method = "BH" )
    ## Try and dynamically generate the name of the plot here...
    write.table(dFrame, file=paste("pValuesForTaxa_bug_treatmentItime_batch_byGroup_", taxa, ".txt",sep=""), sep="\t",row.names=FALSE)

    ## Get the sig table working
    ## It would also be nice to have a sig-picker for the plots and a combination of all sig results into one plot.
    keepVector <- grep("adj", names(dFrame))
    sigdFrame <-dFrame[which(dFrame[,keepVector] < 0.05,arr.ind=TRUE),]
    write.table(sigdFrame, file=paste("pValuesForTaxa_bug_treatmentItime_batch_byGroup_sig_", taxa, ".txt",sep=""), sep="\t",row.names=FALSE)

    dev.off()
}

rm(list=ls())

library("pscl")
library("lmtest")
library("nlme")
library("vegan")

setwd("/Users/mbrown67/Documents/Fodor/Datasets/MarkExperiment/Pooled/")

taxaLevels <- c( "phylum", "class", "order", "family", "genus")

for(taxa in taxaLevels){

    inFileName <- paste( taxa, "LogNormwithMetadata_R1_Pooled.txt", sep ="")
    myT <-read.csv(inFileName,header=TRUE,sep="", na.strings="BLAH")

    numCols <- ncol(myT)
    numMetadataCols <- 20

    ## Reprocessing for correct column data type
    myColClasses <- c("character", rep("numeric", numCols - numMetadataCols - 1), rep("character", 11), "numeric", "numeric", "numeric", "character", "character", "character", "character", "character", "character")
    myT <-read.csv(inFileName, header=TRUE, sep="", colClasses=myColClasses, na.strings="BLAH", comment.char ="@")

    ## Removing unwanted samples {controls, replicates, duplicates, poor quality samples}
    removeControls<-c( "C1", "C2", "N1", "N2", "Neg", "Pos")
    myT<-myT[!(myT$Sample_ID %in% removeControls),]

    removetrs<-c("04_125_tr", "04_101_tr", "04_103_tr", "04_74_tr", "04_70_tr", "04_40_tr", "04_41_tr", "04_84_tr")
    myT<-myT[!(myT$Sample_ID %in% removetrs),]

    removeDups<-c("04-04_S63_L001_R1_001")
    myT<-myT[!(myT$MatchFile %in% removeDups),]

    ## Controls not dropped earlier
    manualDrop <- c("Neg_S40_L001_R1_001", "PCR1Neg_S65_L001_R1_001")
    myT<-myT[!(myT$MatchFile %in% manualDrop),]

    labDrop <- c("Harlan Labs")
    myT<-myT[!(myT$MouseOrigin %in% labDrop),]

    lowSeqDrop <- c("04-55_S32_L001_R1_001")
    myT<-myT[!(myT$MatchFile %in% lowSeqDrop),]
    ## Not sure what to do about this though.
    ### myT$Condition[which(myT$Treatment == "Ctrl", arr.ind = TRUE)]<-"Control"

    names <- vector()
    pValuesSex<- vector()
    pValuesAcuteChronic<- vector()
    pValuesCage<- vector()
    iccCage <- vector()
    iccKeptCounts <- vector()
    pValuesBatch<- vector()
    pValuesTreatment<- vector()
    pValuesTime <- vector()
    pValuesStressLength <- vector()
    pValuesInteraction <- vector()
    allpvals <- list()

    index <- 1
    filePrefix <- "_treatment_time_batch_byGroup_"
    pdf( paste(taxa, filePrefix, "boxplots.pdf", sep=""))

    for( i in 2:(ncol(myT) - numMetadataCols))
        if( sum(myT[,i] != 0 ) > nrow(myT) / 4 ){
            ## Easy access names
            bug <- myT[,i]
            ac <- myT$Condition
            sex <- myT$Sex
            cage <- myT$Cage
            batch <- myT$Sample_Plate
            date <- myT$Date
            mo <- myT$MouseOrigin
            group <- myT$SpreadsheetGrouping
            treatment <- myT$Treatment
            time <- myT$StressLength
            multiWay <- paste(ac, myT$StressLength)
            multiWay[which(myT$Treatment == "Ctrl", arr.ind = TRUE)]<-"Control"
            names[index] = names(myT)[i]
            ## Some kind of vector for the variables of interest
            myFrame <- data.frame(bug, ac, time, multiWay, sex, cage, treatment, batch, date, mo, date)
            mlm<-TRUE
            if(mlm == TRUE){
                fullModel <- gls( bug~   treatment + time + batch, method="REML",correlation=corCompSymm(form=~1|factor(group)),	data = myFrame )
                reducedModel <- gls( bug~ treatment + time + batch, method="REML", data = myFrame )
                fullModelLME <- lme(bug~  treatment + time + batch, method="REML", random = ~1|factor(group), data = myFrame)
            }
            else{
                fullModelLME <- lm(bug~ treatment + time + batch, x=TRUE)
            }
            ## Potential save time by reducing anova calls
            ## Introduce the goodness of fit tests here
            ## Can streamline vectors to be automatically responsive to changes to the model
            allNames <- rownames(anova(fullModelLME))[-1]
            allpvals[[index]] <- anova(fullModelLME)$"p-value"[-1]

            ## Random Effects and Interclass Correlation Coefficient
            if(mlm == TRUE){
                allNames<-c(allNames, "cage", "iccCage")
                allpvals[[index]]<-c(allpvals[[index]], anova(fullModelLME, reducedModel)$"p-value"[2], coef(fullModel$modelStruct[1]$corStruct,unconstrained=FALSE)[[1]])
                pValuesCage[index] <-  anova(fullModelLME, reducedModel)$"p-value"[2]
                ## This is different as it is not corrected for multiple hypothesis testing.
                iccCage[index]<- coef(fullModel$modelStruct[1]$corStruct,unconstrained=FALSE)[[1]]
            }
    ## Nice plotting
            ## Correct so that it uses corrected p-values
            graphMain = c(names[i], paste(c(rep("p-",length(allNames)-1),""), allNames, " = ", format(allpvals[[index]], digits=3), sep=""))

            ## mlm is boolean 1/0 value. Basically, don't graph on icc
            ## need a correction for interaction terms as well
            numPlots <- length(allNames) - mlm
            par(mfrow=c(numPlots, 1),
                oma = c(1,1,0,0) + 0.1,
                mar = c(1,4,3,0) + 0.1)

            for(j in 1:numPlots){
                if(j == 1){
                    plot( bug ~ factor(get(allNames[j])), ylab = names[i], main = c(names[index],toString(graphMain[-1])) )
                    points(factor(get(allNames[j])), bug)
                }
                else{
                    testInteract <- grep(":", allNames)
                    if(length(testInteract) > 0){
                        if(j == testInteract){
                            intSplit <- unlist(strsplit(allNames[grep(":",allNames)],split=":"))
                            plot( bug ~ factor(c( paste( get(intSplit[1]), get(intSplit[2]),sep=""))))
                            points(factor(c( paste( get(intSplit[1]), get(intSplit[2]),sep=""))), bug)
                        }
                    }
                    else{
                        plot( bug ~ factor(get(allNames[j])), ylab = names[i])
                        points(factor(get(allNames[j])), bug)
                    }
                }
            }

            index <- index + 1
	}

    ## This should also be dynamic
    dFrame <- as.data.frame(matrix(unlist(allpvals), nrow= length(allpvals), byrow=TRUE))
    colnames(dFrame) <- unlist(allNames)
    rownames(dFrame) <- names
    orgCol <- ncol(dFrame)

    for(k in 1:(orgCol-1)){
        dFrame[, k + orgCol]<-p.adjust(dFrame[,k], method = "BH")
    }
    colnames(dFrame)[(orgCol + 1):length(dFrame)]<-paste0(rep("adjusted_"),colnames(dFrame)[1:(orgCol - 1)])

    ## Try and dynamically generate the name of the plot here...
    write.table(dFrame, file=paste("pValues", filePrefix, taxa, ".txt",sep=""), sep="\t",row.names=FALSE)

    ## Get the sig table working
    ## It would also be nice to have a sig-picker for the plots and a combination of all sig results into one plot.
    keepVector <- grep("adj", names(dFrame))
    sigdFrame <-dFrame[which(dFrame[,keepVector] < 0.05,arr.ind=TRUE),]
    write.table(sigdFrame, file=paste("SIGpValues", filePrefix, taxa, ".txt",sep=""), sep="\t",row.names=FALSE)

    dev.off()
}

treatment
rm(list=ls())

library("pscl")
library("lmtest")
library("nlme")
library("vegan")

setwd("/Users/mbrown67/Documents/Fodor/Datasets/MarkExperiment/Pooled/")

taxaLevels <- c( "phylum", "class", "order", "family", "genus")

for(taxa in taxaLevels){

    inFileName <- paste( taxa, "LogNormwithMetadata_R1_Pooled.txt", sep ="")
    myT <-read.csv(inFileName,header=TRUE,sep="", na.strings="BLAH")

    numCols <- ncol(myT)
    numMetadataCols <- 20

    ## Reprocessing for correct column data type
    myColClasses <- c("character", rep("numeric", numCols - numMetadataCols - 1), rep("character", 11), "numeric", "numeric", "numeric", "character", "character", "character", "character", "character", "character")
    myT <-read.csv(inFileName, header=TRUE, sep="", colClasses=myColClasses, na.strings="BLAH", comment.char ="@")

    ## Removing unwanted samples {controls, replicates, duplicates, poor quality samples}
    removeControls<-c( "C1", "C2", "N1", "N2", "Neg", "Pos")
    myT<-myT[!(myT$Sample_ID %in% removeControls),]

    removetrs<-c("04_125_tr", "04_101_tr", "04_103_tr", "04_74_tr", "04_70_tr", "04_40_tr", "04_41_tr", "04_84_tr")
    myT<-myT[!(myT$Sample_ID %in% removetrs),]

    removeDups<-c("04-04_S63_L001_R1_001")
    myT<-myT[!(myT$MatchFile %in% removeDups),]

    ## Controls not dropped earlier
    manualDrop <- c("Neg_S40_L001_R1_001", "PCR1Neg_S65_L001_R1_001")
    myT<-myT[!(myT$MatchFile %in% manualDrop),]

    labDrop <- c("Harlan Labs")
    myT<-myT[!(myT$MouseOrigin %in% labDrop),]

    lowSeqDrop <- c("04-55_S32_L001_R1_001")
    myT<-myT[!(myT$MatchFile %in% lowSeqDrop),]
    ## Not sure what to do about this though.
    ### myT$Condition[which(myT$Treatment == "Ctrl", arr.ind = TRUE)]<-"Control"

    names <- vector()
    pValuesSex<- vector()
    pValuesAcuteChronic<- vector()
    pValuesCage<- vector()
    iccCage <- vector()
    iccKeptCounts <- vector()
    pValuesBatch<- vector()
    pValuesTreatment<- vector()
    pValuesTime <- vector()
    pValuesStressLength <- vector()
    pValuesInteraction <- vector()
    allpvals <- list()

    index <- 1
    filePrefix <- "_time_batch_byGroup_"
    pdf( paste(taxa, filePrefix, "boxplots.pdf", sep=""))

    for( i in 2:(ncol(myT) - numMetadataCols))
        if( sum(myT[,i] != 0 ) > nrow(myT) / 4 ){
            ## Easy access names
            bug <- myT[,i]
            ac <- myT$Condition
            sex <- myT$Sex
            cage <- myT$Cage
            batch <- myT$Sample_Plate
            date <- myT$Date
            mo <- myT$MouseOrigin
            group <- myT$SpreadsheetGrouping
            treatment <- myT$Treatment
            time <- myT$StressLength
            multiWay <- paste(ac, myT$StressLength)
            multiWay[which(myT$Treatment == "Ctrl", arr.ind = TRUE)]<-"Control"
            names[index] = names(myT)[i]
            ## Some kind of vector for the variables of interest
            myFrame <- data.frame(bug, ac, time, multiWay, sex, cage, treatment, batch, date, mo, date)
            mlm<-TRUE
            if(mlm == TRUE){
                fullModel <- gls( bug~ time + batch, method="REML",correlation=corCompSymm(form=~1|factor(group)),	data = myFrame )
                reducedModel <- gls( bug~ time + batch, method="REML", data = myFrame )
                fullModelLME <- lme(bug~ time + batch, method="REML", random = ~1|factor(group), data = myFrame)
            }
            else{
                fullModelLME <- lm(bug~ time + batch, x=TRUE)
            }
            ## Potential save time by reducing anova calls
            ## Introduce the goodness of fit tests here
            ## Can streamline vectors to be automatically responsive to changes to the model
            allNames <- rownames(anova(fullModelLME))[-1]
            allpvals[[index]] <- anova(fullModelLME)$"p-value"[-1]

            ## Random Effects and Interclass Correlation Coefficient
            if(mlm == TRUE){
                allNames<-c(allNames, "cage", "iccCage")
                allpvals[[index]]<-c(allpvals[[index]], anova(fullModelLME, reducedModel)$"p-value"[2], coef(fullModel$modelStruct[1]$corStruct,unconstrained=FALSE)[[1]])
                pValuesCage[index] <-  anova(fullModelLME, reducedModel)$"p-value"[2]
                ## This is different as it is not corrected for multiple hypothesis testing.
                iccCage[index]<- coef(fullModel$modelStruct[1]$corStruct,unconstrained=FALSE)[[1]]
            }
    ## Nice plotting
            ## Correct so that it uses corrected p-values
            graphMain = c(names[i], paste(c(rep("p-",length(allNames)-1),""), allNames, " = ", format(allpvals[[index]], digits=3), sep=""))

            ## mlm is boolean 1/0 value. Basically, don't graph on icc
            ## need a correction for interaction terms as well
            numPlots <- length(allNames) - mlm
            par(mfrow=c(numPlots, 1),
                oma = c(1,1,0,0) + 0.1,
                mar = c(1,4,3,0) + 0.1)

            for(j in 1:numPlots){
                if(j == 1){
                    plot( bug ~ factor(get(allNames[j])), ylab = names[i], main = c(names[index],toString(graphMain[-1])) )
                    points(factor(get(allNames[j])), bug)
                }
                else{
                    testInteract <- grep(":", allNames)
                    if(length(testInteract) > 0){
                        if(j == testInteract){
                            intSplit <- unlist(strsplit(allNames[grep(":",allNames)],split=":"))
                            plot( bug ~ factor(c( paste( get(intSplit[1]), get(intSplit[2]),sep=""))))
                            points(factor(c( paste( get(intSplit[1]), get(intSplit[2]),sep=""))), bug)
                        }
                    }
                    else{
                        plot( bug ~ factor(get(allNames[j])), ylab = names[i])
                        points(factor(get(allNames[j])), bug)
                    }
                }
            }

            index <- index + 1
	}

    ## This should also be dynamic
    dFrame <- as.data.frame(matrix(unlist(allpvals), nrow= length(allpvals), byrow=TRUE))
    colnames(dFrame) <- unlist(allNames)
    rownames(dFrame) <- names
    orgCol <- ncol(dFrame)

    for(k in 1:(orgCol-1)){
        dFrame[, k + orgCol]<-p.adjust(dFrame[,k], method = "BH")
    }
    colnames(dFrame)[(orgCol + 1):length(dFrame)]<-paste0(rep("adjusted_"),colnames(dFrame)[1:(orgCol - 1)])

    ## Try and dynamically generate the name of the plot here...
    write.table(dFrame, file=paste("pValues", filePrefix, taxa, ".txt",sep=""), sep="\t",row.names=FALSE)

    ## Get the sig table working
    ## It would also be nice to have a sig-picker for the plots and a combination of all sig results into one plot.
    keepVector <- grep("adj", names(dFrame))
    sigdFrame <-dFrame[which(dFrame[,keepVector] < 0.05,arr.ind=TRUE),]
    write.table(sigdFrame, file=paste("SIGpValues", filePrefix, taxa, ".txt",sep=""), sep="\t",row.names=FALSE)

    dev.off()
}

rm(list=ls())

library("pscl")
library("lmtest")
library("nlme")
library("vegan")

setwd("/Users/mbrown67/Documents/Fodor/Datasets/MarkExperiment/Pooled/")

taxaLevels <- c( "phylum", "class", "order", "family", "genus")

filePrefix <- "_time_batch_"
mlm<-FALSE


for(taxa in taxaLevels){

    inFileName <- paste( taxa, "LogNormwithMetadata_R1_Pooled.txt", sep ="")
    myT <-read.csv(inFileName,header=TRUE,sep="", na.strings="BLAH")

    numCols <- ncol(myT)
    numMetadataCols <- 20

    ## Reprocessing for correct column data type
    myColClasses <- c("character", rep("numeric", numCols - numMetadataCols - 1), rep("character", 11), "numeric", "numeric", "numeric", "character", "character", "character", "character", "character", "character")
    myT <-read.csv(inFileName, header=TRUE, sep="", colClasses=myColClasses, na.strings="BLAH", comment.char ="@")

    ## Removing unwanted samples {controls, replicates, duplicates, poor quality samples}
    removeControls<-c( "C1", "C2", "N1", "N2", "Neg", "Pos")
    myT<-myT[!(myT$Sample_ID %in% removeControls),]

    removetrs<-c("04_125_tr", "04_101_tr", "04_103_tr", "04_74_tr", "04_70_tr", "04_40_tr", "04_41_tr", "04_84_tr")
    myT<-myT[!(myT$Sample_ID %in% removetrs),]

    removeDups<-c("04-04_S63_L001_R1_001")
    myT<-myT[!(myT$MatchFile %in% removeDups),]

    ## Controls not dropped earlier
    manualDrop <- c("Neg_S40_L001_R1_001", "PCR1Neg_S65_L001_R1_001")
    myT<-myT[!(myT$MatchFile %in% manualDrop),]

    labDrop <- c("Harlan Labs")
    myT<-myT[!(myT$MouseOrigin %in% labDrop),]

    lowSeqDrop <- c("04-55_S32_L001_R1_001")
    myT<-myT[!(myT$MatchFile %in% lowSeqDrop),]
    ## Not sure what to do about this though.
    ### myT$Condition[which(myT$Treatment == "Ctrl", arr.ind = TRUE)]<-"Control"

    names <- vector()
    pValuesSex<- vector()
    pValuesAcuteChronic<- vector()
    pValuesCage<- vector()
    iccCage <- vector()
    iccKeptCounts <- vector()
    pValuesBatch<- vector()
    pValuesTreatment<- vector()
    pValuesTime <- vector()
    pValuesStressLength <- vector()
    pValuesInteraction <- vector()
    allpvals <- list()

    index <- 1
    pdf( paste(taxa, filePrefix, "boxplots.pdf", sep=""))

    for( i in 2:(ncol(myT) - numMetadataCols))
        if( sum(myT[,i] != 0 ) > nrow(myT) / 4 ){
            ## Easy access names
            bug <- myT[,i]
            ac <- myT$Condition
            sex <- myT$Sex
            cage <- myT$Cage
            batch <- myT$Sample_Plate
            date <- myT$Date
            mo <- myT$MouseOrigin
            group <- myT$SpreadsheetGrouping
            treatment <- myT$Treatment
            time <- myT$StressLength
            multiWay <- paste(ac, myT$StressLength)
            multiWay[which(myT$Treatment == "Ctrl", arr.ind = TRUE)]<-"Control"
            names[index] = names(myT)[i]
            ## Some kind of vector for the variables of interest
            myFrame <- data.frame(bug, ac, time, multiWay, sex, cage, treatment, batch, date, mo, date)
            if(mlm == TRUE){
                fullModel <- gls( bug~ treatment*time + batch, method="REML",correlation=corCompSymm(form=~1|factor(group)),	data = myFrame )
                reducedModel <- gls( bug~ treatment*time + batch, method="REML", data = myFrame )
                fullModelLME <- lme(bug~ treatment*time + batch, method="REML", random = ~1|factor(group), data = myFrame)
            }
            else{
                fullModelLME <- lm(bug~ treatment*time + batch, x=TRUE)
            }
            ## Potential save time by reducing anova calls
            ## Introduce the goodness of fit tests here
            ## Can streamline vectors to be automatically responsive to changes to the model
            allNames <- rownames(anova(fullModelLME))[-1]
            allpvals[[index]] <- anova(fullModelLME)$"p-value"[-1]

            ## Random Effects and Interclass Correlation Coefficient
            if(mlm == TRUE){
                allNames<-c(allNames, "cage", "iccCage")
                allpvals[[index]]<-c(allpvals[[index]], anova(fullModelLME, reducedModel)$"p-value"[2], coef(fullModel$modelStruct[1]$corStruct,unconstrained=FALSE)[[1]])
                pValuesCage[index] <-  anova(fullModelLME, reducedModel)$"p-value"[2]
                ## This is different as it is not corrected for multiple hypothesis testing.
                iccCage[index]<- coef(fullModel$modelStruct[1]$corStruct,unconstrained=FALSE)[[1]]
            }
    ## Nice plotting
            ## Correct so that it uses corrected p-values
            graphMain = c(names[i], paste(c(rep("p-",length(allNames)-1),""), allNames, " = ", format(allpvals[[index]], digits=3), sep=""))

            ## mlm is boolean 1/0 value. Basically, don't graph on icc
            ## need a correction for interaction terms as well
            numPlots <- length(allNames) - mlm
            par(mfrow=c(numPlots, 1),
                oma = c(1,1,0,0) + 0.1,
                mar = c(1,4,3,0) + 0.1)

            for(j in 1:numPlots){
                if(j == 1){
                    plot( bug ~ factor(get(allNames[j])), ylab = names[i], main = c(names[index],toString(graphMain[-1])) )
                    points(factor(get(allNames[j])), bug)
                }
                else{
                    testInteract <- grep(":", allNames)
                    if(length(testInteract) > 0){
                        if(j == testInteract){
                            intSplit <- unlist(strsplit(allNames[grep(":",allNames)],split=":"))
                            plot( bug ~ factor(c( paste( get(intSplit[1]), get(intSplit[2]),sep=""))))
                            points(factor(c( paste( get(intSplit[1]), get(intSplit[2]),sep=""))), bug)
                        }
                    }
                    else{
                        plot( bug ~ factor(get(allNames[j])), ylab = names[i])
                        points(factor(get(allNames[j])), bug)
                    }
                }
            }

            index <- index + 1
	}

    ## This should also be dynamic
    dFrame <- as.data.frame(matrix(unlist(allpvals), nrow= length(allpvals), byrow=TRUE))
    colnames(dFrame) <- unlist(allNames)
    rownames(dFrame) <- names
    orgCol <- ncol(dFrame)

    for(k in 1:(orgCol-1)){
        dFrame[, k + orgCol]<-p.adjust(dFrame[,k], method = "BH")
    }
    colnames(dFrame)[(orgCol + 1):length(dFrame)]<-paste0(rep("adjusted_"),colnames(dFrame)[1:(orgCol - 1)])

    ## Try and dynamically generate the name of the plot here...
    write.table(dFrame, file=paste("pValues", filePrefix, taxa, ".txt",sep=""), sep="\t",row.names=FALSE)

    ## Get the sig table working
    ## It would also be nice to have a sig-picker for the plots and a combination of all sig results into one plot.
    keepVector <- grep("adj", names(dFrame))
    sigdFrame <-dFrame[which(dFrame[,keepVector] < 0.05,arr.ind=TRUE),]
    write.table(sigdFrame, file=paste("SIGpValues", filePrefix, taxa, ".txt",sep=""), sep="\t",row.names=FALSE)

    dev.off()
}

rm(list=ls())

library("pscl")
library("lmtest")
library("nlme")
library("vegan")

setwd("/Users/mbrown67/Documents/Fodor/Datasets/MarkExperiment/Pooled/")

taxaLevels <- c( "phylum", "class", "order", "family", "genus")

filePrefix <- "_time_batch_"
mlm<-FALSE


for(taxa in taxaLevels){

    inFileName <- paste( taxa, "LogNormwithMetadata_R1_Pooled.txt", sep ="")
    myT <-read.csv(inFileName,header=TRUE,sep="", na.strings="BLAH")

    numCols <- ncol(myT)
    numMetadataCols <- 20

    ## Reprocessing for correct column data type
    myColClasses <- c("character", rep("numeric", numCols - numMetadataCols - 1), rep("character", 11), "numeric", "numeric", "numeric", "character", "character", "character", "character", "character", "character")
    myT <-read.csv(inFileName, header=TRUE, sep="", colClasses=myColClasses, na.strings="BLAH", comment.char ="@")

    ## Removing unwanted samples {controls, replicates, duplicates, poor quality samples}
    removeControls<-c( "C1", "C2", "N1", "N2", "Neg", "Pos")
    myT<-myT[!(myT$Sample_ID %in% removeControls),]

    removetrs<-c("04_125_tr", "04_101_tr", "04_103_tr", "04_74_tr", "04_70_tr", "04_40_tr", "04_41_tr", "04_84_tr")
    myT<-myT[!(myT$Sample_ID %in% removetrs),]

    removeDups<-c("04-04_S63_L001_R1_001")
    myT<-myT[!(myT$MatchFile %in% removeDups),]

    ## Controls not dropped earlier
    manualDrop <- c("Neg_S40_L001_R1_001", "PCR1Neg_S65_L001_R1_001")
    myT<-myT[!(myT$MatchFile %in% manualDrop),]

    labDrop <- c("Harlan Labs")
    myT<-myT[!(myT$MouseOrigin %in% labDrop),]

    lowSeqDrop <- c("04-55_S32_L001_R1_001")
    myT<-myT[!(myT$MatchFile %in% lowSeqDrop),]
    ## Not sure what to do about this though.
    ### myT$Condition[which(myT$Treatment == "Ctrl", arr.ind = TRUE)]<-"Control"

    names <- vector()
    pValuesSex<- vector()
    pValuesAcuteChronic<- vector()
    pValuesCage<- vector()
    iccCage <- vector()
    iccKeptCounts <- vector()
    pValuesBatch<- vector()
    pValuesTreatment<- vector()
    pValuesTime <- vector()
    pValuesStressLength <- vector()
    pValuesInteraction <- vector()
    allpvals <- list()

    index <- 1
    pdf( paste(taxa, filePrefix, "boxplots.pdf", sep=""))

    for( i in 2:(ncol(myT) - numMetadataCols))
        if( sum(myT[,i] != 0 ) > nrow(myT) / 4 ){
            ## Easy access names
            bug <- myT[,i]
            ac <- myT$Condition
            sex <- myT$Sex
            cage <- myT$Cage
            batch <- myT$Sample_Plate
            date <- myT$Date
            mo <- myT$MouseOrigin
            group <- myT$SpreadsheetGrouping
            treatment <- myT$Treatment
            time <- myT$StressLength
            multiWay <- paste(ac, myT$StressLength)
            multiWay[which(myT$Treatment == "Ctrl", arr.ind = TRUE)]<-"Control"
            names[index] = names(myT)[i]
            ## Some kind of vector for the variables of interest
            myFrame <- data.frame(bug, ac, time, multiWay, sex, cage, treatment, batch, date, mo, date)
            if(mlm == TRUE){
                fullModel <- gls( bug~ treatment*time + batch, method="REML",correlation=corCompSymm(form=~1|factor(group)),	data = myFrame )
                reducedModel <- gls( bug~ treatment*time + batch, method="REML", data = myFrame )
                fullModelLME <- lme(bug~ treatment*time + batch, method="REML", random = ~1|factor(group), data = myFrame)
            }
            else{
                fullModelLME <- lm(bug~ treatment*time + batch, x=TRUE)
            }
            ## Potential save time by reducing anova calls
            ## Introduce the goodness of fit tests here
            ## Can streamline vectors to be automatically responsive to changes to the model
            allNames <- rownames(anova(fullModelLME))[-1]
            allpvals[[index]] <- anova(fullModelLME)$"p-value"[-1]

            ## Random Effects and Interclass Correlation Coefficient
            if(mlm == TRUE){
                allNames<-c(allNames, "cage", "iccCage")
                allpvals[[index]]<-c(allpvals[[index]], anova(fullModelLME, reducedModel)$"p-value"[2], coef(fullModel$modelStruct[1]$corStruct,unconstrained=FALSE)[[1]])
                pValuesCage[index] <-  anova(fullModelLME, reducedModel)$"p-value"[2]
                ## This is different as it is not corrected for multiple hypothesis testing.
                iccCage[index]<- coef(fullModel$modelStruct[1]$corStruct,unconstrained=FALSE)[[1]]
            }
    ## Nice plotting
            ## Correct so that it uses corrected p-values
            if(mlm == TRUE){
                graphMain = c(names[i], paste(c(rep("p-",length(allNames)-1),""), allNames, " = ", format(allpvals[[index]], digits=3), sep=""))
            }
            else {
                graphMain = c(names[i], paste(c(rep("p-",length(allNames)),""), allNames, " = ", format(allpvals[[index]], digits=3), sep=""))

            }

            ## mlm is boolean 1/0 value. Basically, don't graph on icc
            ## need a correction for interaction terms as well
            numPlots <- length(allNames) - mlm
            par(mfrow=c(numPlots, 1),
                oma = c(1,1,0,0) + 0.1,
                mar = c(1,4,3,0) + 0.1)

            for(j in 1:numPlots){
                if(j == 1){
                    plot( bug ~ factor(get(allNames[j])), ylab = names[i], main = c(names[index],toString(graphMain[-1])) )
                    points(factor(get(allNames[j])), bug)
                }
                else{
                    testInteract <- grep(":", allNames)
                    if(length(testInteract) > 0){
                        if(j == testInteract){
                            intSplit <- unlist(strsplit(allNames[grep(":",allNames)],split=":"))
                            plot( bug ~ factor(c( paste( get(intSplit[1]), get(intSplit[2]),sep=""))))
                            points(factor(c( paste( get(intSplit[1]), get(intSplit[2]),sep=""))), bug)
                        }
                    }
                    else{
                        plot( bug ~ factor(get(allNames[j])), ylab = names[i])
                        points(factor(get(allNames[j])), bug)
                    }
                }
            }

            index <- index + 1
	}

    ## This should also be dynamic
    dFrame <- as.data.frame(matrix(unlist(allpvals), nrow= length(allpvals), byrow=TRUE))
    colnames(dFrame) <- unlist(allNames)
    rownames(dFrame) <- names
    orgCol <- ncol(dFrame)

    for(k in 1:(orgCol-mlm)){
        dFrame[, k + orgCol]<-p.adjust(dFrame[,k], method = "BH")
    }
    colnames(dFrame)[(orgCol + 1):length(dFrame)]<-paste0(rep("adjusted_"),colnames(dFrame)[1:(orgCol - mlm)])

    ## Try and dynamically generate the name of the plot here...
    write.table(dFrame, file=paste("pValues", filePrefix, taxa, ".txt",sep=""), sep="\t",row.names=FALSE)

    ## Get the sig table working
    ## It would also be nice to have a sig-picker for the plots and a combination of all sig results into one plot.
    keepVector <- grep("adj", names(dFrame))
    sigdFrame <-dFrame[which(dFrame[,keepVector] < 0.05,arr.ind=TRUE),]
    write.table(sigdFrame, file=paste("SIGpValues", filePrefix, taxa, ".txt",sep=""), sep="\t",row.names=FALSE)

    dev.off()
}

length(allpvals)
anova(fullModelLME)
dim(anova(fullModelLME))
as.data.frame(anova(fullModelLME))[,5]
length(anova(fullModelLME))
length(fullModelLME)
as.data.frame(anova(fullModelLME))[1:length(anova(fullModelLME)),5]
as.data.frame(anova(fullModelLME))[1:length(anova(fullModelLME)-1),5]
as.data.frame(anova(fullModelLME))[1:length(anova(fullModelLME)1-1),5]
as.data.frame(anova(fullModelLME))[1:length(anova(fullModelLME)-1),5]
as.data.frame(anova(fullModelLME))[1:length(anova(fullModelLME))-1,5]
rm(list=ls())

library("pscl")
library("lmtest")
library("nlme")
library("vegan")

setwd("/Users/mbrown67/Documents/Fodor/Datasets/MarkExperiment/Pooled/")

taxaLevels <- c( "phylum", "class", "order", "family", "genus")

filePrefix <- "_time_batch_"
mlm<-FALSE


for(taxa in taxaLevels){

    inFileName <- paste( taxa, "LogNormwithMetadata_R1_Pooled.txt", sep ="")
    myT <-read.csv(inFileName,header=TRUE,sep="", na.strings="BLAH")

    numCols <- ncol(myT)
    numMetadataCols <- 20

    ## Reprocessing for correct column data type
    myColClasses <- c("character", rep("numeric", numCols - numMetadataCols - 1), rep("character", 11), "numeric", "numeric", "numeric", "character", "character", "character", "character", "character", "character")
    myT <-read.csv(inFileName, header=TRUE, sep="", colClasses=myColClasses, na.strings="BLAH", comment.char ="@")

    ## Removing unwanted samples {controls, replicates, duplicates, poor quality samples}
    removeControls<-c( "C1", "C2", "N1", "N2", "Neg", "Pos")
    myT<-myT[!(myT$Sample_ID %in% removeControls),]

    removetrs<-c("04_125_tr", "04_101_tr", "04_103_tr", "04_74_tr", "04_70_tr", "04_40_tr", "04_41_tr", "04_84_tr")
    myT<-myT[!(myT$Sample_ID %in% removetrs),]

    removeDups<-c("04-04_S63_L001_R1_001")
    myT<-myT[!(myT$MatchFile %in% removeDups),]

    ## Controls not dropped earlier
    manualDrop <- c("Neg_S40_L001_R1_001", "PCR1Neg_S65_L001_R1_001")
    myT<-myT[!(myT$MatchFile %in% manualDrop),]

    labDrop <- c("Harlan Labs")
    myT<-myT[!(myT$MouseOrigin %in% labDrop),]

    lowSeqDrop <- c("04-55_S32_L001_R1_001")
    myT<-myT[!(myT$MatchFile %in% lowSeqDrop),]
    ## Not sure what to do about this though.
    ### myT$Condition[which(myT$Treatment == "Ctrl", arr.ind = TRUE)]<-"Control"

    names <- vector()
    pValuesSex<- vector()
    pValuesAcuteChronic<- vector()
    pValuesCage<- vector()
    iccCage <- vector()
    iccKeptCounts <- vector()
    pValuesBatch<- vector()
    pValuesTreatment<- vector()
    pValuesTime <- vector()
    pValuesStressLength <- vector()
    pValuesInteraction <- vector()
    allpvals <- list()

    index <- 1
    pdf( paste(taxa, filePrefix, "boxplots.pdf", sep=""))

    for( i in 2:(ncol(myT) - numMetadataCols))
        if( sum(myT[,i] != 0 ) > nrow(myT) / 4 ){
            ## Easy access names
            bug <- myT[,i]
            ac <- myT$Condition
            sex <- myT$Sex
            cage <- myT$Cage
            batch <- myT$Sample_Plate
            date <- myT$Date
            mo <- myT$MouseOrigin
            group <- myT$SpreadsheetGrouping
            treatment <- myT$Treatment
            time <- myT$StressLength
            multiWay <- paste(ac, myT$StressLength)
            multiWay[which(myT$Treatment == "Ctrl", arr.ind = TRUE)]<-"Control"
            names[index] = names(myT)[i]
            ## Some kind of vector for the variables of interest
            myFrame <- data.frame(bug, ac, time, multiWay, sex, cage, treatment, batch, date, mo, date)
            if(mlm == TRUE){
                fullModel <- gls( bug~ treatment*time + batch, method="REML",correlation=corCompSymm(form=~1|factor(group)),	data = myFrame )
                reducedModel <- gls( bug~ treatment*time + batch, method="REML", data = myFrame )
                fullModelLME <- lme(bug~ treatment*time + batch, method="REML", random = ~1|factor(group), data = myFrame)
            }
            else{
                fullModelLME <- lm(bug~ treatment*time + batch, x=TRUE)
            }
            ## Potential save time by reducing anova calls
            ## Introduce the goodness of fit tests here
            ## Can streamline vectors to be automatically responsive to changes to the model
            allNames <- rownames(anova(fullModelLME))[-1]
           allpvals[[index]]<-as.data.frame(anova(fullModelLME))[1:length(anova(fullModelLME))-1,5]
            ##            allpvals[[index]] <- as.data.frame(anova(fullModelLME))[,5$"p-value"[-1]

            ## Random Effects and Interclass Correlation Coefficient
            if(mlm == TRUE){
                allNames<-c(allNames, "cage", "iccCage")
                allpvals[[index]]<-c(allpvals[[index]], anova(fullModelLME, reducedModel)$"p-value"[2], coef(fullModel$modelStruct[1]$corStruct,unconstrained=FALSE)[[1]])
                pValuesCage[index] <-  anova(fullModelLME, reducedModel)$"p-value"[2]
                ## This is different as it is not corrected for multiple hypothesis testing.
                iccCage[index]<- coef(fullModel$modelStruct[1]$corStruct,unconstrained=FALSE)[[1]]
            }
    ## Nice plotting
            ## Correct so that it uses corrected p-values
            if(mlm == TRUE){
                graphMain = c(names[i], paste(c(rep("p-",length(allNames)-1),""), allNames, " = ", format(allpvals[[index]], digits=3), sep=""))
            }
            else {
                graphMain = c(names[i], paste(c(rep("p-",length(allNames)),""), allNames, " = ", format(allpvals[[index]], digits=3), sep=""))

            }

            ## mlm is boolean 1/0 value. Basically, don't graph on icc
            ## need a correction for interaction terms as well
            numPlots <- length(allNames) - mlm
            par(mfrow=c(numPlots, 1),
                oma = c(1,1,0,0) + 0.1,
                mar = c(1,4,3,0) + 0.1)

            for(j in 1:numPlots){
                if(j == 1){
                    plot( bug ~ factor(get(allNames[j])), ylab = names[i], main = c(names[index],toString(graphMain[-1])) )
                    points(factor(get(allNames[j])), bug)
                }
                else{
                    testInteract <- grep(":", allNames)
                    if(length(testInteract) > 0){
                        if(j == testInteract){
                            intSplit <- unlist(strsplit(allNames[grep(":",allNames)],split=":"))
                            plot( bug ~ factor(c( paste( get(intSplit[1]), get(intSplit[2]),sep=""))))
                            points(factor(c( paste( get(intSplit[1]), get(intSplit[2]),sep=""))), bug)
                        }
                    }
                    else{
                        plot( bug ~ factor(get(allNames[j])), ylab = names[i])
                        points(factor(get(allNames[j])), bug)
                    }
                }
            }

            index <- index + 1
	}

    ## This should also be dynamic
    dFrame <- as.data.frame(matrix(unlist(allpvals), nrow= length(allpvals), byrow=TRUE))
    colnames(dFrame) <- unlist(allNames)
    rownames(dFrame) <- names
    orgCol <- ncol(dFrame)

    for(k in 1:(orgCol-mlm)){
        dFrame[, k + orgCol]<-p.adjust(dFrame[,k], method = "BH")
    }
    colnames(dFrame)[(orgCol + 1):length(dFrame)]<-paste0(rep("adjusted_"),colnames(dFrame)[1:(orgCol - mlm)])

    ## Try and dynamically generate the name of the plot here...
    write.table(dFrame, file=paste("pValues", filePrefix, taxa, ".txt",sep=""), sep="\t",row.names=FALSE)

    ## Get the sig table working
    ## It would also be nice to have a sig-picker for the plots and a combination of all sig results into one plot.
    keepVector <- grep("adj", names(dFrame))
    sigdFrame <-dFrame[which(dFrame[,keepVector] < 0.05,arr.ind=TRUE),]
    write.table(sigdFrame, file=paste("SIGpValues", filePrefix, taxa, ".txt",sep=""), sep="\t",row.names=FALSE)

    dev.off()
}

dFrame
colnames(dFrame
)
anova(fullModelLME)
rownames(anova(fullModelLME))
length(anova(fullModelLME))
rm(list=ls())

library("pscl")
library("lmtest")
library("nlme")
library("vegan")

setwd("/Users/mbrown67/Documents/Fodor/Datasets/MarkExperiment/Pooled/")

taxaLevels <- c( "phylum", "class", "order", "family", "genus")

filePrefix <- "_treatmentItime_batch_"
mlm<-FALSE


for(taxa in taxaLevels){

    inFileName <- paste( taxa, "LogNormwithMetadata_R1_Pooled.txt", sep ="")
    myT <-read.csv(inFileName,header=TRUE,sep="", na.strings="BLAH")

    numCols <- ncol(myT)
    numMetadataCols <- 20

    ## Reprocessing for correct column data type
    myColClasses <- c("character", rep("numeric", numCols - numMetadataCols - 1), rep("character", 11), "numeric", "numeric", "numeric", "character", "character", "character", "character", "character", "character")
    myT <-read.csv(inFileName, header=TRUE, sep="", colClasses=myColClasses, na.strings="BLAH", comment.char ="@")

    ## Removing unwanted samples {controls, replicates, duplicates, poor quality samples}
    removeControls<-c( "C1", "C2", "N1", "N2", "Neg", "Pos")
    myT<-myT[!(myT$Sample_ID %in% removeControls),]

    removetrs<-c("04_125_tr", "04_101_tr", "04_103_tr", "04_74_tr", "04_70_tr", "04_40_tr", "04_41_tr", "04_84_tr")
    myT<-myT[!(myT$Sample_ID %in% removetrs),]

    removeDups<-c("04-04_S63_L001_R1_001")
    myT<-myT[!(myT$MatchFile %in% removeDups),]

    ## Controls not dropped earlier
    manualDrop <- c("Neg_S40_L001_R1_001", "PCR1Neg_S65_L001_R1_001")
    myT<-myT[!(myT$MatchFile %in% manualDrop),]

    labDrop <- c("Harlan Labs")
    myT<-myT[!(myT$MouseOrigin %in% labDrop),]

    lowSeqDrop <- c("04-55_S32_L001_R1_001")
    myT<-myT[!(myT$MatchFile %in% lowSeqDrop),]
    ## Not sure what to do about this though.
    ### myT$Condition[which(myT$Treatment == "Ctrl", arr.ind = TRUE)]<-"Control"

    names <- vector()
    pValuesSex<- vector()
    pValuesAcuteChronic<- vector()
    pValuesCage<- vector()
    iccCage <- vector()
    iccKeptCounts <- vector()
    pValuesBatch<- vector()
    pValuesTreatment<- vector()
    pValuesTime <- vector()
    pValuesStressLength <- vector()
    pValuesInteraction <- vector()
    allpvals <- list()

    index <- 1
    pdf( paste(taxa, filePrefix, "boxplots.pdf", sep=""))

    for( i in 2:(ncol(myT) - numMetadataCols))
        if( sum(myT[,i] != 0 ) > nrow(myT) / 4 ){
            ## Easy access names
            bug <- myT[,i]
            ac <- myT$Condition
            sex <- myT$Sex
            cage <- myT$Cage
            batch <- myT$Sample_Plate
            date <- myT$Date
            mo <- myT$MouseOrigin
            group <- myT$SpreadsheetGrouping
            treatment <- myT$Treatment
            time <- myT$StressLength
            multiWay <- paste(ac, myT$StressLength)
            multiWay[which(myT$Treatment == "Ctrl", arr.ind = TRUE)]<-"Control"
            names[index] = names(myT)[i]
            ## Some kind of vector for the variables of interest
            myFrame <- data.frame(bug, ac, time, multiWay, sex, cage, treatment, batch, date, mo, date)
            if(mlm == TRUE){
                fullModel <- gls( bug~ treatment*time + batch, method="REML",correlation=corCompSymm(form=~1|factor(group)),	data = myFrame )
                reducedModel <- gls( bug~ treatment*time + batch, method="REML", data = myFrame )
                fullModelLME <- lme(bug~ treatment*time + batch, method="REML", random = ~1|factor(group), data = myFrame)
            }
            else{
                fullModelLME <- lm(bug~ treatment*time + batch, x=TRUE)
            }
            ## Potential save time by reducing anova calls
            ## Introduce the goodness of fit tests here
            ## Can streamline vectors to be automatically responsive to changes to the model
            if(mlm == TRUE){
                allNames <- rownames(anova(fullModelLME))[-1]
                allpvals[[index]] <- anova(fullModelLME)$"p-value"[-1]
            }
            else {
                allNames <- rownames(anova(fullModelLME))[-length(anova(fullModelLME))]
                allpvals[[index]]<-as.data.frame(anova(fullModelLME))[1:length(anova(fullModelLME))-1,5]
            }

            ## Random Effects and Interclass Correlation Coefficient
            if(mlm == TRUE){
                allNames<-c(allNames, "cage", "iccCage")
                allpvals[[index]]<-c(allpvals[[index]], anova(fullModelLME, reducedModel)$"p-value"[2], coef(fullModel$modelStruct[1]$corStruct,unconstrained=FALSE)[[1]])
                pValuesCage[index] <-  anova(fullModelLME, reducedModel)$"p-value"[2]
                ## This is different as it is not corrected for multiple hypothesis testing.
                iccCage[index]<- coef(fullModel$modelStruct[1]$corStruct,unconstrained=FALSE)[[1]]
            }
    ## Nice plotting
            ## Correct so that it uses corrected p-values
            if(mlm == TRUE){
                graphMain = c(names[i], paste(c(rep("p-",length(allNames)-1),""), allNames, " = ", format(allpvals[[index]], digits=3), sep=""))
            }
            else {
                graphMain = c(names[i], paste(c(rep("p-",length(allNames)),""), allNames, " = ", format(allpvals[[index]], digits=3), sep=""))

            }

            ## mlm is boolean 1/0 value. Basically, don't graph on icc
            ## need a correction for interaction terms as well
            numPlots <- length(allNames) - mlm
            par(mfrow=c(numPlots, 1),
                oma = c(1,1,0,0) + 0.1,
                mar = c(1,4,3,0) + 0.1)

            for(j in 1:numPlots){
                if(j == 1){
                    plot( bug ~ factor(get(allNames[j])), ylab = names[i], main = c(names[index],toString(graphMain[-1])) )
                    points(factor(get(allNames[j])), bug)
                }
                else{
                    testInteract <- grep(":", allNames)
                    if(length(testInteract) > 0){
                        if(j == testInteract){
                            intSplit <- unlist(strsplit(allNames[grep(":",allNames)],split=":"))
                            plot( bug ~ factor(c( paste( get(intSplit[1]), get(intSplit[2]),sep=""))))
                            points(factor(c( paste( get(intSplit[1]), get(intSplit[2]),sep=""))), bug)
                        }
                    }
                    else{
                        plot( bug ~ factor(get(allNames[j])), ylab = names[i])
                        points(factor(get(allNames[j])), bug)
                    }
                }
            }

            index <- index + 1
	}

    ## This should also be dynamic
    dFrame <- as.data.frame(matrix(unlist(allpvals), nrow= length(allpvals), byrow=TRUE))
    colnames(dFrame) <- unlist(allNames)
    rownames(dFrame) <- names
    orgCol <- ncol(dFrame)

    for(k in 1:(orgCol-mlm)){
        dFrame[, k + orgCol]<-p.adjust(dFrame[,k], method = "BH")
    }
    colnames(dFrame)[(orgCol + 1):length(dFrame)]<-paste0(rep("adjusted_"),colnames(dFrame)[1:(orgCol - mlm)])

    ## Try and dynamically generate the name of the plot here...
    write.table(dFrame, file=paste("pValues", filePrefix, taxa, ".txt",sep=""), sep="\t",row.names=FALSE)

    ## Get the sig table working
    ## It would also be nice to have a sig-picker for the plots and a combination of all sig results into one plot.
    keepVector <- grep("adj", names(dFrame))
    sigdFrame <-dFrame[which(dFrame[,keepVector] < 0.05,arr.ind=TRUE),]
    write.table(sigdFrame, file=paste("SIGpValues", filePrefix, taxa, ".txt",sep=""), sep="\t",row.names=FALSE)

    dev.off()
}

names
dFrame
rownames(dFrame)
rm(list=ls())

library("pscl")
library("lmtest")
library("nlme")
library("vegan")

setwd("/Users/mbrown67/Documents/Fodor/Datasets/MarkExperiment/Pooled/")

taxaLevels <- c( "phylum", "class", "order", "family", "genus")

filePrefix <- "_treatmentItime_batch_"
mlm<-FALSE


for(taxa in taxaLevels){

    inFileName <- paste( taxa, "LogNormwithMetadata_R1_Pooled.txt", sep ="")
    myT <-read.csv(inFileName,header=TRUE,sep="", na.strings="BLAH")

    numCols <- ncol(myT)
    numMetadataCols <- 20

    ## Reprocessing for correct column data type
    myColClasses <- c("character", rep("numeric", numCols - numMetadataCols - 1), rep("character", 11), "numeric", "numeric", "numeric", "character", "character", "character", "character", "character", "character")
    myT <-read.csv(inFileName, header=TRUE, sep="", colClasses=myColClasses, na.strings="BLAH", comment.char ="@")

    ## Removing unwanted samples {controls, replicates, duplicates, poor quality samples}
    removeControls<-c( "C1", "C2", "N1", "N2", "Neg", "Pos")
    myT<-myT[!(myT$Sample_ID %in% removeControls),]

    removetrs<-c("04_125_tr", "04_101_tr", "04_103_tr", "04_74_tr", "04_70_tr", "04_40_tr", "04_41_tr", "04_84_tr")
    myT<-myT[!(myT$Sample_ID %in% removetrs),]

    removeDups<-c("04-04_S63_L001_R1_001")
    myT<-myT[!(myT$MatchFile %in% removeDups),]

    ## Controls not dropped earlier
    manualDrop <- c("Neg_S40_L001_R1_001", "PCR1Neg_S65_L001_R1_001")
    myT<-myT[!(myT$MatchFile %in% manualDrop),]

    labDrop <- c("Harlan Labs")
    myT<-myT[!(myT$MouseOrigin %in% labDrop),]

    lowSeqDrop <- c("04-55_S32_L001_R1_001")
    myT<-myT[!(myT$MatchFile %in% lowSeqDrop),]
    ## Not sure what to do about this though.
    ### myT$Condition[which(myT$Treatment == "Ctrl", arr.ind = TRUE)]<-"Control"

    names <- vector()
    pValuesSex<- vector()
    pValuesAcuteChronic<- vector()
    pValuesCage<- vector()
    iccCage <- vector()
    iccKeptCounts <- vector()
    pValuesBatch<- vector()
    pValuesTreatment<- vector()
    pValuesTime <- vector()
    pValuesStressLength <- vector()
    pValuesInteraction <- vector()
    allpvals <- list()

    index <- 1
    pdf( paste(taxa, filePrefix, "boxplots.pdf", sep=""))

    for( i in 2:(ncol(myT) - numMetadataCols))
        if( sum(myT[,i] != 0 ) > nrow(myT) / 4 ){
            ## Easy access names
            bug <- myT[,i]
            ac <- myT$Condition
            sex <- myT$Sex
            cage <- myT$Cage
            batch <- myT$Sample_Plate
            date <- myT$Date
            mo <- myT$MouseOrigin
            group <- myT$SpreadsheetGrouping
            treatment <- myT$Treatment
            time <- myT$StressLength
            multiWay <- paste(ac, myT$StressLength)
            multiWay[which(myT$Treatment == "Ctrl", arr.ind = TRUE)]<-"Control"
            names[index] = names(myT)[i]
            ## Some kind of vector for the variables of interest
            myFrame <- data.frame(bug, ac, time, multiWay, sex, cage, treatment, batch, date, mo, date)
            if(mlm == TRUE){
                fullModel <- gls( bug~ treatment*time + batch, method="REML",correlation=corCompSymm(form=~1|factor(group)),	data = myFrame )
                reducedModel <- gls( bug~ treatment*time + batch, method="REML", data = myFrame )
                fullModelLME <- lme(bug~ treatment*time + batch, method="REML", random = ~1|factor(group), data = myFrame)
            }
            else{
                fullModelLME <- lm(bug~ treatment*time + batch, x=TRUE)
            }
            ## Potential save time by reducing anova calls
            ## Introduce the goodness of fit tests here
            ## Can streamline vectors to be automatically responsive to changes to the model
            if(mlm == TRUE){
                allNames <- rownames(anova(fullModelLME))[-1]
                allpvals[[index]] <- anova(fullModelLME)$"p-value"[-1]
            }
            else {
                allNames <- rownames(anova(fullModelLME))[-length(anova(fullModelLME))]
                allpvals[[index]]<-as.data.frame(anova(fullModelLME))[1:length(anova(fullModelLME))-1,5]
            }

            ## Random Effects and Interclass Correlation Coefficient
            if(mlm == TRUE){
                allNames<-c(allNames, "cage", "iccCage")
                allpvals[[index]]<-c(allpvals[[index]], anova(fullModelLME, reducedModel)$"p-value"[2], coef(fullModel$modelStruct[1]$corStruct,unconstrained=FALSE)[[1]])
                pValuesCage[index] <-  anova(fullModelLME, reducedModel)$"p-value"[2]
                ## This is different as it is not corrected for multiple hypothesis testing.
                iccCage[index]<- coef(fullModel$modelStruct[1]$corStruct,unconstrained=FALSE)[[1]]
            }
    ## Nice plotting
            ## Correct so that it uses corrected p-values
            if(mlm == TRUE){
                graphMain = c(names[i], paste(c(rep("p-",length(allNames)-1),""), allNames, " = ", format(allpvals[[index]], digits=3), sep=""))
            }
            else {
                graphMain = c(names[i], paste(c(rep("p-",length(allNames)),""), allNames, " = ", format(allpvals[[index]], digits=3), sep=""))

            }

            ## mlm is boolean 1/0 value. Basically, don't graph on icc
            ## need a correction for interaction terms as well
            numPlots <- length(allNames) - mlm
            par(mfrow=c(numPlots, 1),
                oma = c(1,1,0,0) + 0.1,
                mar = c(1,4,3,0) + 0.1)

            for(j in 1:numPlots){
                if(j == 1){
                    plot( bug ~ factor(get(allNames[j])), ylab = names[i], main = c(names[index],toString(graphMain[-1])) )
                    points(factor(get(allNames[j])), bug)
                }
                else{
                    testInteract <- grep(":", allNames)
                    if(length(testInteract) > 0){
                        if(j == testInteract){
                            intSplit <- unlist(strsplit(allNames[grep(":",allNames)],split=":"))
                            plot( bug ~ factor(c( paste( get(intSplit[1]), get(intSplit[2]),sep=""))))
                            points(factor(c( paste( get(intSplit[1]), get(intSplit[2]),sep=""))), bug)
                        }
                    }
                    else{
                        plot( bug ~ factor(get(allNames[j])), ylab = names[i])
                        points(factor(get(allNames[j])), bug)
                    }
                }
            }

            index <- index + 1
	}

    ## This should also be dynamic
    dFrame <- as.data.frame(matrix(unlist(allpvals), nrow= length(allpvals), byrow=TRUE))
    colnames(dFrame) <- unlist(allNames)
    rownames(dFrame) <- names
    orgCol <- ncol(dFrame)

    for(k in 1:(orgCol-mlm)){
        dFrame[, k + orgCol]<-p.adjust(dFrame[,k], method = "BH")
    }
    colnames(dFrame)[(orgCol + 1):length(dFrame)]<-paste0(rep("adjusted_"),colnames(dFrame)[1:(orgCol - mlm)])

    ## Try and dynamically generate the name of the plot here...
    write.table(dFrame, file=paste("pValues", filePrefix, taxa, ".txt",sep=""), sep="\t",row.names=TRUE)

    ## Get the sig table working
    ## It would also be nice to have a sig-picker for the plots and a combination of all sig results into one plot.
    keepVector <- grep("adj", names(dFrame))
    sigdFrame <-dFrame[which(dFrame[,keepVector] < 0.05,arr.ind=TRUE),]
    write.table(sigdFrame, file=paste("SIGpValues", filePrefix, taxa, ".txt",sep=""), sep="\t",row.names=TRUE)

    dev.off()
}

rm(list=ls())

library("pscl")
library("lmtest")
library("nlme")
library("vegan")

setwd("/Users/mbrown67/Documents/Fodor/Datasets/MarkExperiment/Pooled/")

taxaLevels <- c( "phylum", "class", "order", "family", "genus")

filePrefix <- "_treatmentItime_batch_"
mlm<-FALSE


for(taxa in taxaLevels){

    inFileName <- paste( taxa, "LogNormwithMetadata_R1_Pooled.txt", sep ="")
    myT <-read.csv(inFileName,header=TRUE,sep="", na.strings="BLAH")

    numCols <- ncol(myT)
    numMetadataCols <- 20

    ## Reprocessing for correct column data type
    myColClasses <- c("character", rep("numeric", numCols - numMetadataCols - 1), rep("character", 11), "numeric", "numeric", "numeric", "character", "character", "character", "character", "character", "character")
    myT <-read.csv(inFileName, header=TRUE, sep="", colClasses=myColClasses, na.strings="BLAH", comment.char ="@")

    ## Removing unwanted samples {controls, replicates, duplicates, poor quality samples}
    removeControls<-c( "C1", "C2", "N1", "N2", "Neg", "Pos")
    myT<-myT[!(myT$Sample_ID %in% removeControls),]

    removetrs<-c("04_125_tr", "04_101_tr", "04_103_tr", "04_74_tr", "04_70_tr", "04_40_tr", "04_41_tr", "04_84_tr")
    myT<-myT[!(myT$Sample_ID %in% removetrs),]

    removeDups<-c("04-04_S63_L001_R1_001")
    myT<-myT[!(myT$MatchFile %in% removeDups),]

    ## Controls not dropped earlier
    manualDrop <- c("Neg_S40_L001_R1_001", "PCR1Neg_S65_L001_R1_001")
    myT<-myT[!(myT$MatchFile %in% manualDrop),]

    labDrop <- c("Harlan Labs")
    myT<-myT[!(myT$MouseOrigin %in% labDrop),]

    lowSeqDrop <- c("04-55_S32_L001_R1_001")
    myT<-myT[!(myT$MatchFile %in% lowSeqDrop),]
    ## Not sure what to do about this though.
    ### myT$Condition[which(myT$Treatment == "Ctrl", arr.ind = TRUE)]<-"Control"

    names <- vector()
    pValuesSex<- vector()
    pValuesAcuteChronic<- vector()
    pValuesCage<- vector()
    iccCage <- vector()
    iccKeptCounts <- vector()
    pValuesBatch<- vector()
    pValuesTreatment<- vector()
    pValuesTime <- vector()
    pValuesStressLength <- vector()
    pValuesInteraction <- vector()
    allpvals <- list()

    index <- 1
    pdf( paste(taxa, filePrefix, "boxplots.pdf", sep=""))

    for( i in 2:(ncol(myT) - numMetadataCols))
        if( sum(myT[,i] != 0 ) > nrow(myT) / 4 ){
            ## Easy access names
            bug <- myT[,i]
            ac <- myT$Condition
            sex <- myT$Sex
            cage <- myT$Cage
            batch <- myT$Sample_Plate
            date <- myT$Date
            mo <- myT$MouseOrigin
            group <- myT$SpreadsheetGrouping
            treatment <- myT$Treatment
            time <- myT$StressLength
            multiWay <- paste(ac, myT$StressLength)
            multiWay[which(myT$Treatment == "Ctrl", arr.ind = TRUE)]<-"Control"
            names[index] = names(myT)[i]
            ## Some kind of vector for the variables of interest
            myFrame <- data.frame(bug, ac, time, multiWay, sex, cage, treatment, batch, date, mo, date)
            if(mlm == TRUE){
                fullModel <- gls( bug~ treatment*time + batch, method="REML",correlation=corCompSymm(form=~1|factor(group)),	data = myFrame )
                reducedModel <- gls( bug~ treatment*time + batch, method="REML", data = myFrame )
                fullModelLME <- lme(bug~ treatment*time + batch, method="REML", random = ~1|factor(group), data = myFrame)
            }
            else{
                fullModelLME <- lm(bug~ treatment*time + batch, x=TRUE)
            }
            ## Potential save time by reducing anova calls
            ## Introduce the goodness of fit tests here
            ## Can streamline vectors to be automatically responsive to changes to the model
            if(mlm == TRUE){
                allNames <- rownames(anova(fullModelLME))[-1]
                allpvals[[index]] <- anova(fullModelLME)$"p-value"[-1]
            }
            else {
                allNames <- rownames(anova(fullModelLME))[-length(anova(fullModelLME))]
                allpvals[[index]]<-as.data.frame(anova(fullModelLME))[1:length(anova(fullModelLME))-1,5]
            }

            ## Random Effects and Interclass Correlation Coefficient
            if(mlm == TRUE){
                allNames<-c(allNames, "cage", "iccCage")
                allpvals[[index]]<-c(allpvals[[index]], anova(fullModelLME, reducedModel)$"p-value"[2], coef(fullModel$modelStruct[1]$corStruct,unconstrained=FALSE)[[1]])
                pValuesCage[index] <-  anova(fullModelLME, reducedModel)$"p-value"[2]
                ## This is different as it is not corrected for multiple hypothesis testing.
                iccCage[index]<- coef(fullModel$modelStruct[1]$corStruct,unconstrained=FALSE)[[1]]
            }
    ## Nice plotting
            ## Correct so that it uses corrected p-values
            if(mlm == TRUE){
                graphMain = c(names[i], paste(c(rep("p-",length(allNames)-1),""), allNames, " = ", format(allpvals[[index]], digits=3), sep=""))
            }
            else {
                graphMain = c(names[i], paste(c(rep("p-",length(allNames)),""), allNames, " = ", format(allpvals[[index]], digits=3), sep=""))

            }

            ## mlm is boolean 1/0 value. Basically, don't graph on icc
            ## need a correction for interaction terms as well
            numPlots <- length(allNames) - mlm
            par(mfrow=c(numPlots, 1),
                oma = c(1,1,0,0) + 0.1,
                mar = c(1,4,3,0) + 0.1)

            for(j in 1:numPlots){
                if(j == 1){
                    plot( bug ~ factor(get(allNames[j])), ylab = names[i], main = c(names[index],toString(graphMain[-1])) )
                    points(factor(get(allNames[j])), bug)
                }
                else{
                    testInteract <- grep(":", allNames)
                    if(length(testInteract) > 0){
                        if(j == testInteract){
                            intSplit <- unlist(strsplit(allNames[grep(":",allNames)],split=":"))
                            plot( bug ~ factor(c( paste( get(intSplit[1]), get(intSplit[2]),sep=""))))
                            points(factor(c( paste( get(intSplit[1]), get(intSplit[2]),sep=""))), bug)
                        }
                    }
                    else{
                        plot( bug ~ factor(get(allNames[j])), ylab = names[i])
                        points(factor(get(allNames[j])), bug)
                    }
                }
            }

            index <- index + 1
	}

    ## This should also be dynamic
    dFrame <- as.data.frame(matrix(unlist(allpvals), nrow= length(allpvals), byrow=TRUE))
    colnames(dFrame) <- unlist(allNames)
    rownames(dFrame) <- names
    orgCol <- ncol(dFrame)

    for(k in 1:(orgCol-mlm)){
        dFrame[, k + orgCol]<-p.adjust(dFrame[,k], method = "BH")
    }
    colnames(dFrame)[(orgCol + 1):length(dFrame)]<-paste0(rep("adjusted_"),colnames(dFrame)[1:(orgCol - mlm)])

    ## Try and dynamically generate the name of the plot here...
    write.table(dFrame, file=paste("pValues", filePrefix, taxa, ".txt",sep=""), sep="\t",row.names=FALSE)

    ## Get the sig table working
    ## It would also be nice to have a sig-picker for the plots and a combination of all sig results into one plot.
    keepVector <- grep("adj", names(dFrame))
    sigdFrame <-dFrame[which(dFrame[,keepVector] < 0.05,arr.ind=TRUE),]
    write.table(sigdFrame, file=paste("SIGpValues", filePrefix, taxa, ".txt",sep=""), sep="\t",row.names=FALSE)

    dev.off()
}

dFrame
    dFrame <- cbind(names, dFrame)
colnames(dFrame)
rm(list=ls())

library("pscl")
library("lmtest")
library("nlme")
library("vegan")

setwd("/Users/mbrown67/Documents/Fodor/Datasets/MarkExperiment/Pooled/")

taxaLevels <- c( "phylum", "class", "order", "family", "genus")

filePrefix <- "_treatmentItime_batch_"
mlm<-FALSE


for(taxa in taxaLevels){

    inFileName <- paste( taxa, "LogNormwithMetadata_R1_Pooled.txt", sep ="")
    myT <-read.csv(inFileName,header=TRUE,sep="", na.strings="BLAH")

    numCols <- ncol(myT)
    numMetadataCols <- 20

    ## Reprocessing for correct column data type
    myColClasses <- c("character", rep("numeric", numCols - numMetadataCols - 1), rep("character", 11), "numeric", "numeric", "numeric", "character", "character", "character", "character", "character", "character")
    myT <-read.csv(inFileName, header=TRUE, sep="", colClasses=myColClasses, na.strings="BLAH", comment.char ="@")

    ## Removing unwanted samples {controls, replicates, duplicates, poor quality samples}
    removeControls<-c( "C1", "C2", "N1", "N2", "Neg", "Pos")
    myT<-myT[!(myT$Sample_ID %in% removeControls),]

    removetrs<-c("04_125_tr", "04_101_tr", "04_103_tr", "04_74_tr", "04_70_tr", "04_40_tr", "04_41_tr", "04_84_tr")
    myT<-myT[!(myT$Sample_ID %in% removetrs),]

    removeDups<-c("04-04_S63_L001_R1_001")
    myT<-myT[!(myT$MatchFile %in% removeDups),]

    ## Controls not dropped earlier
    manualDrop <- c("Neg_S40_L001_R1_001", "PCR1Neg_S65_L001_R1_001")
    myT<-myT[!(myT$MatchFile %in% manualDrop),]

    labDrop <- c("Harlan Labs")
    myT<-myT[!(myT$MouseOrigin %in% labDrop),]

    lowSeqDrop <- c("04-55_S32_L001_R1_001")
    myT<-myT[!(myT$MatchFile %in% lowSeqDrop),]
    ## Not sure what to do about this though.
    ### myT$Condition[which(myT$Treatment == "Ctrl", arr.ind = TRUE)]<-"Control"

    names <- vector()
    pValuesSex<- vector()
    pValuesAcuteChronic<- vector()
    pValuesCage<- vector()
    iccCage <- vector()
    iccKeptCounts <- vector()
    pValuesBatch<- vector()
    pValuesTreatment<- vector()
    pValuesTime <- vector()
    pValuesStressLength <- vector()
    pValuesInteraction <- vector()
    allpvals <- list()

    index <- 1
    pdf( paste(taxa, filePrefix, "boxplots.pdf", sep=""))

    for( i in 2:(ncol(myT) - numMetadataCols))
        if( sum(myT[,i] != 0 ) > nrow(myT) / 4 ){
            ## Easy access names
            bug <- myT[,i]
            ac <- myT$Condition
            sex <- myT$Sex
            cage <- myT$Cage
            batch <- myT$Sample_Plate
            date <- myT$Date
            mo <- myT$MouseOrigin
            group <- myT$SpreadsheetGrouping
            treatment <- myT$Treatment
            time <- myT$StressLength
            multiWay <- paste(ac, myT$StressLength)
            multiWay[which(myT$Treatment == "Ctrl", arr.ind = TRUE)]<-"Control"
            names[index] = names(myT)[i]
            ## Some kind of vector for the variables of interest
            myFrame <- data.frame(bug, ac, time, multiWay, sex, cage, treatment, batch, date, mo, date)
            if(mlm == TRUE){
                fullModel <- gls( bug~ treatment*time + batch, method="REML",correlation=corCompSymm(form=~1|factor(group)),	data = myFrame )
                reducedModel <- gls( bug~ treatment*time + batch, method="REML", data = myFrame )
                fullModelLME <- lme(bug~ treatment*time + batch, method="REML", random = ~1|factor(group), data = myFrame)
            }
            else{
                fullModelLME <- lm(bug~ treatment*time + batch, x=TRUE)
            }
            ## Potential save time by reducing anova calls
            ## Introduce the goodness of fit tests here
            ## Can streamline vectors to be automatically responsive to changes to the model
            if(mlm == TRUE){
                allNames <- rownames(anova(fullModelLME))[-1]
                allpvals[[index]] <- anova(fullModelLME)$"p-value"[-1]
            }
            else {
                allNames <- rownames(anova(fullModelLME))[-length(anova(fullModelLME))]
                allpvals[[index]]<-as.data.frame(anova(fullModelLME))[1:length(anova(fullModelLME))-1,5]
            }

            ## Random Effects and Interclass Correlation Coefficient
            if(mlm == TRUE){
                allNames<-c(allNames, "cage", "iccCage")
                allpvals[[index]]<-c(allpvals[[index]], anova(fullModelLME, reducedModel)$"p-value"[2], coef(fullModel$modelStruct[1]$corStruct,unconstrained=FALSE)[[1]])
                pValuesCage[index] <-  anova(fullModelLME, reducedModel)$"p-value"[2]
                ## This is different as it is not corrected for multiple hypothesis testing.
                iccCage[index]<- coef(fullModel$modelStruct[1]$corStruct,unconstrained=FALSE)[[1]]
            }
    ## Nice plotting
            ## Correct so that it uses corrected p-values
            if(mlm == TRUE){
                graphMain = c(names[i], paste(c(rep("p-",length(allNames)-1),""), allNames, " = ", format(allpvals[[index]], digits=3), sep=""))
            }
            else {
                graphMain = c(names[i], paste(c(rep("p-",length(allNames)),""), allNames, " = ", format(allpvals[[index]], digits=3), sep=""))

            }

            ## mlm is boolean 1/0 value. Basically, don't graph on icc
            ## need a correction for interaction terms as well
            numPlots <- length(allNames) - mlm
            par(mfrow=c(numPlots, 1),
                oma = c(1,1,0,0) + 0.1,
                mar = c(1,4,3,0) + 0.1)

            for(j in 1:numPlots){
                if(j == 1){
                    plot( bug ~ factor(get(allNames[j])), ylab = names[i], main = c(names[index],toString(graphMain[-1])) )
                    points(factor(get(allNames[j])), bug)
                }
                else{
                    testInteract <- grep(":", allNames)
                    if(length(testInteract) > 0){
                        if(j == testInteract){
                            intSplit <- unlist(strsplit(allNames[grep(":",allNames)],split=":"))
                            plot( bug ~ factor(c( paste( get(intSplit[1]), get(intSplit[2]),sep=""))))
                            points(factor(c( paste( get(intSplit[1]), get(intSplit[2]),sep=""))), bug)
                        }
                    }
                    else{
                        plot( bug ~ factor(get(allNames[j])), ylab = names[i])
                        points(factor(get(allNames[j])), bug)
                    }
                }
            }

            index <- index + 1
	}

    ## This should also be dynamic
    dFrame <- as.data.frame(matrix(unlist(allpvals), nrow= length(allpvals), byrow=TRUE))
    colnames(dFrame) <- unlist(allNames)
    rownames(dFrame) <- names
    orgCol <- ncol(dFrame)

    for(k in 1:(orgCol-mlm)){
        dFrame[, k + orgCol]<-p.adjust(dFrame[,k], method = "BH")
    }
    colnames(dFrame)[(orgCol + 1):length(dFrame)]<-paste0(rep("adjusted_"),colnames(dFrame)[1:(orgCol - mlm)])

    dFrame <- cbind(names, dFrame)
    ## Try and dynamically generate the name of the plot here...
    write.table(dFrame, file=paste("pValues", filePrefix, taxa, ".txt",sep=""), sep="\t",row.names=FALSE)

    ## Get the sig table working
    ## It would also be nice to have a sig-picker for the plots and a combination of all sig results into one plot.
    keepVector <- grep("adj", names(dFrame))
    sigdFrame <-dFrame[which(dFrame[,keepVector] < 0.05,arr.ind=TRUE),]
    write.table(sigdFrame, file=paste("SIGpValues", filePrefix, taxa, ".txt",sep=""), sep="\t",row.names=FALSE)

    dev.off()
}

rm(list=ls())

library("pscl")
library("lmtest")
library("nlme")
library("vegan")

setwd("/Users/mbrown67/Documents/Fodor/Datasets/MarkExperiment/Pooled/")

taxaLevels <- c( "phylum", "class", "order", "family", "genus")

filePrefix <- "_treatment_batch_"
mlm<-FALSE


for(taxa in taxaLevels){

    inFileName <- paste( taxa, "LogNormwithMetadata_R1_Pooled.txt", sep ="")
    myT <-read.csv(inFileName,header=TRUE,sep="", na.strings="BLAH")

    numCols <- ncol(myT)
    numMetadataCols <- 20

    ## Reprocessing for correct column data type
    myColClasses <- c("character", rep("numeric", numCols - numMetadataCols - 1), rep("character", 11), "numeric", "numeric", "numeric", "character", "character", "character", "character", "character", "character")
    myT <-read.csv(inFileName, header=TRUE, sep="", colClasses=myColClasses, na.strings="BLAH", comment.char ="@")

    ## Removing unwanted samples {controls, replicates, duplicates, poor quality samples}
    removeControls<-c( "C1", "C2", "N1", "N2", "Neg", "Pos")
    myT<-myT[!(myT$Sample_ID %in% removeControls),]

    removetrs<-c("04_125_tr", "04_101_tr", "04_103_tr", "04_74_tr", "04_70_tr", "04_40_tr", "04_41_tr", "04_84_tr")
    myT<-myT[!(myT$Sample_ID %in% removetrs),]

    removeDups<-c("04-04_S63_L001_R1_001")
    myT<-myT[!(myT$MatchFile %in% removeDups),]

    ## Controls not dropped earlier
    manualDrop <- c("Neg_S40_L001_R1_001", "PCR1Neg_S65_L001_R1_001")
    myT<-myT[!(myT$MatchFile %in% manualDrop),]

    labDrop <- c("Harlan Labs")
    myT<-myT[!(myT$MouseOrigin %in% labDrop),]

    lowSeqDrop <- c("04-55_S32_L001_R1_001")
    myT<-myT[!(myT$MatchFile %in% lowSeqDrop),]
    ## Not sure what to do about this though.
    ### myT$Condition[which(myT$Treatment == "Ctrl", arr.ind = TRUE)]<-"Control"

    names <- vector()
    pValuesSex<- vector()
    pValuesAcuteChronic<- vector()
    pValuesCage<- vector()
    iccCage <- vector()
    iccKeptCounts <- vector()
    pValuesBatch<- vector()
    pValuesTreatment<- vector()
    pValuesTime <- vector()
    pValuesStressLength <- vector()
    pValuesInteraction <- vector()
    allpvals <- list()

    index <- 1
    pdf( paste(taxa, filePrefix, "boxplots.pdf", sep=""))

    for( i in 2:(ncol(myT) - numMetadataCols))
        if( sum(myT[,i] != 0 ) > nrow(myT) / 4 ){
            ## Easy access names
            bug <- myT[,i]
            ac <- myT$Condition
            sex <- myT$Sex
            cage <- myT$Cage
            batch <- myT$Sample_Plate
            date <- myT$Date
            mo <- myT$MouseOrigin
            group <- myT$SpreadsheetGrouping
            treatment <- myT$Treatment
            time <- myT$StressLength
            multiWay <- paste(ac, myT$StressLength)
            multiWay[which(myT$Treatment == "Ctrl", arr.ind = TRUE)]<-"Control"
            names[index] = names(myT)[i]
            ## Some kind of vector for the variables of interest
            myFrame <- data.frame(bug, ac, time, multiWay, sex, cage, treatment, batch, date, mo, date)
            if(mlm == TRUE){
                fullModel <- gls( bug~ treatment + batch, method="REML",correlation=corCompSymm(form=~1|factor(group)),	data = myFrame )
                reducedModel <- gls( bug~ treatment + batch, method="REML", data = myFrame )
                fullModelLME <- lme(bug~ treatment*time + batch, method="REML", random = ~1|factor(group), data = myFrame)
            }
            else{
                fullModelLME <- lm(bug~ treatment + batch, x=TRUE)
            }
            ## Potential save time by reducing anova calls
            ## Introduce the goodness of fit tests here
            ## Can streamline vectors to be automatically responsive to changes to the model
            if(mlm == TRUE){
                allNames <- rownames(anova(fullModelLME))[-1]
                allpvals[[index]] <- anova(fullModelLME)$"p-value"[-1]
            }
            else {
                allNames <- rownames(anova(fullModelLME))[-length(anova(fullModelLME))]
                allpvals[[index]]<-as.data.frame(anova(fullModelLME))[1:length(anova(fullModelLME))-1,5]
            }

            ## Random Effects and Interclass Correlation Coefficient
            if(mlm == TRUE){
                allNames<-c(allNames, "cage", "iccCage")
                allpvals[[index]]<-c(allpvals[[index]], anova(fullModelLME, reducedModel)$"p-value"[2], coef(fullModel$modelStruct[1]$corStruct,unconstrained=FALSE)[[1]])
                pValuesCage[index] <-  anova(fullModelLME, reducedModel)$"p-value"[2]
                ## This is different as it is not corrected for multiple hypothesis testing.
                iccCage[index]<- coef(fullModel$modelStruct[1]$corStruct,unconstrained=FALSE)[[1]]
            }
    ## Nice plotting
            ## Correct so that it uses corrected p-values
            if(mlm == TRUE){
                graphMain = c(names[i], paste(c(rep("p-",length(allNames)-1),""), allNames, " = ", format(allpvals[[index]], digits=3), sep=""))
            }
            else {
                graphMain = c(names[i], paste(c(rep("p-",length(allNames)),""), allNames, " = ", format(allpvals[[index]], digits=3), sep=""))

            }

            ## mlm is boolean 1/0 value. Basically, don't graph on icc
            ## need a correction for interaction terms as well
            numPlots <- length(allNames) - mlm
            par(mfrow=c(numPlots, 1),
                oma = c(1,1,0,0) + 0.1,
                mar = c(1,4,3,0) + 0.1)

            for(j in 1:numPlots){
                if(j == 1){
                    plot( bug ~ factor(get(allNames[j])), ylab = names[i], main = c(names[index],toString(graphMain[-1])) )
                    points(factor(get(allNames[j])), bug)
                }
                else{
                    testInteract <- grep(":", allNames)
                    if(length(testInteract) > 0){
                        if(j == testInteract){
                            intSplit <- unlist(strsplit(allNames[grep(":",allNames)],split=":"))
                            plot( bug ~ factor(c( paste( get(intSplit[1]), get(intSplit[2]),sep=""))))
                            points(factor(c( paste( get(intSplit[1]), get(intSplit[2]),sep=""))), bug)
                        }
                    }
                    else{
                        plot( bug ~ factor(get(allNames[j])), ylab = names[i])
                        points(factor(get(allNames[j])), bug)
                    }
                }
            }

            index <- index + 1
	}

    ## This should also be dynamic
    dFrame <- as.data.frame(matrix(unlist(allpvals), nrow= length(allpvals), byrow=TRUE))
    colnames(dFrame) <- unlist(allNames)
    rownames(dFrame) <- names
    orgCol <- ncol(dFrame)

    for(k in 1:(orgCol-mlm)){
        dFrame[, k + orgCol]<-p.adjust(dFrame[,k], method = "BH")
    }
    colnames(dFrame)[(orgCol + 1):length(dFrame)]<-paste0(rep("adjusted_"),colnames(dFrame)[1:(orgCol - mlm)])

    dFrame <- cbind(names, dFrame)
    ## Try and dynamically generate the name of the plot here...
    write.table(dFrame, file=paste("pValues", filePrefix, taxa, ".txt",sep=""), sep="\t",row.names=FALSE)

    ## Get the sig table working
    ## It would also be nice to have a sig-picker for the plots and a combination of all sig results into one plot.
    keepVector <- grep("adj", names(dFrame))
    sigdFrame <-dFrame[which(dFrame[,keepVector] < 0.05,arr.ind=TRUE),]
    write.table(sigdFrame, file=paste("SIGpValues", filePrefix, taxa, ".txt",sep=""), sep="\t",row.names=FALSE)

    dev.off()
}

anova(fullModelLME)
length(anova(fullModelLME))
dim(anova(fullModelLME))
rm(list=ls())

library("pscl")
library("lmtest")
library("nlme")
library("vegan")

setwd("/Users/mbrown67/Documents/Fodor/Datasets/MarkExperiment/Pooled/")

taxaLevels <- c( "phylum", "class", "order", "family", "genus")

filePrefix <- "_treatmentItime_batch_"
mlm<-FALSE


for(taxa in taxaLevels){

    inFileName <- paste( taxa, "LogNormwithMetadata_R1_Pooled.txt", sep ="")
    myT <-read.csv(inFileName,header=TRUE,sep="", na.strings="BLAH")

    numCols <- ncol(myT)
    numMetadataCols <- 20

    ## Reprocessing for correct column data type
    myColClasses <- c("character", rep("numeric", numCols - numMetadataCols - 1), rep("character", 11), "numeric", "numeric", "numeric", "character", "character", "character", "character", "character", "character")
    myT <-read.csv(inFileName, header=TRUE, sep="", colClasses=myColClasses, na.strings="BLAH", comment.char ="@")

    ## Removing unwanted samples {controls, replicates, duplicates, poor quality samples}
    removeControls<-c( "C1", "C2", "N1", "N2", "Neg", "Pos")
    myT<-myT[!(myT$Sample_ID %in% removeControls),]

    removetrs<-c("04_125_tr", "04_101_tr", "04_103_tr", "04_74_tr", "04_70_tr", "04_40_tr", "04_41_tr", "04_84_tr")
    myT<-myT[!(myT$Sample_ID %in% removetrs),]

    removeDups<-c("04-04_S63_L001_R1_001")
    myT<-myT[!(myT$MatchFile %in% removeDups),]

    ## Controls not dropped earlier
    manualDrop <- c("Neg_S40_L001_R1_001", "PCR1Neg_S65_L001_R1_001")
    myT<-myT[!(myT$MatchFile %in% manualDrop),]

    labDrop <- c("Harlan Labs")
    myT<-myT[!(myT$MouseOrigin %in% labDrop),]

    lowSeqDrop <- c("04-55_S32_L001_R1_001")
    myT<-myT[!(myT$MatchFile %in% lowSeqDrop),]
    ## Not sure what to do about this though.
    ### myT$Condition[which(myT$Treatment == "Ctrl", arr.ind = TRUE)]<-"Control"

    names <- vector()
    pValuesSex<- vector()
    pValuesAcuteChronic<- vector()
    pValuesCage<- vector()
    iccCage <- vector()
    iccKeptCounts <- vector()
    pValuesBatch<- vector()
    pValuesTreatment<- vector()
    pValuesTime <- vector()
    pValuesStressLength <- vector()
    pValuesInteraction <- vector()
    allpvals <- list()

    index <- 1
    pdf( paste(taxa, filePrefix, "boxplots.pdf", sep=""))

    for( i in 2:(ncol(myT) - numMetadataCols))
        if( sum(myT[,i] != 0 ) > nrow(myT) / 4 ){
            ## Easy access names
            bug <- myT[,i]
            ac <- myT$Condition
            sex <- myT$Sex
            cage <- myT$Cage
            batch <- myT$Sample_Plate
            date <- myT$Date
            mo <- myT$MouseOrigin
            group <- myT$SpreadsheetGrouping
            treatment <- myT$Treatment
            time <- myT$StressLength
            multiWay <- paste(ac, myT$StressLength)
            multiWay[which(myT$Treatment == "Ctrl", arr.ind = TRUE)]<-"Control"
            names[index] = names(myT)[i]
            ## Some kind of vector for the variables of interest
            myFrame <- data.frame(bug, ac, time, multiWay, sex, cage, treatment, batch, date, mo, date)
            if(mlm == TRUE){
                fullModel <- gls( bug~ treatment*time + batch, method="REML",correlation=corCompSymm(form=~1|factor(group)),	data = myFrame )
                reducedModel <- gls( bug~ treatment*time + batch, method="REML", data = myFrame )
                fullModelLME <- lme(bug~ treatment*time + batch, method="REML", random = ~1|factor(group), data = myFrame)
            }
            else{
                fullModelLME <- lm(bug~ treatment*time + batch, x=TRUE)
            }
            ## Potential save time by reducing anova calls
            ## Introduce the goodness of fit tests here
            ## Can streamline vectors to be automatically responsive to changes to the model
            if(mlm == TRUE){
                allNames <- rownames(anova(fullModelLME))[-1]
                allpvals[[index]] <- anova(fullModelLME)$"p-value"[-1]
            }
            else {
                allNames <- rownames(anova(fullModelLME))[-dim(anova(fullModelLME))[1]]
                allpvals[[index]]<-as.data.frame(anova(fullModelLME))[1:dim(anova(fullModelLME))[1]-1,5]
            }

            ## Random Effects and Interclass Correlation Coefficient
            if(mlm == TRUE){
                allNames<-c(allNames, "cage", "iccCage")
                allpvals[[index]]<-c(allpvals[[index]], anova(fullModelLME, reducedModel)$"p-value"[2], coef(fullModel$modelStruct[1]$corStruct,unconstrained=FALSE)[[1]])
                pValuesCage[index] <-  anova(fullModelLME, reducedModel)$"p-value"[2]
                ## This is different as it is not corrected for multiple hypothesis testing.
                iccCage[index]<- coef(fullModel$modelStruct[1]$corStruct,unconstrained=FALSE)[[1]]
            }
    ## Nice plotting
            ## Correct so that it uses corrected p-values
            if(mlm == TRUE){
                graphMain = c(names[i], paste(c(rep("p-",length(allNames)-1),""), allNames, " = ", format(allpvals[[index]], digits=3), sep=""))
            }
            else {
                graphMain = c(names[i], paste(c(rep("p-",length(allNames)),""), allNames, " = ", format(allpvals[[index]], digits=3), sep=""))

            }

            ## mlm is boolean 1/0 value. Basically, don't graph on icc
            ## need a correction for interaction terms as well
            numPlots <- length(allNames) - mlm
            par(mfrow=c(numPlots, 1),
                oma = c(1,1,0,0) + 0.1,
                mar = c(1,4,3,0) + 0.1)

            for(j in 1:numPlots){
                if(j == 1){
                    plot( bug ~ factor(get(allNames[j])), ylab = names[i], main = c(names[index],toString(graphMain[-1])) )
                    points(factor(get(allNames[j])), bug)
                }
                else{
                    testInteract <- grep(":", allNames)
                    if(length(testInteract) > 0){
                        if(j == testInteract){
                            intSplit <- unlist(strsplit(allNames[grep(":",allNames)],split=":"))
                            plot( bug ~ factor(c( paste( get(intSplit[1]), get(intSplit[2]),sep=""))))
                            points(factor(c( paste( get(intSplit[1]), get(intSplit[2]),sep=""))), bug)
                        }
                    }
                    else{
                        plot( bug ~ factor(get(allNames[j])), ylab = names[i])
                        points(factor(get(allNames[j])), bug)
                    }
                }
            }

            index <- index + 1
	}

    ## This should also be dynamic
    dFrame <- as.data.frame(matrix(unlist(allpvals), nrow= length(allpvals), byrow=TRUE))
    colnames(dFrame) <- unlist(allNames)
    rownames(dFrame) <- names
    orgCol <- ncol(dFrame)

    for(k in 1:(orgCol-mlm)){
        dFrame[, k + orgCol]<-p.adjust(dFrame[,k], method = "BH")
    }
    colnames(dFrame)[(orgCol + 1):length(dFrame)]<-paste0(rep("adjusted_"),colnames(dFrame)[1:(orgCol - mlm)])

    dFrame <- cbind(names, dFrame)
    ## Try and dynamically generate the name of the plot here...
    write.table(dFrame, file=paste("pValues", filePrefix, taxa, ".txt",sep=""), sep="\t",row.names=FALSE)

    ## Get the sig table working
    ## It would also be nice to have a sig-picker for the plots and a combination of all sig results into one plot.
    keepVector <- grep("adj", names(dFrame))
    sigdFrame <-dFrame[which(dFrame[,keepVector] < 0.05,arr.ind=TRUE),]
    write.table(sigdFrame, file=paste("SIGpValues", filePrefix, taxa, ".txt",sep=""), sep="\t",row.names=FALSE)

    dev.off()
}

rm(list=ls())

library("pscl")
library("lmtest")
library("nlme")
library("vegan")

setwd("/Users/mbrown67/Documents/Fodor/Datasets/MarkExperiment/Pooled/")

taxaLevels <- c( "phylum", "class", "order", "family", "genus")

filePrefix <- "_treatment_batch_"
mlm<-FALSE


for(taxa in taxaLevels){

    inFileName <- paste( taxa, "LogNormwithMetadata_R1_Pooled.txt", sep ="")
    myT <-read.csv(inFileName,header=TRUE,sep="", na.strings="BLAH")

    numCols <- ncol(myT)
    numMetadataCols <- 20

    ## Reprocessing for correct column data type
    myColClasses <- c("character", rep("numeric", numCols - numMetadataCols - 1), rep("character", 11), "numeric", "numeric", "numeric", "character", "character", "character", "character", "character", "character")
    myT <-read.csv(inFileName, header=TRUE, sep="", colClasses=myColClasses, na.strings="BLAH", comment.char ="@")

    ## Removing unwanted samples {controls, replicates, duplicates, poor quality samples}
    removeControls<-c( "C1", "C2", "N1", "N2", "Neg", "Pos")
    myT<-myT[!(myT$Sample_ID %in% removeControls),]

    removetrs<-c("04_125_tr", "04_101_tr", "04_103_tr", "04_74_tr", "04_70_tr", "04_40_tr", "04_41_tr", "04_84_tr")
    myT<-myT[!(myT$Sample_ID %in% removetrs),]

    removeDups<-c("04-04_S63_L001_R1_001")
    myT<-myT[!(myT$MatchFile %in% removeDups),]

    ## Controls not dropped earlier
    manualDrop <- c("Neg_S40_L001_R1_001", "PCR1Neg_S65_L001_R1_001")
    myT<-myT[!(myT$MatchFile %in% manualDrop),]

    labDrop <- c("Harlan Labs")
    myT<-myT[!(myT$MouseOrigin %in% labDrop),]

    lowSeqDrop <- c("04-55_S32_L001_R1_001")
    myT<-myT[!(myT$MatchFile %in% lowSeqDrop),]
    ## Not sure what to do about this though.
    ### myT$Condition[which(myT$Treatment == "Ctrl", arr.ind = TRUE)]<-"Control"

    names <- vector()
    pValuesSex<- vector()
    pValuesAcuteChronic<- vector()
    pValuesCage<- vector()
    iccCage <- vector()
    iccKeptCounts <- vector()
    pValuesBatch<- vector()
    pValuesTreatment<- vector()
    pValuesTime <- vector()
    pValuesStressLength <- vector()
    pValuesInteraction <- vector()
    allpvals <- list()

    index <- 1
    pdf( paste(taxa, filePrefix, "boxplots.pdf", sep=""))

    for( i in 2:(ncol(myT) - numMetadataCols))
        if( sum(myT[,i] != 0 ) > nrow(myT) / 4 ){
            ## Easy access names
            bug <- myT[,i]
            ac <- myT$Condition
            sex <- myT$Sex
            cage <- myT$Cage
            batch <- myT$Sample_Plate
            date <- myT$Date
            mo <- myT$MouseOrigin
            group <- myT$SpreadsheetGrouping
            treatment <- myT$Treatment
            time <- myT$StressLength
            multiWay <- paste(ac, myT$StressLength)
            multiWay[which(myT$Treatment == "Ctrl", arr.ind = TRUE)]<-"Control"
            names[index] = names(myT)[i]
            ## Some kind of vector for the variables of interest
            myFrame <- data.frame(bug, ac, time, multiWay, sex, cage, treatment, batch, date, mo, date)
            if(mlm == TRUE){
                fullModel <- gls( bug~ treatment*time + batch, method="REML",correlation=corCompSymm(form=~1|factor(group)),	data = myFrame )
                reducedModel <- gls( bug~ treatment*time + batch, method="REML", data = myFrame )
                fullModelLME <- lme(bug~ treatment*time + batch, method="REML", random = ~1|factor(group), data = myFrame)
            }
            else{
                fullModelLME <- lm(bug~ treatment + batch, x=TRUE)
            }
            ## Potential save time by reducing anova calls
            ## Introduce the goodness of fit tests here
            ## Can streamline vectors to be automatically responsive to changes to the model
            if(mlm == TRUE){
                allNames <- rownames(anova(fullModelLME))[-1]
                allpvals[[index]] <- anova(fullModelLME)$"p-value"[-1]
            }
            else {
                allNames <- rownames(anova(fullModelLME))[-dim(anova(fullModelLME))[1]]
                allpvals[[index]]<-as.data.frame(anova(fullModelLME))[1:dim(anova(fullModelLME))[1]-1,5]
            }

            ## Random Effects and Interclass Correlation Coefficient
            if(mlm == TRUE){
                allNames<-c(allNames, "cage", "iccCage")
                allpvals[[index]]<-c(allpvals[[index]], anova(fullModelLME, reducedModel)$"p-value"[2], coef(fullModel$modelStruct[1]$corStruct,unconstrained=FALSE)[[1]])
                pValuesCage[index] <-  anova(fullModelLME, reducedModel)$"p-value"[2]
                ## This is different as it is not corrected for multiple hypothesis testing.
                iccCage[index]<- coef(fullModel$modelStruct[1]$corStruct,unconstrained=FALSE)[[1]]
            }
    ## Nice plotting
            ## Correct so that it uses corrected p-values
            if(mlm == TRUE){
                graphMain = c(names[i], paste(c(rep("p-",length(allNames)-1),""), allNames, " = ", format(allpvals[[index]], digits=3), sep=""))
            }
            else {
                graphMain = c(names[i], paste(c(rep("p-",length(allNames)),""), allNames, " = ", format(allpvals[[index]], digits=3), sep=""))

            }

            ## mlm is boolean 1/0 value. Basically, don't graph on icc
            ## need a correction for interaction terms as well
            numPlots <- length(allNames) - mlm
            par(mfrow=c(numPlots, 1),
                oma = c(1,1,0,0) + 0.1,
                mar = c(1,4,3,0) + 0.1)

            for(j in 1:numPlots){
                if(j == 1){
                    plot( bug ~ factor(get(allNames[j])), ylab = names[i], main = c(names[index],toString(graphMain[-1])) )
                    points(factor(get(allNames[j])), bug)
                }
                else{
                    testInteract <- grep(":", allNames)
                    if(length(testInteract) > 0){
                        if(j == testInteract){
                            intSplit <- unlist(strsplit(allNames[grep(":",allNames)],split=":"))
                            plot( bug ~ factor(c( paste( get(intSplit[1]), get(intSplit[2]),sep=""))))
                            points(factor(c( paste( get(intSplit[1]), get(intSplit[2]),sep=""))), bug)
                        }
                    }
                    else{
                        plot( bug ~ factor(get(allNames[j])), ylab = names[i])
                        points(factor(get(allNames[j])), bug)
                    }
                }
            }

            index <- index + 1
	}

    ## This should also be dynamic
    dFrame <- as.data.frame(matrix(unlist(allpvals), nrow= length(allpvals), byrow=TRUE))
    colnames(dFrame) <- unlist(allNames)
    rownames(dFrame) <- names
    orgCol <- ncol(dFrame)

    for(k in 1:(orgCol-mlm)){
        dFrame[, k + orgCol]<-p.adjust(dFrame[,k], method = "BH")
    }
    colnames(dFrame)[(orgCol + 1):length(dFrame)]<-paste0(rep("adjusted_"),colnames(dFrame)[1:(orgCol - mlm)])

    dFrame <- cbind(names, dFrame)
    ## Try and dynamically generate the name of the plot here...
    write.table(dFrame, file=paste("pValues", filePrefix, taxa, ".txt",sep=""), sep="\t",row.names=FALSE)

    ## Get the sig table working
    ## It would also be nice to have a sig-picker for the plots and a combination of all sig results into one plot.
    keepVector <- grep("adj", names(dFrame))
    sigdFrame <-dFrame[which(dFrame[,keepVector] < 0.05,arr.ind=TRUE),]
    write.table(sigdFrame, file=paste("SIGpValues", filePrefix, taxa, ".txt",sep=""), sep="\t",row.names=FALSE)

    dev.off()
}

rm(list=ls())

library("pscl")
library("lmtest")
library("nlme")
library("vegan")

setwd("/Users/mbrown67/Documents/Fodor/Datasets/MarkExperiment/Pooled/")

taxaLevels <- c( "phylum", "class", "order", "family", "genus")

filePrefix <- "_treatment_"
mlm<-FALSE


for(taxa in taxaLevels){

    inFileName <- paste( taxa, "LogNormwithMetadata_R1_Pooled.txt", sep ="")
    myT <-read.csv(inFileName,header=TRUE,sep="", na.strings="BLAH")

    numCols <- ncol(myT)
    numMetadataCols <- 20

    ## Reprocessing for correct column data type
    myColClasses <- c("character", rep("numeric", numCols - numMetadataCols - 1), rep("character", 11), "numeric", "numeric", "numeric", "character", "character", "character", "character", "character", "character")
    myT <-read.csv(inFileName, header=TRUE, sep="", colClasses=myColClasses, na.strings="BLAH", comment.char ="@")

    ## Removing unwanted samples {controls, replicates, duplicates, poor quality samples}
    removeControls<-c( "C1", "C2", "N1", "N2", "Neg", "Pos")
    myT<-myT[!(myT$Sample_ID %in% removeControls),]

    removetrs<-c("04_125_tr", "04_101_tr", "04_103_tr", "04_74_tr", "04_70_tr", "04_40_tr", "04_41_tr", "04_84_tr")
    myT<-myT[!(myT$Sample_ID %in% removetrs),]

    removeDups<-c("04-04_S63_L001_R1_001")
    myT<-myT[!(myT$MatchFile %in% removeDups),]

    ## Controls not dropped earlier
    manualDrop <- c("Neg_S40_L001_R1_001", "PCR1Neg_S65_L001_R1_001")
    myT<-myT[!(myT$MatchFile %in% manualDrop),]

    labDrop <- c("Harlan Labs")
    myT<-myT[!(myT$MouseOrigin %in% labDrop),]

    lowSeqDrop <- c("04-55_S32_L001_R1_001")
    myT<-myT[!(myT$MatchFile %in% lowSeqDrop),]
    ## Not sure what to do about this though.
    ### myT$Condition[which(myT$Treatment == "Ctrl", arr.ind = TRUE)]<-"Control"

    names <- vector()
    pValuesSex<- vector()
    pValuesAcuteChronic<- vector()
    pValuesCage<- vector()
    iccCage <- vector()
    iccKeptCounts <- vector()
    pValuesBatch<- vector()
    pValuesTreatment<- vector()
    pValuesTime <- vector()
    pValuesStressLength <- vector()
    pValuesInteraction <- vector()
    allpvals <- list()

    index <- 1
    pdf( paste(taxa, filePrefix, "boxplots.pdf", sep=""))

    for( i in 2:(ncol(myT) - numMetadataCols))
        if( sum(myT[,i] != 0 ) > nrow(myT) / 4 ){
            ## Easy access names
            bug <- myT[,i]
            ac <- myT$Condition
            sex <- myT$Sex
            cage <- myT$Cage
            batch <- myT$Sample_Plate
            date <- myT$Date
            mo <- myT$MouseOrigin
            group <- myT$SpreadsheetGrouping
            treatment <- myT$Treatment
            time <- myT$StressLength
            multiWay <- paste(ac, myT$StressLength)
            multiWay[which(myT$Treatment == "Ctrl", arr.ind = TRUE)]<-"Control"
            names[index] = names(myT)[i]
            ## Some kind of vector for the variables of interest
            myFrame <- data.frame(bug, ac, time, multiWay, sex, cage, treatment, batch, date, mo, date)
            if(mlm == TRUE){
                fullModel <- gls( bug~ treatment*time + batch, method="REML",correlation=corCompSymm(form=~1|factor(group)),	data = myFrame )
                reducedModel <- gls( bug~ treatment*time + batch, method="REML", data = myFrame )
                fullModelLME <- lme(bug~ treatment*time + batch, method="REML", random = ~1|factor(group), data = myFrame)
            }
            else{
                fullModelLME <- lm(bug~ treatment, x=TRUE)
            }
            ## Potential save time by reducing anova calls
            ## Introduce the goodness of fit tests here
            ## Can streamline vectors to be automatically responsive to changes to the model
            if(mlm == TRUE){
                allNames <- rownames(anova(fullModelLME))[-1]
                allpvals[[index]] <- anova(fullModelLME)$"p-value"[-1]
            }
            else {
                allNames <- rownames(anova(fullModelLME))[-dim(anova(fullModelLME))[1]]
                allpvals[[index]]<-as.data.frame(anova(fullModelLME))[1:dim(anova(fullModelLME))[1]-1,5]
            }

            ## Random Effects and Interclass Correlation Coefficient
            if(mlm == TRUE){
                allNames<-c(allNames, "cage", "iccCage")
                allpvals[[index]]<-c(allpvals[[index]], anova(fullModelLME, reducedModel)$"p-value"[2], coef(fullModel$modelStruct[1]$corStruct,unconstrained=FALSE)[[1]])
                pValuesCage[index] <-  anova(fullModelLME, reducedModel)$"p-value"[2]
                ## This is different as it is not corrected for multiple hypothesis testing.
                iccCage[index]<- coef(fullModel$modelStruct[1]$corStruct,unconstrained=FALSE)[[1]]
            }
    ## Nice plotting
            ## Correct so that it uses corrected p-values
            if(mlm == TRUE){
                graphMain = c(names[i], paste(c(rep("p-",length(allNames)-1),""), allNames, " = ", format(allpvals[[index]], digits=3), sep=""))
            }
            else {
                graphMain = c(names[i], paste(c(rep("p-",length(allNames)),""), allNames, " = ", format(allpvals[[index]], digits=3), sep=""))

            }

            ## mlm is boolean 1/0 value. Basically, don't graph on icc
            ## need a correction for interaction terms as well
            numPlots <- length(allNames) - mlm
            par(mfrow=c(numPlots, 1),
                oma = c(1,1,0,0) + 0.1,
                mar = c(1,4,3,0) + 0.1)

            for(j in 1:numPlots){
                if(j == 1){
                    plot( bug ~ factor(get(allNames[j])), ylab = names[i], main = c(names[index],toString(graphMain[-1])) )
                    points(factor(get(allNames[j])), bug)
                }
                else{
                    testInteract <- grep(":", allNames)
                    if(length(testInteract) > 0){
                        if(j == testInteract){
                            intSplit <- unlist(strsplit(allNames[grep(":",allNames)],split=":"))
                            plot( bug ~ factor(c( paste( get(intSplit[1]), get(intSplit[2]),sep=""))))
                            points(factor(c( paste( get(intSplit[1]), get(intSplit[2]),sep=""))), bug)
                        }
                    }
                    else{
                        plot( bug ~ factor(get(allNames[j])), ylab = names[i])
                        points(factor(get(allNames[j])), bug)
                    }
                }
            }

            index <- index + 1
	}

    ## This should also be dynamic
    dFrame <- as.data.frame(matrix(unlist(allpvals), nrow= length(allpvals), byrow=TRUE))
    colnames(dFrame) <- unlist(allNames)
    rownames(dFrame) <- names
    orgCol <- ncol(dFrame)

    for(k in 1:(orgCol-mlm)){
        dFrame[, k + orgCol]<-p.adjust(dFrame[,k], method = "BH")
    }
    colnames(dFrame)[(orgCol + 1):length(dFrame)]<-paste0(rep("adjusted_"),colnames(dFrame)[1:(orgCol - mlm)])

    dFrame <- cbind(names, dFrame)
    ## Try and dynamically generate the name of the plot here...
    write.table(dFrame, file=paste("pValues", filePrefix, taxa, ".txt",sep=""), sep="\t",row.names=FALSE)

    ## Get the sig table working
    ## It would also be nice to have a sig-picker for the plots and a combination of all sig results into one plot.
    keepVector <- grep("adj", names(dFrame))
    sigdFrame <-dFrame[which(dFrame[,keepVector] < 0.05,arr.ind=TRUE),]
    write.table(sigdFrame, file=paste("SIGpValues", filePrefix, taxa, ".txt",sep=""), sep="\t",row.names=FALSE)

    dev.off()
}

rm(list=ls())

library("pscl")
library("lmtest")
library("nlme")
library("vegan")

setwd("/Users/mbrown67/Documents/Fodor/Datasets/MarkExperiment/Pooled/")

taxaLevels <- c( "phylum", "class", "order", "family", "genus")

filePrefix <- "_treatment_"
mlm<-FALSE


for(taxa in taxaLevels){

    inFileName <- paste( taxa, "LogNormwithMetadata_R1_Pooled.txt", sep ="")
    myT <-read.csv(inFileName,header=TRUE,sep="", na.strings="BLAH")

    numCols <- ncol(myT)
    numMetadataCols <- 20

    ## Reprocessing for correct column data type
    myColClasses <- c("character", rep("numeric", numCols - numMetadataCols - 1), rep("character", 11), "numeric", "numeric", "numeric", "character", "character", "character", "character", "character", "character")
    myT <-read.csv(inFileName, header=TRUE, sep="", colClasses=myColClasses, na.strings="BLAH", comment.char ="@")

    ## Removing unwanted samples {controls, replicates, duplicates, poor quality samples}
    removeControls<-c( "C1", "C2", "N1", "N2", "Neg", "Pos")
    myT<-myT[!(myT$Sample_ID %in% removeControls),]

    removetrs<-c("04_125_tr", "04_101_tr", "04_103_tr", "04_74_tr", "04_70_tr", "04_40_tr", "04_41_tr", "04_84_tr")
    myT<-myT[!(myT$Sample_ID %in% removetrs),]

    removeDups<-c("04-04_S63_L001_R1_001")
    myT<-myT[!(myT$MatchFile %in% removeDups),]

    ## Controls not dropped earlier
    manualDrop <- c("Neg_S40_L001_R1_001", "PCR1Neg_S65_L001_R1_001")
    myT<-myT[!(myT$MatchFile %in% manualDrop),]

    labDrop <- c("Harlan Labs")
    myT<-myT[!(myT$MouseOrigin %in% labDrop),]

    lowSeqDrop <- c("04-55_S32_L001_R1_001")
    myT<-myT[!(myT$MatchFile %in% lowSeqDrop),]
    ## Not sure what to do about this though.
    ### myT$Condition[which(myT$Treatment == "Ctrl", arr.ind = TRUE)]<-"Control"

    names <- vector()
    pValuesSex<- vector()
    pValuesAcuteChronic<- vector()
    pValuesCage<- vector()
    iccCage <- vector()
    iccKeptCounts <- vector()
    pValuesBatch<- vector()
    pValuesTreatment<- vector()
    pValuesTime <- vector()
    pValuesStressLength <- vector()
    pValuesInteraction <- vector()
    allpvals <- list()

    index <- 1
    pdf( paste(taxa, filePrefix, "boxplots.pdf", sep=""))

    for( i in 2:(ncol(myT) - numMetadataCols))
        if( sum(myT[,i] != 0 ) > nrow(myT) / 5 ){
            ## Easy access names
            bug <- myT[,i]
            ac <- myT$Condition
            sex <- myT$Sex
            cage <- myT$Cage
            batch <- myT$Sample_Plate
            date <- myT$Date
            mo <- myT$MouseOrigin
            group <- myT$SpreadsheetGrouping
            treatment <- myT$Treatment
            time <- myT$StressLength
            multiWay <- paste(ac, myT$StressLength)
            multiWay[which(myT$Treatment == "Ctrl", arr.ind = TRUE)]<-"Control"
            names[index] = names(myT)[i]
            ## Some kind of vector for the variables of interest
            myFrame <- data.frame(bug, ac, time, multiWay, sex, cage, treatment, batch, date, mo, date)
            if(mlm == TRUE){
                fullModel <- gls( bug~ treatment*time + batch, method="REML",correlation=corCompSymm(form=~1|factor(group)),	data = myFrame )
                reducedModel <- gls( bug~ treatment*time + batch, method="REML", data = myFrame )
                fullModelLME <- lme(bug~ treatment*time + batch, method="REML", random = ~1|factor(group), data = myFrame)
            }
            else{
                fullModelLME <- lm(bug~ treatment, x=TRUE)
            }
            ## Potential save time by reducing anova calls
            ## Introduce the goodness of fit tests here
            ## Can streamline vectors to be automatically responsive to changes to the model
            if(mlm == TRUE){
                allNames <- rownames(anova(fullModelLME))[-1]
                allpvals[[index]] <- anova(fullModelLME)$"p-value"[-1]
            }
            else {
                allNames <- rownames(anova(fullModelLME))[-dim(anova(fullModelLME))[1]]
                allpvals[[index]]<-as.data.frame(anova(fullModelLME))[1:dim(anova(fullModelLME))[1]-1,5]
            }

            ## Random Effects and Interclass Correlation Coefficient
            if(mlm == TRUE){
                allNames<-c(allNames, "cage", "iccCage")
                allpvals[[index]]<-c(allpvals[[index]], anova(fullModelLME, reducedModel)$"p-value"[2], coef(fullModel$modelStruct[1]$corStruct,unconstrained=FALSE)[[1]])
                pValuesCage[index] <-  anova(fullModelLME, reducedModel)$"p-value"[2]
                ## This is different as it is not corrected for multiple hypothesis testing.
                iccCage[index]<- coef(fullModel$modelStruct[1]$corStruct,unconstrained=FALSE)[[1]]
            }
    ## Nice plotting
            ## Correct so that it uses corrected p-values
            if(mlm == TRUE){
                graphMain = c(names[i], paste(c(rep("p-",length(allNames)-1),""), allNames, " = ", format(allpvals[[index]], digits=3), sep=""))
            }
            else {
                graphMain = c(names[i], paste(c(rep("p-",length(allNames)),""), allNames, " = ", format(allpvals[[index]], digits=3), sep=""))

            }

            ## mlm is boolean 1/0 value. Basically, don't graph on icc
            ## need a correction for interaction terms as well
            numPlots <- length(allNames) - mlm
            par(mfrow=c(numPlots, 1),
                oma = c(1,1,0,0) + 0.1,
                mar = c(1,4,3,0) + 0.1)

            for(j in 1:numPlots){
                if(j == 1){
                    plot( bug ~ factor(get(allNames[j])), ylab = names[i], main = c(names[index],toString(graphMain[-1])) )
                    points(factor(get(allNames[j])), bug)
                }
                else{
                    testInteract <- grep(":", allNames)
                    if(length(testInteract) > 0){
                        if(j == testInteract){
                            intSplit <- unlist(strsplit(allNames[grep(":",allNames)],split=":"))
                            plot( bug ~ factor(c( paste( get(intSplit[1]), get(intSplit[2]),sep=""))))
                            points(factor(c( paste( get(intSplit[1]), get(intSplit[2]),sep=""))), bug)
                        }
                    }
                    else{
                        plot( bug ~ factor(get(allNames[j])), ylab = names[i])
                        points(factor(get(allNames[j])), bug)
                    }
                }
            }

            index <- index + 1
	}

    ## This should also be dynamic
    dFrame <- as.data.frame(matrix(unlist(allpvals), nrow= length(allpvals), byrow=TRUE))
    colnames(dFrame) <- unlist(allNames)
    rownames(dFrame) <- names
    orgCol <- ncol(dFrame)

    for(k in 1:(orgCol-mlm)){
        dFrame[, k + orgCol]<-p.adjust(dFrame[,k], method = "BH")
    }
    colnames(dFrame)[(orgCol + 1):length(dFrame)]<-paste0(rep("adjusted_"),colnames(dFrame)[1:(orgCol - mlm)])

    dFrame <- cbind(names, dFrame)
    ## Try and dynamically generate the name of the plot here...
    write.table(dFrame, file=paste("pValues", filePrefix, taxa, ".txt",sep=""), sep="\t",row.names=FALSE)

    ## Get the sig table working
    ## It would also be nice to have a sig-picker for the plots and a combination of all sig results into one plot.
    keepVector <- grep("adj", names(dFrame))
    sigdFrame <-dFrame[which(dFrame[,keepVector] < 0.05,arr.ind=TRUE),]
    write.table(sigdFrame, file=paste("SIGpValues", filePrefix, taxa, ".txt",sep=""), sep="\t",row.names=FALSE)

    dev.off()
}

rm(list=ls())

library("pscl")
library("lmtest")
library("nlme")
library("vegan")

setwd("/Users/mbrown67/Documents/Fodor/Datasets/MarkExperiment/Pooled/")

taxaLevels <- c( "phylum", "class", "order", "family", "genus")

filePrefix <- "_treatment_"
mlm<-FALSE


for(taxa in taxaLevels){

    inFileName <- paste( taxa, "LogNormwithMetadata_R1_Pooled.txt", sep ="")
    myT <-read.csv(inFileName,header=TRUE,sep="", na.strings="BLAH")

    numCols <- ncol(myT)
    numMetadataCols <- 20

    ## Reprocessing for correct column data type
    myColClasses <- c("character", rep("numeric", numCols - numMetadataCols - 1), rep("character", 11), "numeric", "numeric", "numeric", "character", "character", "character", "character", "character", "character")
    myT <-read.csv(inFileName, header=TRUE, sep="", colClasses=myColClasses, na.strings="BLAH", comment.char ="@")

    ## Removing unwanted samples {controls, replicates, duplicates, poor quality samples}
    removeControls<-c( "C1", "C2", "N1", "N2", "Neg", "Pos")
    myT<-myT[!(myT$Sample_ID %in% removeControls),]

    removetrs<-c("04_125_tr", "04_101_tr", "04_103_tr", "04_74_tr", "04_70_tr", "04_40_tr", "04_41_tr", "04_84_tr")
    myT<-myT[!(myT$Sample_ID %in% removetrs),]

    removeDups<-c("04-04_S63_L001_R1_001")
    myT<-myT[!(myT$MatchFile %in% removeDups),]

    ## Controls not dropped earlier
    manualDrop <- c("Neg_S40_L001_R1_001", "PCR1Neg_S65_L001_R1_001")
    myT<-myT[!(myT$MatchFile %in% manualDrop),]

    labDrop <- c("Harlan Labs")
    myT<-myT[!(myT$MouseOrigin %in% labDrop),]

    lowSeqDrop <- c("04-55_S32_L001_R1_001")
    myT<-myT[!(myT$MatchFile %in% lowSeqDrop),]
    ## Not sure what to do about this though.
    ### myT$Condition[which(myT$Treatment == "Ctrl", arr.ind = TRUE)]<-"Control"

    names <- vector()
    pValuesSex<- vector()
    pValuesAcuteChronic<- vector()
    pValuesCage<- vector()
    iccCage <- vector()
    iccKeptCounts <- vector()
    pValuesBatch<- vector()
    pValuesTreatment<- vector()
    pValuesTime <- vector()
    pValuesStressLength <- vector()
    pValuesInteraction <- vector()
    allpvals <- list()

    index <- 1
    pdf( paste(taxa, filePrefix, "boxplots.pdf", sep=""))

    for( i in 2:(ncol(myT) - numMetadataCols))
        if( sum(myT[,i] != 0 ) > nrow(myT) / 6 ){
            ## Easy access names
            bug <- myT[,i]
            ac <- myT$Condition
            sex <- myT$Sex
            cage <- myT$Cage
            batch <- myT$Sample_Plate
            date <- myT$Date
            mo <- myT$MouseOrigin
            group <- myT$SpreadsheetGrouping
            treatment <- myT$Treatment
            time <- myT$StressLength
            multiWay <- paste(ac, myT$StressLength)
            multiWay[which(myT$Treatment == "Ctrl", arr.ind = TRUE)]<-"Control"
            names[index] = names(myT)[i]
            ## Some kind of vector for the variables of interest
            myFrame <- data.frame(bug, ac, time, multiWay, sex, cage, treatment, batch, date, mo, date)
            if(mlm == TRUE){
                fullModel <- gls( bug~ treatment*time + batch, method="REML",correlation=corCompSymm(form=~1|factor(group)),	data = myFrame )
                reducedModel <- gls( bug~ treatment*time + batch, method="REML", data = myFrame )
                fullModelLME <- lme(bug~ treatment*time + batch, method="REML", random = ~1|factor(group), data = myFrame)
            }
            else{
                fullModelLME <- lm(bug~ treatment, x=TRUE)
            }
            ## Potential save time by reducing anova calls
            ## Introduce the goodness of fit tests here
            ## Can streamline vectors to be automatically responsive to changes to the model
            if(mlm == TRUE){
                allNames <- rownames(anova(fullModelLME))[-1]
                allpvals[[index]] <- anova(fullModelLME)$"p-value"[-1]
            }
            else {
                allNames <- rownames(anova(fullModelLME))[-dim(anova(fullModelLME))[1]]
                allpvals[[index]]<-as.data.frame(anova(fullModelLME))[1:dim(anova(fullModelLME))[1]-1,5]
            }

            ## Random Effects and Interclass Correlation Coefficient
            if(mlm == TRUE){
                allNames<-c(allNames, "cage", "iccCage")
                allpvals[[index]]<-c(allpvals[[index]], anova(fullModelLME, reducedModel)$"p-value"[2], coef(fullModel$modelStruct[1]$corStruct,unconstrained=FALSE)[[1]])
                pValuesCage[index] <-  anova(fullModelLME, reducedModel)$"p-value"[2]
                ## This is different as it is not corrected for multiple hypothesis testing.
                iccCage[index]<- coef(fullModel$modelStruct[1]$corStruct,unconstrained=FALSE)[[1]]
            }
    ## Nice plotting
            ## Correct so that it uses corrected p-values
            if(mlm == TRUE){
                graphMain = c(names[i], paste(c(rep("p-",length(allNames)-1),""), allNames, " = ", format(allpvals[[index]], digits=3), sep=""))
            }
            else {
                graphMain = c(names[i], paste(c(rep("p-",length(allNames)),""), allNames, " = ", format(allpvals[[index]], digits=3), sep=""))

            }

            ## mlm is boolean 1/0 value. Basically, don't graph on icc
            ## need a correction for interaction terms as well
            numPlots <- length(allNames) - mlm
            par(mfrow=c(numPlots, 1),
                oma = c(1,1,0,0) + 0.1,
                mar = c(1,4,3,0) + 0.1)

            for(j in 1:numPlots){
                if(j == 1){
                    plot( bug ~ factor(get(allNames[j])), ylab = names[i], main = c(names[index],toString(graphMain[-1])) )
                    points(factor(get(allNames[j])), bug)
                }
                else{
                    testInteract <- grep(":", allNames)
                    if(length(testInteract) > 0){
                        if(j == testInteract){
                            intSplit <- unlist(strsplit(allNames[grep(":",allNames)],split=":"))
                            plot( bug ~ factor(c( paste( get(intSplit[1]), get(intSplit[2]),sep=""))))
                            points(factor(c( paste( get(intSplit[1]), get(intSplit[2]),sep=""))), bug)
                        }
                    }
                    else{
                        plot( bug ~ factor(get(allNames[j])), ylab = names[i])
                        points(factor(get(allNames[j])), bug)
                    }
                }
            }

            index <- index + 1
	}

    ## This should also be dynamic
    dFrame <- as.data.frame(matrix(unlist(allpvals), nrow= length(allpvals), byrow=TRUE))
    colnames(dFrame) <- unlist(allNames)
    rownames(dFrame) <- names
    orgCol <- ncol(dFrame)

    for(k in 1:(orgCol-mlm)){
        dFrame[, k + orgCol]<-p.adjust(dFrame[,k], method = "BH")
    }
    colnames(dFrame)[(orgCol + 1):length(dFrame)]<-paste0(rep("adjusted_"),colnames(dFrame)[1:(orgCol - mlm)])

    dFrame <- cbind(names, dFrame)
    ## Try and dynamically generate the name of the plot here...
    write.table(dFrame, file=paste("pValues", filePrefix, taxa, ".txt",sep=""), sep="\t",row.names=FALSE)

    ## Get the sig table working
    ## It would also be nice to have a sig-picker for the plots and a combination of all sig results into one plot.
    keepVector <- grep("adj", names(dFrame))
    sigdFrame <-dFrame[which(dFrame[,keepVector] < 0.05,arr.ind=TRUE),]
    write.table(sigdFrame, file=paste("SIGpValues", filePrefix, taxa, ".txt",sep=""), sep="\t",row.names=FALSE)

    dev.off()
}

boxplot(treatment~batch, data=myFrame)
treatment
batch
which(batch == "Lyte_Batch04_Run01_repeat")
length(which(batch == "Lyte_Batch04_Run01_repeat"))
length(which(batch != "Lyte_Batch04_Run01_repeat"))
which(batch == "Lyte_Batch04_Run01_repeat")
which(batch == "Lyte_Batch04_Run01_repeat") && which(treatment == "Ctrl")
which(batch == "Lyte_Batch04_Run01_repeat") %in% which(treatment == "Ctrl")
length(which(batch == "Lyte_Batch04_Run01_repeat") %in% which(treatment) == "Ctrl")
sum(which(batch == "Lyte_Batch04_Run01_repeat") %in% which(treatment) == "Ctrl")
sum(which(batch == "Lyte_Batch04_Run01_repeat") %in% which(treatment == "Ctrl"))
sum(which(batch == "Lyte_Batch04_Run01_repeat") %in% which(treatment == "Exp"))
sum(which(batch != "Lyte_Batch04_Run01_repeat") %in% which(treatment == "Exp"))
sum(which(batch != "Lyte_Batch04_Run01_repeat") %in% which(treatment == "Ctrl"))
sum(which(batch == "Lyte_Batch04_Run01_repeat") %in% which(treatment == "Ctrl") %in% which(time == 9))
sum(which(batch == "Lyte_Batch04_Run01_repeat") %in% which(treatment == "Ctrl") %in% which(time == 14))
sum(which(batch == "Lyte_Batch04_Run01_repeat") %in% which(treatment == "Ctrl") %in% which(time == 19))
sum(which(batch == "Lyte_Batch04_Run01_repeat") %in% which(treatment == "Exp") %in% which(time == 9))
sum(which(batch == "Lyte_Batch04_Run01_repeat") %in% which(treatment == "Exp") %in% which(time == 14))
sum(which(batch != "Lyte_Batch04_Run01_repeat") %in% which(treatment == "Ctrl") %in% which(time == 9))
sum(which(batch != "Lyte_Batch04_Run01_repeat") %in% which(treatment == "Ctrl") %in% which(time == 14))
sum(which(batch != "Lyte_Batch04_Run01_repeat") %in% which(treatment == "Ctrl") %in% which(time == 19))
time
myT$Sample_Plate[which(myT$Treatment == "Ctrl", arr.ind= TRUE),]
myT$Sample_Plate[which(myT$Treatment == "Ctrl", arr.ind= TRUE)]
which(myT$Sample_Plate[which(myT$Treatment == "Ctrl", arr.ind= TRUE)] == "Lyte_Batch04_Run01_repeat")
which(myT$Sample_Plate[which(myT$Treatment == "Ctrl", arr.ind= TRUE) && which(myT$StressLength == 9)] == "Lyte_Batch04_Run01_repeat")
which(myT$Sample_Plate[which(myT$Treatment == "Ctrl", arr.ind= TRUE) && which(myT$StressLength == 9, arr.ind = TRUE)] == "Lyte_Batch04_Run01_repeat")
length(which(myT$Sample_Plate[which(myT$Treatment == "Ctrl", arr.ind= TRUE) && which(myT$StressLength == 9, arr.ind = TRUE)] == "Lyte_Batch04_Run01_repeat"))
myT[myT$Treatment == "Ctrl" & myT$StressLength == 9 & myT$Sample_Plate == "Lyte_Batch04_Run01_repeat",]
length(myT[myT$Treatment == "Ctrl" & myT$StressLength == 9 & myT$Sample_Plate == "Lyte_Batch04_Run01_repeat",])
dim(myT[myT$Treatment == "Ctrl" & myT$StressLength == 9 & myT$Sample_Plate == "Lyte_Batch04_Run01_repeat",])
dim(myT[myT$Treatment == "Ctrl" & myT$StressLength == 9 & myT$Sample_Plate != "Lyte_Batch04_Run01_repeat",])
dim(myT[myT$Treatment == "Ctrl" & myT$StressLength == 14 & myT$Sample_Plate == "Lyte_Batch04_Run01_repeat",])
dim(myT[myT$Treatment == "Ctrl" & myT$StressLength == 14 & myT$Sample_Plate != "Lyte_Batch04_Run01_repeat",])
dim(myT[myT$Treatment == "Ctrl" & myT$StressLength == 19 & myT$Sample_Plate == "Lyte_Batch04_Run01_repeat",])
dim(myT[myT$Treatment == "Ctrl" & myT$StressLength == 19 & myT$Sample_Plate != "Lyte_Batch04_Run01_repeat",])
dim(myT[myT$Treatment == "Exp" & myT$StressLength == 9 & myT$Sample_Plate == "Lyte_Batch04_Run01_repeat",])
dim(myT[myT$Treatment == "Exp" & myT$StressLength == 9 & myT$Sample_Plate != "Lyte_Batch04_Run01_repeat",])
dim(myT[myT$Treatment == "Exp" & myT$StressLength == 14 & myT$Sample_Plate == "Lyte_Batch04_Run01_repeat",])
dim(myT[myT$Treatment == "Exp" & myT$StressLength == 14 & myT$Sample_Plate != "Lyte_Batch04_Run01_repeat",])
dim(myT[myT$Treatment == "Exp" & myT$StressLength == 19 & myT$Sample_Plate == "Lyte_Batch04_Run01_repeat",])
dim(myT[myT$Treatment == "Exp" & myT$StressLength == 19 & myT$Sample_Plate != "Lyte_Batch04_Run01_repeat",])
rm(list=ls())

library("pscl")
library("lmtest")
library("nlme")
library("vegan")

setwd("/Users/mbrown67/Documents/Fodor/Datasets/MarkExperiment/Pooled/")

taxaLevels <- c( "phylum", "class", "order", "family", "genus")

filePrefix <- "_treatment*batch_"
mlm<-FALSE


for(taxa in taxaLevels){

    inFileName <- paste( taxa, "LogNormwithMetadata_R1_Pooled.txt", sep ="")
    myT <-read.csv(inFileName,header=TRUE,sep="", na.strings="BLAH")

    numCols <- ncol(myT)
    numMetadataCols <- 20

    ## Reprocessing for correct column data type
    myColClasses <- c("character", rep("numeric", numCols - numMetadataCols - 1), rep("character", 11), "numeric", "numeric", "numeric", "character", "character", "character", "character", "character", "character")
    myT <-read.csv(inFileName, header=TRUE, sep="", colClasses=myColClasses, na.strings="BLAH", comment.char ="@")

    ## Removing unwanted samples {controls, replicates, duplicates, poor quality samples}
    removeControls<-c( "C1", "C2", "N1", "N2", "Neg", "Pos")
    myT<-myT[!(myT$Sample_ID %in% removeControls),]

    removetrs<-c("04_125_tr", "04_101_tr", "04_103_tr", "04_74_tr", "04_70_tr", "04_40_tr", "04_41_tr", "04_84_tr")
    myT<-myT[!(myT$Sample_ID %in% removetrs),]

    removeDups<-c("04-04_S63_L001_R1_001")
    myT<-myT[!(myT$MatchFile %in% removeDups),]

    ## Controls not dropped earlier
    manualDrop <- c("Neg_S40_L001_R1_001", "PCR1Neg_S65_L001_R1_001")
    myT<-myT[!(myT$MatchFile %in% manualDrop),]

    labDrop <- c("Harlan Labs")
    myT<-myT[!(myT$MouseOrigin %in% labDrop),]

    lowSeqDrop <- c("04-55_S32_L001_R1_001")
    myT<-myT[!(myT$MatchFile %in% lowSeqDrop),]
    ## Not sure what to do about this though.
    ### myT$Condition[which(myT$Treatment == "Ctrl", arr.ind = TRUE)]<-"Control"

    names <- vector()
    pValuesSex<- vector()
    pValuesAcuteChronic<- vector()
    pValuesCage<- vector()
    iccCage <- vector()
    iccKeptCounts <- vector()
    pValuesBatch<- vector()
    pValuesTreatment<- vector()
    pValuesTime <- vector()
    pValuesStressLength <- vector()
    pValuesInteraction <- vector()
    allpvals <- list()

    index <- 1
    pdf( paste(taxa, filePrefix, "boxplots.pdf", sep=""))

    for( i in 2:(ncol(myT) - numMetadataCols))
        if( sum(myT[,i] != 0 ) > nrow(myT) / 4 ){
            ## Easy access names
            bug <- myT[,i]
            ac <- myT$Condition
            sex <- myT$Sex
            cage <- myT$Cage
            batch <- myT$Sample_Plate
            date <- myT$Date
            mo <- myT$MouseOrigin
            group <- myT$SpreadsheetGrouping
            treatment <- myT$Treatment
            time <- myT$StressLength
            multiWay <- paste(ac, myT$StressLength)
            multiWay[which(myT$Treatment == "Ctrl", arr.ind = TRUE)]<-"Control"
            names[index] = names(myT)[i]
            ## Some kind of vector for the variables of interest
            myFrame <- data.frame(bug, ac, time, multiWay, sex, cage, treatment, batch, date, mo, date)
            if(mlm == TRUE){
                fullModel <- gls( bug~ treatment*batch, method="REML",correlation=corCompSymm(form=~1|factor(group)),	data = myFrame )
                reducedModel <- gls( bug~ treatment*batch, method="REML", data = myFrame )
                fullModelLME <- lme(bug~ treatment*time + batch, method="REML", random = ~1|factor(group), data = myFrame)
            }
            else{
                fullModelLME <- lm(bug~ treatment*batch, x=TRUE)
            }
            ## Potential save time by reducing anova calls
            ## Introduce the goodness of fit tests here
            ## Can streamline vectors to be automatically responsive to changes to the model
            if(mlm == TRUE){
                allNames <- rownames(anova(fullModelLME))[-1]
                allpvals[[index]] <- anova(fullModelLME)$"p-value"[-1]
            }
            else {
                allNames <- rownames(anova(fullModelLME))[-dim(anova(fullModelLME))[1]]
                allpvals[[index]]<-as.data.frame(anova(fullModelLME))[1:dim(anova(fullModelLME))[1]-1,5]
            }

            ## Random Effects and Interclass Correlation Coefficient
            if(mlm == TRUE){
                allNames<-c(allNames, "cage", "iccCage")
                allpvals[[index]]<-c(allpvals[[index]], anova(fullModelLME, reducedModel)$"p-value"[2], coef(fullModel$modelStruct[1]$corStruct,unconstrained=FALSE)[[1]])
                pValuesCage[index] <-  anova(fullModelLME, reducedModel)$"p-value"[2]
                ## This is different as it is not corrected for multiple hypothesis testing.
                iccCage[index]<- coef(fullModel$modelStruct[1]$corStruct,unconstrained=FALSE)[[1]]
            }
    ## Nice plotting
            ## Correct so that it uses corrected p-values
            if(mlm == TRUE){
                graphMain = c(names[i], paste(c(rep("p-",length(allNames)-1),""), allNames, " = ", format(allpvals[[index]], digits=3), sep=""))
            }
            else {
                graphMain = c(names[i], paste(c(rep("p-",length(allNames)),""), allNames, " = ", format(allpvals[[index]], digits=3), sep=""))

            }

            ## mlm is boolean 1/0 value. Basically, don't graph on icc
            ## need a correction for interaction terms as well
            numPlots <- length(allNames) - mlm
            par(mfrow=c(numPlots, 1),
                oma = c(1,1,0,0) + 0.1,
                mar = c(1,4,3,0) + 0.1)

            for(j in 1:numPlots){
                if(j == 1){
                    plot( bug ~ factor(get(allNames[j])), ylab = names[i], main = c(names[index],toString(graphMain[-1])) )
                    points(factor(get(allNames[j])), bug)
                }
                else{
                    testInteract <- grep(":", allNames)
                    if(length(testInteract) > 0){
                        if(j == testInteract){
                            intSplit <- unlist(strsplit(allNames[grep(":",allNames)],split=":"))
                            plot( bug ~ factor(c( paste( get(intSplit[1]), get(intSplit[2]),sep=""))))
                            points(factor(c( paste( get(intSplit[1]), get(intSplit[2]),sep=""))), bug)
                        }
                    }
                    else{
                        plot( bug ~ factor(get(allNames[j])), ylab = names[i])
                        points(factor(get(allNames[j])), bug)
                    }
                }
            }

            index <- index + 1
	}

    ## This should also be dynamic
    dFrame <- as.data.frame(matrix(unlist(allpvals), nrow= length(allpvals), byrow=TRUE))
    colnames(dFrame) <- unlist(allNames)
    rownames(dFrame) <- names
    orgCol <- ncol(dFrame)

    for(k in 1:(orgCol-mlm)){
        dFrame[, k + orgCol]<-p.adjust(dFrame[,k], method = "BH")
    }
    colnames(dFrame)[(orgCol + 1):length(dFrame)]<-paste0(rep("adjusted_"),colnames(dFrame)[1:(orgCol - mlm)])

    dFrame <- cbind(names, dFrame)
    ## Try and dynamically generate the name of the plot here...
    write.table(dFrame, file=paste("pValues", filePrefix, taxa, ".txt",sep=""), sep="\t",row.names=FALSE)

    ## Get the sig table working
    ## It would also be nice to have a sig-picker for the plots and a combination of all sig results into one plot.
    keepVector <- grep("adj", names(dFrame))
    sigdFrame <-dFrame[which(dFrame[,keepVector] < 0.05,arr.ind=TRUE),]
    write.table(sigdFrame, file=paste("SIGpValues", filePrefix, taxa, ".txt",sep=""), sep="\t",row.names=FALSE)

    dev.off()
}

rm(list=ls())

library("pscl")
library("lmtest")
library("nlme")
library("vegan")

setwd("/Users/mbrown67/Documents/Fodor/Datasets/MarkExperiment/Pooled/")

taxaLevels <- c( "phylum", "class", "order", "family", "genus")

filePrefix <- "_time*batch_"
mlm<-FALSE


for(taxa in taxaLevels){

    inFileName <- paste( taxa, "LogNormwithMetadata_R1_Pooled.txt", sep ="")
    myT <-read.csv(inFileName,header=TRUE,sep="", na.strings="BLAH")

    numCols <- ncol(myT)
    numMetadataCols <- 20

    ## Reprocessing for correct column data type
    myColClasses <- c("character", rep("numeric", numCols - numMetadataCols - 1), rep("character", 11), "numeric", "numeric", "numeric", "character", "character", "character", "character", "character", "character")
    myT <-read.csv(inFileName, header=TRUE, sep="", colClasses=myColClasses, na.strings="BLAH", comment.char ="@")

    ## Removing unwanted samples {controls, replicates, duplicates, poor quality samples}
    removeControls<-c( "C1", "C2", "N1", "N2", "Neg", "Pos")
    myT<-myT[!(myT$Sample_ID %in% removeControls),]

    removetrs<-c("04_125_tr", "04_101_tr", "04_103_tr", "04_74_tr", "04_70_tr", "04_40_tr", "04_41_tr", "04_84_tr")
    myT<-myT[!(myT$Sample_ID %in% removetrs),]

    removeDups<-c("04-04_S63_L001_R1_001")
    myT<-myT[!(myT$MatchFile %in% removeDups),]

    ## Controls not dropped earlier
    manualDrop <- c("Neg_S40_L001_R1_001", "PCR1Neg_S65_L001_R1_001")
    myT<-myT[!(myT$MatchFile %in% manualDrop),]

    labDrop <- c("Harlan Labs")
    myT<-myT[!(myT$MouseOrigin %in% labDrop),]

    lowSeqDrop <- c("04-55_S32_L001_R1_001")
    myT<-myT[!(myT$MatchFile %in% lowSeqDrop),]
    ## Not sure what to do about this though.
    ### myT$Condition[which(myT$Treatment == "Ctrl", arr.ind = TRUE)]<-"Control"

    names <- vector()
    pValuesSex<- vector()
    pValuesAcuteChronic<- vector()
    pValuesCage<- vector()
    iccCage <- vector()
    iccKeptCounts <- vector()
    pValuesBatch<- vector()
    pValuesTreatment<- vector()
    pValuesTime <- vector()
    pValuesStressLength <- vector()
    pValuesInteraction <- vector()
    allpvals <- list()

    index <- 1
    pdf( paste(taxa, filePrefix, "boxplots.pdf", sep=""))

    for( i in 2:(ncol(myT) - numMetadataCols))
        if( sum(myT[,i] != 0 ) > nrow(myT) / 4 ){
            ## Easy access names
            bug <- myT[,i]
            ac <- myT$Condition
            sex <- myT$Sex
            cage <- myT$Cage
            batch <- myT$Sample_Plate
            date <- myT$Date
            mo <- myT$MouseOrigin
            group <- myT$SpreadsheetGrouping
            treatment <- myT$Treatment
            time <- myT$StressLength
            multiWay <- paste(ac, myT$StressLength)
            multiWay[which(myT$Treatment == "Ctrl", arr.ind = TRUE)]<-"Control"
            names[index] = names(myT)[i]
            ## Some kind of vector for the variables of interest
            myFrame <- data.frame(bug, ac, time, multiWay, sex, cage, treatment, batch, date, mo, date)
            if(mlm == TRUE){
                fullModel <- gls( bug~ treatment*batch, method="REML",correlation=corCompSymm(form=~1|factor(group)),	data = myFrame )
                reducedModel <- gls( bug~ treatment*batch, method="REML", data = myFrame )
                fullModelLME <- lme(bug~ treatment*time + batch, method="REML", random = ~1|factor(group), data = myFrame)
            }
            else{
                fullModelLME <- lm(bug~ time*batch, x=TRUE)
            }
            ## Potential save time by reducing anova calls
            ## Introduce the goodness of fit tests here
            ## Can streamline vectors to be automatically responsive to changes to the model
            if(mlm == TRUE){
                allNames <- rownames(anova(fullModelLME))[-1]
                allpvals[[index]] <- anova(fullModelLME)$"p-value"[-1]
            }
            else {
                allNames <- rownames(anova(fullModelLME))[-dim(anova(fullModelLME))[1]]
                allpvals[[index]]<-as.data.frame(anova(fullModelLME))[1:dim(anova(fullModelLME))[1]-1,5]
            }

            ## Random Effects and Interclass Correlation Coefficient
            if(mlm == TRUE){
                allNames<-c(allNames, "cage", "iccCage")
                allpvals[[index]]<-c(allpvals[[index]], anova(fullModelLME, reducedModel)$"p-value"[2], coef(fullModel$modelStruct[1]$corStruct,unconstrained=FALSE)[[1]])
                pValuesCage[index] <-  anova(fullModelLME, reducedModel)$"p-value"[2]
                ## This is different as it is not corrected for multiple hypothesis testing.
                iccCage[index]<- coef(fullModel$modelStruct[1]$corStruct,unconstrained=FALSE)[[1]]
            }
    ## Nice plotting
            ## Correct so that it uses corrected p-values
            if(mlm == TRUE){
                graphMain = c(names[i], paste(c(rep("p-",length(allNames)-1),""), allNames, " = ", format(allpvals[[index]], digits=3), sep=""))
            }
            else {
                graphMain = c(names[i], paste(c(rep("p-",length(allNames)),""), allNames, " = ", format(allpvals[[index]], digits=3), sep=""))

            }

            ## mlm is boolean 1/0 value. Basically, don't graph on icc
            ## need a correction for interaction terms as well
            numPlots <- length(allNames) - mlm
            par(mfrow=c(numPlots, 1),
                oma = c(1,1,0,0) + 0.1,
                mar = c(1,4,3,0) + 0.1)

            for(j in 1:numPlots){
                if(j == 1){
                    plot( bug ~ factor(get(allNames[j])), ylab = names[i], main = c(names[index],toString(graphMain[-1])) )
                    points(factor(get(allNames[j])), bug)
                }
                else{
                    testInteract <- grep(":", allNames)
                    if(length(testInteract) > 0){
                        if(j == testInteract){
                            intSplit <- unlist(strsplit(allNames[grep(":",allNames)],split=":"))
                            plot( bug ~ factor(c( paste( get(intSplit[1]), get(intSplit[2]),sep=""))))
                            points(factor(c( paste( get(intSplit[1]), get(intSplit[2]),sep=""))), bug)
                        }
                    }
                    else{
                        plot( bug ~ factor(get(allNames[j])), ylab = names[i])
                        points(factor(get(allNames[j])), bug)
                    }
                }
            }

            index <- index + 1
	}

    ## This should also be dynamic
    dFrame <- as.data.frame(matrix(unlist(allpvals), nrow= length(allpvals), byrow=TRUE))
    colnames(dFrame) <- unlist(allNames)
    rownames(dFrame) <- names
    orgCol <- ncol(dFrame)

    for(k in 1:(orgCol-mlm)){
        dFrame[, k + orgCol]<-p.adjust(dFrame[,k], method = "BH")
    }
    colnames(dFrame)[(orgCol + 1):length(dFrame)]<-paste0(rep("adjusted_"),colnames(dFrame)[1:(orgCol - mlm)])

    dFrame <- cbind(names, dFrame)
    ## Try and dynamically generate the name of the plot here...
    write.table(dFrame, file=paste("pValues", filePrefix, taxa, ".txt",sep=""), sep="\t",row.names=FALSE)

    ## Get the sig table working
    ## It would also be nice to have a sig-picker for the plots and a combination of all sig results into one plot.
    keepVector <- grep("adj", names(dFrame))
    sigdFrame <-dFrame[which(dFrame[,keepVector] < 0.05,arr.ind=TRUE),]
    write.table(sigdFrame, file=paste("SIGpValues", filePrefix, taxa, ".txt",sep=""), sep="\t",row.names=FALSE)

    dev.off()
}

allNames
strsplit(allNames[3], split=":")
rm(list=ls())

library("pscl")
library("lmtest")
library("nlme")
library("vegan")

setwd("/Users/mbrown67/Documents/Fodor/Datasets/MarkExperiment/Pooled/")

taxaLevels <- c( "phylum", "class", "order", "family", "genus")

filePrefix <- "_treatment*time*batch_"
mlm<-FALSE


for(taxa in taxaLevels){

    inFileName <- paste( taxa, "LogNormwithMetadata_R1_Pooled.txt", sep ="")
    myT <-read.csv(inFileName,header=TRUE,sep="", na.strings="BLAH")

    numCols <- ncol(myT)
    numMetadataCols <- 20

    ## Reprocessing for correct column data type
    myColClasses <- c("character", rep("numeric", numCols - numMetadataCols - 1), rep("character", 11), "numeric", "numeric", "numeric", "character", "character", "character", "character", "character", "character")
    myT <-read.csv(inFileName, header=TRUE, sep="", colClasses=myColClasses, na.strings="BLAH", comment.char ="@")

    ## Removing unwanted samples {controls, replicates, duplicates, poor quality samples}
    removeControls<-c( "C1", "C2", "N1", "N2", "Neg", "Pos")
    myT<-myT[!(myT$Sample_ID %in% removeControls),]

    removetrs<-c("04_125_tr", "04_101_tr", "04_103_tr", "04_74_tr", "04_70_tr", "04_40_tr", "04_41_tr", "04_84_tr")
    myT<-myT[!(myT$Sample_ID %in% removetrs),]

    removeDups<-c("04-04_S63_L001_R1_001")
    myT<-myT[!(myT$MatchFile %in% removeDups),]

    ## Controls not dropped earlier
    manualDrop <- c("Neg_S40_L001_R1_001", "PCR1Neg_S65_L001_R1_001")
    myT<-myT[!(myT$MatchFile %in% manualDrop),]

    labDrop <- c("Harlan Labs")
    myT<-myT[!(myT$MouseOrigin %in% labDrop),]

    lowSeqDrop <- c("04-55_S32_L001_R1_001")
    myT<-myT[!(myT$MatchFile %in% lowSeqDrop),]
    ## Not sure what to do about this though.
    ### myT$Condition[which(myT$Treatment == "Ctrl", arr.ind = TRUE)]<-"Control"

    names <- vector()
    pValuesSex<- vector()
    pValuesAcuteChronic<- vector()
    pValuesCage<- vector()
    iccCage <- vector()
    iccKeptCounts <- vector()
    pValuesBatch<- vector()
    pValuesTreatment<- vector()
    pValuesTime <- vector()
    pValuesStressLength <- vector()
    pValuesInteraction <- vector()
    allpvals <- list()

    index <- 1
    pdf( paste(taxa, filePrefix, "boxplots.pdf", sep=""))

    for( i in 2:(ncol(myT) - numMetadataCols))
        if( sum(myT[,i] != 0 ) > nrow(myT) / 4 ){
            ## Easy access names
            bug <- myT[,i]
            ac <- myT$Condition
            sex <- myT$Sex
            cage <- myT$Cage
            batch <- myT$Sample_Plate
            date <- myT$Date
            mo <- myT$MouseOrigin
            group <- myT$SpreadsheetGrouping
            treatment <- myT$Treatment
            time <- myT$StressLength
            multiWay <- paste(ac, myT$StressLength)
            multiWay[which(myT$Treatment == "Ctrl", arr.ind = TRUE)]<-"Control"
            names[index] = names(myT)[i]
            ## Some kind of vector for the variables of interest
            myFrame <- data.frame(bug, ac, time, multiWay, sex, cage, treatment, batch, date, mo, date)
            if(mlm == TRUE){
                fullModel <- gls( bug~ treatment*batch, method="REML",correlation=corCompSymm(form=~1|factor(group)),	data = myFrame )
                reducedModel <- gls( bug~ treatment*batch, method="REML", data = myFrame )
                fullModelLME <- lme(bug~ treatment*time + batch, method="REML", random = ~1|factor(group), data = myFrame)
            }
            else{
                fullModelLME <- lm(bug~ treatment*time*batch, x=TRUE)
            }
            ## Potential save time by reducing anova calls
            ## Introduce the goodness of fit tests here
            ## Can streamline vectors to be automatically responsive to changes to the model
            if(mlm == TRUE){
                allNames <- rownames(anova(fullModelLME))[-1]
                allpvals[[index]] <- anova(fullModelLME)$"p-value"[-1]
            }
            else {
                allNames <- rownames(anova(fullModelLME))[-dim(anova(fullModelLME))[1]]
                allpvals[[index]]<-as.data.frame(anova(fullModelLME))[1:dim(anova(fullModelLME))[1]-1,5]
            }

            ## Random Effects and Interclass Correlation Coefficient
            if(mlm == TRUE){
                allNames<-c(allNames, "cage", "iccCage")
                allpvals[[index]]<-c(allpvals[[index]], anova(fullModelLME, reducedModel)$"p-value"[2], coef(fullModel$modelStruct[1]$corStruct,unconstrained=FALSE)[[1]])
                pValuesCage[index] <-  anova(fullModelLME, reducedModel)$"p-value"[2]
                ## This is different as it is not corrected for multiple hypothesis testing.
                iccCage[index]<- coef(fullModel$modelStruct[1]$corStruct,unconstrained=FALSE)[[1]]
            }
    ## Nice plotting
            ## Correct so that it uses corrected p-values
            if(mlm == TRUE){
                graphMain = c(names[i], paste(c(rep("p-",length(allNames)-1),""), allNames, " = ", format(allpvals[[index]], digits=3), sep=""))
            }
            else {
                graphMain = c(names[i], paste(c(rep("p-",length(allNames)),""), allNames, " = ", format(allpvals[[index]], digits=3), sep=""))

            }

            ## mlm is boolean 1/0 value. Basically, don't graph on icc
            ## need a correction for interaction terms as well
            numPlots <- length(allNames) - mlm
            par(mfrow=c(numPlots, 1),
                oma = c(1,1,0,0) + 0.1,
                mar = c(1,4,3,0) + 0.1)

            for(j in 1:numPlots){
                if(j == 1){
                    plot( bug ~ factor(get(allNames[j])), ylab = names[i], main = c(names[index],toString(graphMain[-1])) )
                    points(factor(get(allNames[j])), bug)
                }
                else{
                    testInteract <- grep(":", allNames)
                    if(length(testInteract) > 0){
                        for(j %in% testInteract){
                            intSplit <- unlist(strsplit(allNames[grep(":",allNames)],split=":"))
                            if(length(intSplit) == 2){
                                plot( bug ~ factor(c( paste( get(intSplit[1]), get(intSplit[2]),sep=""))))
                                points(factor(c( paste( get(intSplit[1]), get(intSplit[2]),sep=""))), bug)
                            }
                            else{
                                plot( bug ~ factor(c( paste( get(intSplit[1]), get(intSplit[2]), get(intSplit[3]),sep=""))))
                                points(factor(c( paste( get(intSplit[1]), get(intSplit[2]), get(intSplit[3]),sep=""))), bug)
                            }
                        }
                    }
                    else{
                        plot( bug ~ factor(get(allNames[j])), ylab = names[i])
                        points(factor(get(allNames[j])), bug)
                    }
                }
            }

            index <- index + 1
	}

    ## This should also be dynamic
    dFrame <- as.data.frame(matrix(unlist(allpvals), nrow= length(allpvals), byrow=TRUE))
    colnames(dFrame) <- unlist(allNames)
    rownames(dFrame) <- names
    orgCol <- ncol(dFrame)

    for(k in 1:(orgCol-mlm)){
        dFrame[, k + orgCol]<-p.adjust(dFrame[,k], method = "BH")
    }
    colnames(dFrame)[(orgCol + 1):length(dFrame)]<-paste0(rep("adjusted_"),colnames(dFrame)[1:(orgCol - mlm)])

    dFrame <- cbind(names, dFrame)
    ## Try and dynamically generate the name of the plot here...
    write.table(dFrame, file=paste("pValues", filePrefix, taxa, ".txt",sep=""), sep="\t",row.names=FALSE)

    ## Get the sig table working
    ## It would also be nice to have a sig-picker for the plots and a combination of all sig results into one plot.
    keepVector <- grep("adj", names(dFrame))
    sigdFrame <-dFrame[which(dFrame[,keepVector] < 0.05,arr.ind=TRUE),]
    write.table(sigdFrame, file=paste("SIGpValues", filePrefix, taxa, ".txt",sep=""), sep="\t",row.names=FALSE)

    dev.off()
}

testInteract
rm(list=ls())

library("pscl")
library("lmtest")
library("nlme")
library("vegan")

setwd("/Users/mbrown67/Documents/Fodor/Datasets/MarkExperiment/Pooled/")

taxaLevels <- c( "phylum", "class", "order", "family", "genus")

filePrefix <- "_treatment*time*batch_"
mlm<-FALSE


for(taxa in taxaLevels){

    inFileName <- paste( taxa, "LogNormwithMetadata_R1_Pooled.txt", sep ="")
    myT <-read.csv(inFileName,header=TRUE,sep="", na.strings="BLAH")

    numCols <- ncol(myT)
    numMetadataCols <- 20

    ## Reprocessing for correct column data type
    myColClasses <- c("character", rep("numeric", numCols - numMetadataCols - 1), rep("character", 11), "numeric", "numeric", "numeric", "character", "character", "character", "character", "character", "character")
    myT <-read.csv(inFileName, header=TRUE, sep="", colClasses=myColClasses, na.strings="BLAH", comment.char ="@")

    ## Removing unwanted samples {controls, replicates, duplicates, poor quality samples}
    removeControls<-c( "C1", "C2", "N1", "N2", "Neg", "Pos")
    myT<-myT[!(myT$Sample_ID %in% removeControls),]

    removetrs<-c("04_125_tr", "04_101_tr", "04_103_tr", "04_74_tr", "04_70_tr", "04_40_tr", "04_41_tr", "04_84_tr")
    myT<-myT[!(myT$Sample_ID %in% removetrs),]

    removeDups<-c("04-04_S63_L001_R1_001")
    myT<-myT[!(myT$MatchFile %in% removeDups),]

    ## Controls not dropped earlier
    manualDrop <- c("Neg_S40_L001_R1_001", "PCR1Neg_S65_L001_R1_001")
    myT<-myT[!(myT$MatchFile %in% manualDrop),]

    labDrop <- c("Harlan Labs")
    myT<-myT[!(myT$MouseOrigin %in% labDrop),]

    lowSeqDrop <- c("04-55_S32_L001_R1_001")
    myT<-myT[!(myT$MatchFile %in% lowSeqDrop),]
    ## Not sure what to do about this though.
    ### myT$Condition[which(myT$Treatment == "Ctrl", arr.ind = TRUE)]<-"Control"

    names <- vector()
    pValuesSex<- vector()
    pValuesAcuteChronic<- vector()
    pValuesCage<- vector()
    iccCage <- vector()
    iccKeptCounts <- vector()
    pValuesBatch<- vector()
    pValuesTreatment<- vector()
    pValuesTime <- vector()
    pValuesStressLength <- vector()
    pValuesInteraction <- vector()
    allpvals <- list()

    index <- 1
    pdf( paste(taxa, filePrefix, "boxplots.pdf", sep=""))

    for( i in 2:(ncol(myT) - numMetadataCols))
        if( sum(myT[,i] != 0 ) > nrow(myT) / 4 ){
            ## Easy access names
            bug <- myT[,i]
            ac <- myT$Condition
            sex <- myT$Sex
            cage <- myT$Cage
            batch <- myT$Sample_Plate
            date <- myT$Date
            mo <- myT$MouseOrigin
            group <- myT$SpreadsheetGrouping
            treatment <- myT$Treatment
            time <- myT$StressLength
            multiWay <- paste(ac, myT$StressLength)
            multiWay[which(myT$Treatment == "Ctrl", arr.ind = TRUE)]<-"Control"
            names[index] = names(myT)[i]
            ## Some kind of vector for the variables of interest
            myFrame <- data.frame(bug, ac, time, multiWay, sex, cage, treatment, batch, date, mo, date)
            if(mlm == TRUE){
                fullModel <- gls( bug~ treatment*batch, method="REML",correlation=corCompSymm(form=~1|factor(group)),	data = myFrame )
                reducedModel <- gls( bug~ treatment*batch, method="REML", data = myFrame )
                fullModelLME <- lme(bug~ treatment*time + batch, method="REML", random = ~1|factor(group), data = myFrame)
            }
            else{
                fullModelLME <- lm(bug~ treatment*time*batch, x=TRUE)
            }
            ## Potential save time by reducing anova calls
            ## Introduce the goodness of fit tests here
            ## Can streamline vectors to be automatically responsive to changes to the model
            if(mlm == TRUE){
                allNames <- rownames(anova(fullModelLME))[-1]
                allpvals[[index]] <- anova(fullModelLME)$"p-value"[-1]
            }
            else {
                allNames <- rownames(anova(fullModelLME))[-dim(anova(fullModelLME))[1]]
                allpvals[[index]]<-as.data.frame(anova(fullModelLME))[1:dim(anova(fullModelLME))[1]-1,5]
            }

            ## Random Effects and Interclass Correlation Coefficient
            if(mlm == TRUE){
                allNames<-c(allNames, "cage", "iccCage")
                allpvals[[index]]<-c(allpvals[[index]], anova(fullModelLME, reducedModel)$"p-value"[2], coef(fullModel$modelStruct[1]$corStruct,unconstrained=FALSE)[[1]])
                pValuesCage[index] <-  anova(fullModelLME, reducedModel)$"p-value"[2]
                ## This is different as it is not corrected for multiple hypothesis testing.
                iccCage[index]<- coef(fullModel$modelStruct[1]$corStruct,unconstrained=FALSE)[[1]]
            }
    ## Nice plotting
            ## Correct so that it uses corrected p-values
            if(mlm == TRUE){
                graphMain = c(names[i], paste(c(rep("p-",length(allNames)-1),""), allNames, " = ", format(allpvals[[index]], digits=3), sep=""))
            }
            else {
                graphMain = c(names[i], paste(c(rep("p-",length(allNames)),""), allNames, " = ", format(allpvals[[index]], digits=3), sep=""))

            }

            ## mlm is boolean 1/0 value. Basically, don't graph on icc
            ## need a correction for interaction terms as well
            numPlots <- length(allNames) - mlm
            par(mfrow=c(numPlots, 1),
                oma = c(1,1,0,0) + 0.1,
                mar = c(1,4,3,0) + 0.1)

            for(j in 1:numPlots){
                if(j == 1){
                    plot( bug ~ factor(get(allNames[j])), ylab = names[i], main = c(names[index],toString(graphMain[-1])) )
                    points(factor(get(allNames[j])), bug)
                }
                else{
                    testInteract <- grep(":", allNames)
                    if(length(testInteract) > 0){
                        for(j %in% testInteract){
                            intSplit <- unlist(strsplit(allNames[grep(":",allNames)[j]],split=":"))
                            if(length(intSplit) == 2){
                                plot( bug ~ factor(c( paste( get(intSplit[1]), get(intSplit[2]),sep=""))))
                                points(factor(c( paste( get(intSplit[1]), get(intSplit[2]),sep=""))), bug)
                            }
                            else{
                                plot( bug ~ factor(c( paste( get(intSplit[1]), get(intSplit[2]), get(intSplit[3]),sep=""))))
                                points(factor(c( paste( get(intSplit[1]), get(intSplit[2]), get(intSplit[3]),sep=""))), bug)
                            }
                        }
                    }
                    else{
                        plot( bug ~ factor(get(allNames[j])), ylab = names[i])
                        points(factor(get(allNames[j])), bug)
                    }
                }
            }

            index <- index + 1
	}

    ## This should also be dynamic
    dFrame <- as.data.frame(matrix(unlist(allpvals), nrow= length(allpvals), byrow=TRUE))
    colnames(dFrame) <- unlist(allNames)
    rownames(dFrame) <- names
    orgCol <- ncol(dFrame)

    for(k in 1:(orgCol-mlm)){
        dFrame[, k + orgCol]<-p.adjust(dFrame[,k], method = "BH")
    }
    colnames(dFrame)[(orgCol + 1):length(dFrame)]<-paste0(rep("adjusted_"),colnames(dFrame)[1:(orgCol - mlm)])

    dFrame <- cbind(names, dFrame)
    ## Try and dynamically generate the name of the plot here...
    write.table(dFrame, file=paste("pValues", filePrefix, taxa, ".txt",sep=""), sep="\t",row.names=FALSE)

    ## Get the sig table working
    ## It would also be nice to have a sig-picker for the plots and a combination of all sig results into one plot.
    keepVector <- grep("adj", names(dFrame))
    sigdFrame <-dFrame[which(dFrame[,keepVector] < 0.05,arr.ind=TRUE),]
    write.table(sigdFrame, file=paste("SIGpValues", filePrefix, taxa, ".txt",sep=""), sep="\t",row.names=FALSE)

    dev.off()
}

anova(fullModelLME)
ls()
testInteract <- c("treatment", "time", "batch", "treatment:time", "treatment:batch", "time:batch", "treatment:time:batch")
new <- grep(":", testInteract)
new
for( i %in% new){
for(i in new){
i <- 4
}
i
if(i %in% new){print("Yes")}
rm(list=ls())

library("pscl")
library("lmtest")
library("nlme")
library("vegan")

setwd("/Users/mbrown67/Documents/Fodor/Datasets/MarkExperiment/Pooled/")

taxaLevels <- c( "phylum", "class", "order", "family", "genus")

filePrefix <- "_treatment*time*batch_"
mlm<-FALSE


for(taxa in taxaLevels){

    inFileName <- paste( taxa, "LogNormwithMetadata_R1_Pooled.txt", sep ="")
    myT <-read.csv(inFileName,header=TRUE,sep="", na.strings="BLAH")

    numCols <- ncol(myT)
    numMetadataCols <- 20

    ## Reprocessing for correct column data type
    myColClasses <- c("character", rep("numeric", numCols - numMetadataCols - 1), rep("character", 11), "numeric", "numeric", "numeric", "character", "character", "character", "character", "character", "character")
    myT <-read.csv(inFileName, header=TRUE, sep="", colClasses=myColClasses, na.strings="BLAH", comment.char ="@")

    ## Removing unwanted samples {controls, replicates, duplicates, poor quality samples}
    removeControls<-c( "C1", "C2", "N1", "N2", "Neg", "Pos")
    myT<-myT[!(myT$Sample_ID %in% removeControls),]

    removetrs<-c("04_125_tr", "04_101_tr", "04_103_tr", "04_74_tr", "04_70_tr", "04_40_tr", "04_41_tr", "04_84_tr")
    myT<-myT[!(myT$Sample_ID %in% removetrs),]

    removeDups<-c("04-04_S63_L001_R1_001")
    myT<-myT[!(myT$MatchFile %in% removeDups),]

    ## Controls not dropped earlier
    manualDrop <- c("Neg_S40_L001_R1_001", "PCR1Neg_S65_L001_R1_001")
    myT<-myT[!(myT$MatchFile %in% manualDrop),]

    labDrop <- c("Harlan Labs")
    myT<-myT[!(myT$MouseOrigin %in% labDrop),]

    lowSeqDrop <- c("04-55_S32_L001_R1_001")
    myT<-myT[!(myT$MatchFile %in% lowSeqDrop),]
    ## Not sure what to do about this though.
    ### myT$Condition[which(myT$Treatment == "Ctrl", arr.ind = TRUE)]<-"Control"

    names <- vector()
    pValuesSex<- vector()
    pValuesAcuteChronic<- vector()
    pValuesCage<- vector()
    iccCage <- vector()
    iccKeptCounts <- vector()
    pValuesBatch<- vector()
    pValuesTreatment<- vector()
    pValuesTime <- vector()
    pValuesStressLength <- vector()
    pValuesInteraction <- vector()
    allpvals <- list()

    index <- 1
    pdf( paste(taxa, filePrefix, "boxplots.pdf", sep=""))

    for( i in 2:(ncol(myT) - numMetadataCols))
        if( sum(myT[,i] != 0 ) > nrow(myT) / 4 ){
            ## Easy access names
            bug <- myT[,i]
            ac <- myT$Condition
            sex <- myT$Sex
            cage <- myT$Cage
            batch <- myT$Sample_Plate
            date <- myT$Date
            mo <- myT$MouseOrigin
            group <- myT$SpreadsheetGrouping
            treatment <- myT$Treatment
            time <- myT$StressLength
            multiWay <- paste(ac, myT$StressLength)
            multiWay[which(myT$Treatment == "Ctrl", arr.ind = TRUE)]<-"Control"
            names[index] = names(myT)[i]
            ## Some kind of vector for the variables of interest
            myFrame <- data.frame(bug, ac, time, multiWay, sex, cage, treatment, batch, date, mo, date)
            if(mlm == TRUE){
                fullModel <- gls( bug~ treatment*batch, method="REML",correlation=corCompSymm(form=~1|factor(group)),	data = myFrame )
                reducedModel <- gls( bug~ treatment*time*batch, method="REML", data = myFrame )
                fullModelLME <- lme(bug~ treatment*time*batch, method="REML", random = ~1|factor(group), data = myFrame)
            }
            else{
                fullModelLME <- lm(bug~ treatment*time*batch, x=TRUE)
            }
            ## Potential save time by reducing anova calls
            ## Introduce the goodness of fit tests here
            ## Can streamline vectors to be automatically responsive to changes to the model
            if(mlm == TRUE){
                allNames <- rownames(anova(fullModelLME))[-1]
                allpvals[[index]] <- anova(fullModelLME)$"p-value"[-1]
            }
            else {
                allNames <- rownames(anova(fullModelLME))[-dim(anova(fullModelLME))[1]]
                allpvals[[index]]<-as.data.frame(anova(fullModelLME))[1:dim(anova(fullModelLME))[1]-1,5]
            }

            ## Random Effects and Interclass Correlation Coefficient
            if(mlm == TRUE){
                allNames<-c(allNames, "cage", "iccCage")
                allpvals[[index]]<-c(allpvals[[index]], anova(fullModelLME, reducedModel)$"p-value"[2], coef(fullModel$modelStruct[1]$corStruct,unconstrained=FALSE)[[1]])
                pValuesCage[index] <-  anova(fullModelLME, reducedModel)$"p-value"[2]
                ## This is different as it is not corrected for multiple hypothesis testing.
                iccCage[index]<- coef(fullModel$modelStruct[1]$corStruct,unconstrained=FALSE)[[1]]
            }
    ## Nice plotting
            ## Correct so that it uses corrected p-values
            if(mlm == TRUE){
                graphMain = c(names[i], paste(c(rep("p-",length(allNames)-1),""), allNames, " = ", format(allpvals[[index]], digits=3), sep=""))
            }
            else {
                graphMain = c(names[i], paste(c(rep("p-",length(allNames)),""), allNames, " = ", format(allpvals[[index]], digits=3), sep=""))

            }

            ## mlm is boolean 1/0 value. Basically, don't graph on icc
            ## need a correction for interaction terms as well
            numPlots <- length(allNames) - mlm
            par(mfrow=c(numPlots, 1),
                oma = c(1,1,0,0) + 0.1,
                mar = c(1,4,3,0) + 0.1)

            for(j in 1:numPlots){
                if(j == 1){
                    plot( bug ~ factor(get(allNames[j])), ylab = names[i], main = c(names[index],toString(graphMain[-1])) )
                    points(factor(get(allNames[j])), bug)
                }
                else{
                    testInteract <- grep(":", allNames)
                    if(length(testInteract) > 0){
                        if(j %in% testInteract){
                            intSplit <- unlist(strsplit(allNames[grep(":",allNames)[j]],split=":"))
                            if(length(intSplit) == 2){
                                plot( bug ~ factor(c( paste( get(intSplit[1]), get(intSplit[2]),sep=""))))
                                points(factor(c( paste( get(intSplit[1]), get(intSplit[2]),sep=""))), bug)
                            }
                            else{
                                plot( bug ~ factor(c( paste( get(intSplit[1]), get(intSplit[2]), get(intSplit[3]),sep=""))))
                                points(factor(c( paste( get(intSplit[1]), get(intSplit[2]), get(intSplit[3]),sep=""))), bug)
                            }
                        }
                    }
                    else{
                        plot( bug ~ factor(get(allNames[j])), ylab = names[i])
                        points(factor(get(allNames[j])), bug)
                    }
                }
            }

            index <- index + 1
	}

    ## This should also be dynamic
    dFrame <- as.data.frame(matrix(unlist(allpvals), nrow= length(allpvals), byrow=TRUE))
    colnames(dFrame) <- unlist(allNames)
    rownames(dFrame) <- names
    orgCol <- ncol(dFrame)

    for(k in 1:(orgCol-mlm)){
        dFrame[, k + orgCol]<-p.adjust(dFrame[,k], method = "BH")
    }
    colnames(dFrame)[(orgCol + 1):length(dFrame)]<-paste0(rep("adjusted_"),colnames(dFrame)[1:(orgCol - mlm)])

    dFrame <- cbind(names, dFrame)
    ## Try and dynamically generate the name of the plot here...
    write.table(dFrame, file=paste("pValues", filePrefix, taxa, ".txt",sep=""), sep="\t",row.names=FALSE)

    ## Get the sig table working
    ## It would also be nice to have a sig-picker for the plots and a combination of all sig results into one plot.
    keepVector <- grep("adj", names(dFrame))
    sigdFrame <-dFrame[which(dFrame[,keepVector] < 0.05,arr.ind=TRUE),]
    write.table(sigdFrame, file=paste("SIGpValues", filePrefix, taxa, ".txt",sep=""), sep="\t",row.names=FALSE)

    dev.off()
}

ls()
intSplit
j
tstInteract
testInteract
anova(fullModelLME)
allNames
grep(":", allNames)
which(grep(":", allNames) == j)
which(grep(":", allNames) == j)
rm(list=ls())

library("pscl")
library("lmtest")
library("nlme")
library("vegan")

setwd("/Users/mbrown67/Documents/Fodor/Datasets/MarkExperiment/Pooled/")

taxaLevels <- c( "phylum", "class", "order", "family", "genus")

filePrefix <- "_treatment*time*batch_"
mlm<-FALSE


for(taxa in taxaLevels){

    inFileName <- paste( taxa, "LogNormwithMetadata_R1_Pooled.txt", sep ="")
    myT <-read.csv(inFileName,header=TRUE,sep="", na.strings="BLAH")

    numCols <- ncol(myT)
    numMetadataCols <- 20

    ## Reprocessing for correct column data type
    myColClasses <- c("character", rep("numeric", numCols - numMetadataCols - 1), rep("character", 11), "numeric", "numeric", "numeric", "character", "character", "character", "character", "character", "character")
    myT <-read.csv(inFileName, header=TRUE, sep="", colClasses=myColClasses, na.strings="BLAH", comment.char ="@")

    ## Removing unwanted samples {controls, replicates, duplicates, poor quality samples}
    removeControls<-c( "C1", "C2", "N1", "N2", "Neg", "Pos")
    myT<-myT[!(myT$Sample_ID %in% removeControls),]

    removetrs<-c("04_125_tr", "04_101_tr", "04_103_tr", "04_74_tr", "04_70_tr", "04_40_tr", "04_41_tr", "04_84_tr")
    myT<-myT[!(myT$Sample_ID %in% removetrs),]

    removeDups<-c("04-04_S63_L001_R1_001")
    myT<-myT[!(myT$MatchFile %in% removeDups),]

    ## Controls not dropped earlier
    manualDrop <- c("Neg_S40_L001_R1_001", "PCR1Neg_S65_L001_R1_001")
    myT<-myT[!(myT$MatchFile %in% manualDrop),]

    labDrop <- c("Harlan Labs")
    myT<-myT[!(myT$MouseOrigin %in% labDrop),]

    lowSeqDrop <- c("04-55_S32_L001_R1_001")
    myT<-myT[!(myT$MatchFile %in% lowSeqDrop),]
    ## Not sure what to do about this though.
    ### myT$Condition[which(myT$Treatment == "Ctrl", arr.ind = TRUE)]<-"Control"

    names <- vector()
    pValuesSex<- vector()
    pValuesAcuteChronic<- vector()
    pValuesCage<- vector()
    iccCage <- vector()
    iccKeptCounts <- vector()
    pValuesBatch<- vector()
    pValuesTreatment<- vector()
    pValuesTime <- vector()
    pValuesStressLength <- vector()
    pValuesInteraction <- vector()
    allpvals <- list()

    index <- 1
    pdf( paste(taxa, filePrefix, "boxplots.pdf", sep=""))

    for( i in 2:(ncol(myT) - numMetadataCols))
        if( sum(myT[,i] != 0 ) > nrow(myT) / 4 ){
            ## Easy access names
            bug <- myT[,i]
            ac <- myT$Condition
            sex <- myT$Sex
            cage <- myT$Cage
            batch <- myT$Sample_Plate
            date <- myT$Date
            mo <- myT$MouseOrigin
            group <- myT$SpreadsheetGrouping
            treatment <- myT$Treatment
            time <- myT$StressLength
            multiWay <- paste(ac, myT$StressLength)
            multiWay[which(myT$Treatment == "Ctrl", arr.ind = TRUE)]<-"Control"
            names[index] = names(myT)[i]
            ## Some kind of vector for the variables of interest
            myFrame <- data.frame(bug, ac, time, multiWay, sex, cage, treatment, batch, date, mo, date)
            if(mlm == TRUE){
                fullModel <- gls( bug~ treatment*batch, method="REML",correlation=corCompSymm(form=~1|factor(group)),	data = myFrame )
                reducedModel <- gls( bug~ treatment*time*batch, method="REML", data = myFrame )
                fullModelLME <- lme(bug~ treatment*time*batch, method="REML", random = ~1|factor(group), data = myFrame)
            }
            else{
                fullModelLME <- lm(bug~ treatment*time*batch, x=TRUE)
            }
            ## Potential save time by reducing anova calls
            ## Introduce the goodness of fit tests here
            ## Can streamline vectors to be automatically responsive to changes to the model
            if(mlm == TRUE){
                allNames <- rownames(anova(fullModelLME))[-1]
                allpvals[[index]] <- anova(fullModelLME)$"p-value"[-1]
            }
            else {
                allNames <- rownames(anova(fullModelLME))[-dim(anova(fullModelLME))[1]]
                allpvals[[index]]<-as.data.frame(anova(fullModelLME))[1:dim(anova(fullModelLME))[1]-1,5]
            }

            ## Random Effects and Interclass Correlation Coefficient
            if(mlm == TRUE){
                allNames<-c(allNames, "cage", "iccCage")
                allpvals[[index]]<-c(allpvals[[index]], anova(fullModelLME, reducedModel)$"p-value"[2], coef(fullModel$modelStruct[1]$corStruct,unconstrained=FALSE)[[1]])
                pValuesCage[index] <-  anova(fullModelLME, reducedModel)$"p-value"[2]
                ## This is different as it is not corrected for multiple hypothesis testing.
                iccCage[index]<- coef(fullModel$modelStruct[1]$corStruct,unconstrained=FALSE)[[1]]
            }
    ## Nice plotting
            ## Correct so that it uses corrected p-values
            if(mlm == TRUE){
                graphMain = c(names[i], paste(c(rep("p-",length(allNames)-1),""), allNames, " = ", format(allpvals[[index]], digits=3), sep=""))
            }
            else {
                graphMain = c(names[i], paste(c(rep("p-",length(allNames)),""), allNames, " = ", format(allpvals[[index]], digits=3), sep=""))

            }

            ## mlm is boolean 1/0 value. Basically, don't graph on icc
            ## need a correction for interaction terms as well
            numPlots <- length(allNames) - mlm
            par(mfrow=c(numPlots, 1),
                oma = c(1,1,0,0) + 0.1,
                mar = c(1,4,3,0) + 0.1)

            for(j in 1:numPlots){
                if(j == 1){
                    plot( bug ~ factor(get(allNames[j])), ylab = names[i], main = c(names[index],toString(graphMain[-1])) )
                    points(factor(get(allNames[j])), bug)
                }
                else{
                    testInteract <- grep(":", allNames)
                    if(length(testInteract) > 0){
                        if(j %in% testInteract){
                            intSplit <- unlist(strsplit(allNames[grep(":",allNames)[which(grep(":", allNames) == j)]],split=":"))
                            if(length(intSplit) == 2){
                                plot( bug ~ factor(c( paste( get(intSplit[1]), get(intSplit[2]),sep=""))))
                                points(factor(c( paste( get(intSplit[1]), get(intSplit[2]),sep=""))), bug)
                            }
                            else{
                                plot( bug ~ factor(c( paste( get(intSplit[1]), get(intSplit[2]), get(intSplit[3]),sep=""))))
                                points(factor(c( paste( get(intSplit[1]), get(intSplit[2]), get(intSplit[3]),sep=""))), bug)
                            }
                        }
                    }
                    else{
                        plot( bug ~ factor(get(allNames[j])), ylab = names[i])
                        points(factor(get(allNames[j])), bug)
                    }
                }
            }

            index <- index + 1
	}

    ## This should also be dynamic
    dFrame <- as.data.frame(matrix(unlist(allpvals), nrow= length(allpvals), byrow=TRUE))
    colnames(dFrame) <- unlist(allNames)
    rownames(dFrame) <- names
    orgCol <- ncol(dFrame)

    for(k in 1:(orgCol-mlm)){
        dFrame[, k + orgCol]<-p.adjust(dFrame[,k], method = "BH")
    }
    colnames(dFrame)[(orgCol + 1):length(dFrame)]<-paste0(rep("adjusted_"),colnames(dFrame)[1:(orgCol - mlm)])

    dFrame <- cbind(names, dFrame)
    ## Try and dynamically generate the name of the plot here...
    write.table(dFrame, file=paste("pValues", filePrefix, taxa, ".txt",sep=""), sep="\t",row.names=FALSE)

    ## Get the sig table working
    ## It would also be nice to have a sig-picker for the plots and a combination of all sig results into one plot.
    keepVector <- grep("adj", names(dFrame))
    sigdFrame <-dFrame[which(dFrame[,keepVector] < 0.05,arr.ind=TRUE),]
    write.table(sigdFrame, file=paste("SIGpValues", filePrefix, taxa, ".txt",sep=""), sep="\t",row.names=FALSE)

    dev.off()
}

rm(list=ls())

library("pscl")
library("lmtest")
library("nlme")
library("vegan")

setwd("/Users/mbrown67/Documents/Fodor/Datasets/MarkExperiment/Pooled/")

taxaLevels <- c( "phylum", "class", "order", "family", "genus")

filePrefix <- "_treatment*time*batch_byGroup_"
mlm<-TRUE


for(taxa in taxaLevels){

    inFileName <- paste( taxa, "LogNormwithMetadata_R1_Pooled.txt", sep ="")
    myT <-read.csv(inFileName,header=TRUE,sep="", na.strings="BLAH")

    numCols <- ncol(myT)
    numMetadataCols <- 20

    ## Reprocessing for correct column data type
    myColClasses <- c("character", rep("numeric", numCols - numMetadataCols - 1), rep("character", 11), "numeric", "numeric", "numeric", "character", "character", "character", "character", "character", "character")
    myT <-read.csv(inFileName, header=TRUE, sep="", colClasses=myColClasses, na.strings="BLAH", comment.char ="@")

    ## Removing unwanted samples {controls, replicates, duplicates, poor quality samples}
    removeControls<-c( "C1", "C2", "N1", "N2", "Neg", "Pos")
    myT<-myT[!(myT$Sample_ID %in% removeControls),]

    removetrs<-c("04_125_tr", "04_101_tr", "04_103_tr", "04_74_tr", "04_70_tr", "04_40_tr", "04_41_tr", "04_84_tr")
    myT<-myT[!(myT$Sample_ID %in% removetrs),]

    removeDups<-c("04-04_S63_L001_R1_001")
    myT<-myT[!(myT$MatchFile %in% removeDups),]

    ## Controls not dropped earlier
    manualDrop <- c("Neg_S40_L001_R1_001", "PCR1Neg_S65_L001_R1_001")
    myT<-myT[!(myT$MatchFile %in% manualDrop),]

    labDrop <- c("Harlan Labs")
    myT<-myT[!(myT$MouseOrigin %in% labDrop),]

    lowSeqDrop <- c("04-55_S32_L001_R1_001")
    myT<-myT[!(myT$MatchFile %in% lowSeqDrop),]
    ## Not sure what to do about this though.
    ### myT$Condition[which(myT$Treatment == "Ctrl", arr.ind = TRUE)]<-"Control"

    names <- vector()
    pValuesSex<- vector()
    pValuesAcuteChronic<- vector()
    pValuesCage<- vector()
    iccCage <- vector()
    iccKeptCounts <- vector()
    pValuesBatch<- vector()
    pValuesTreatment<- vector()
    pValuesTime <- vector()
    pValuesStressLength <- vector()
    pValuesInteraction <- vector()
    allpvals <- list()

    index <- 1
    pdf( paste(taxa, filePrefix, "boxplots.pdf", sep=""))

    for( i in 2:(ncol(myT) - numMetadataCols))
        if( sum(myT[,i] != 0 ) > nrow(myT) / 4 ){
            ## Easy access names
            bug <- myT[,i]
            ac <- myT$Condition
            sex <- myT$Sex
            cage <- myT$Cage
            batch <- myT$Sample_Plate
            date <- myT$Date
            mo <- myT$MouseOrigin
            group <- myT$SpreadsheetGrouping
            treatment <- myT$Treatment
            time <- myT$StressLength
            multiWay <- paste(ac, myT$StressLength)
            multiWay[which(myT$Treatment == "Ctrl", arr.ind = TRUE)]<-"Control"
            names[index] = names(myT)[i]
            ## Some kind of vector for the variables of interest
            myFrame <- data.frame(bug, ac, time, multiWay, sex, cage, treatment, batch, date, mo, date)
            if(mlm == TRUE){
                fullModel <- gls( bug~ treatment*time*batch, method="REML",correlation=corCompSymm(form=~1|factor(group)),	data = myFrame )
                reducedModel <- gls( bug~ treatment*time*batch, method="REML", data = myFrame )
                fullModelLME <- lme(bug~ treatment*time*batch, method="REML", random = ~1|factor(group), data = myFrame)
            }
            else{
                fullModelLME <- lm(bug~ treatment*time*batch, x=TRUE)
            }
            ## Potential save time by reducing anova calls
            ## Introduce the goodness of fit tests here
            ## Can streamline vectors to be automatically responsive to changes to the model
            if(mlm == TRUE){
                allNames <- rownames(anova(fullModelLME))[-1]
                allpvals[[index]] <- anova(fullModelLME)$"p-value"[-1]
            }
            else {
                allNames <- rownames(anova(fullModelLME))[-dim(anova(fullModelLME))[1]]
                allpvals[[index]]<-as.data.frame(anova(fullModelLME))[1:dim(anova(fullModelLME))[1]-1,5]
            }

            ## Random Effects and Interclass Correlation Coefficient
            if(mlm == TRUE){
                allNames<-c(allNames, "cage", "iccCage")
                allpvals[[index]]<-c(allpvals[[index]], anova(fullModelLME, reducedModel)$"p-value"[2], coef(fullModel$modelStruct[1]$corStruct,unconstrained=FALSE)[[1]])
                pValuesCage[index] <-  anova(fullModelLME, reducedModel)$"p-value"[2]
                ## This is different as it is not corrected for multiple hypothesis testing.
                iccCage[index]<- coef(fullModel$modelStruct[1]$corStruct,unconstrained=FALSE)[[1]]
            }
    ## Nice plotting
            ## Correct so that it uses corrected p-values
            if(mlm == TRUE){
                graphMain = c(names[i], paste(c(rep("p-",length(allNames)-1),""), allNames, " = ", format(allpvals[[index]], digits=3), sep=""))
            }
            else {
                graphMain = c(names[i], paste(c(rep("p-",length(allNames)),""), allNames, " = ", format(allpvals[[index]], digits=3), sep=""))

            }

            ## mlm is boolean 1/0 value. Basically, don't graph on icc
            ## need a correction for interaction terms as well
            numPlots <- length(allNames) - mlm
            par(mfrow=c(numPlots, 1),
                oma = c(1,1,0,0) + 0.1,
                mar = c(1,4,3,0) + 0.1)

            for(j in 1:numPlots){
                if(j == 1){
                    plot( bug ~ factor(get(allNames[j])), ylab = names[i], main = c(names[index],toString(graphMain[-1])) )
                    points(factor(get(allNames[j])), bug)
                }
                else{
                    testInteract <- grep(":", allNames)
                    if(length(testInteract) > 0){
                        if(j %in% testInteract){
                            intSplit <- unlist(strsplit(allNames[grep(":",allNames)[which(grep(":", allNames) == j)]],split=":"))
                            if(length(intSplit) == 2){
                                plot( bug ~ factor(c( paste( get(intSplit[1]), get(intSplit[2]),sep=""))))
                                points(factor(c( paste( get(intSplit[1]), get(intSplit[2]),sep=""))), bug)
                            }
                            else{
                                plot( bug ~ factor(c( paste( get(intSplit[1]), get(intSplit[2]), get(intSplit[3]),sep=""))))
                                points(factor(c( paste( get(intSplit[1]), get(intSplit[2]), get(intSplit[3]),sep=""))), bug)
                            }
                        }
                    }
                    else{
                        plot( bug ~ factor(get(allNames[j])), ylab = names[i])
                        points(factor(get(allNames[j])), bug)
                    }
                }
            }

            index <- index + 1
	}

    ## This should also be dynamic
    dFrame <- as.data.frame(matrix(unlist(allpvals), nrow= length(allpvals), byrow=TRUE))
    colnames(dFrame) <- unlist(allNames)
    rownames(dFrame) <- names
    orgCol <- ncol(dFrame)

    for(k in 1:(orgCol-mlm)){
        dFrame[, k + orgCol]<-p.adjust(dFrame[,k], method = "BH")
    }
    colnames(dFrame)[(orgCol + 1):length(dFrame)]<-paste0(rep("adjusted_"),colnames(dFrame)[1:(orgCol - mlm)])

    dFrame <- cbind(names, dFrame)
    ## Try and dynamically generate the name of the plot here...
    write.table(dFrame, file=paste("pValues", filePrefix, taxa, ".txt",sep=""), sep="\t",row.names=FALSE)

    ## Get the sig table working
    ## It would also be nice to have a sig-picker for the plots and a combination of all sig results into one plot.
    keepVector <- grep("adj", names(dFrame))
    sigdFrame <-dFrame[which(dFrame[,keepVector] < 0.05,arr.ind=TRUE),]
    write.table(sigdFrame, file=paste("SIGpValues", filePrefix, taxa, ".txt",sep=""), sep="\t",row.names=FALSE)

    dev.off()
}

batch
rm(list=ls())

library("pscl")
library("lmtest")
library("nlme")
library("vegan")

setwd("/Users/mbrown67/Documents/Fodor/Datasets/MarkExperiment/Pooled/")

taxaLevels <- c( "phylum", "class", "order", "family", "genus")

filePrefix <- "_treatment_onebatch_onetime_"
mlm<-FALSE

dropBatch <- "Lyte_Batch04_Run01_repeat"
dropTime <- 19
dropTreatment <- "Exp"

for(taxa in taxaLevels){

    inFileName <- paste( taxa, "LogNormwithMetadata_R1_Pooled.txt", sep ="")
    myT <-read.csv(inFileName,header=TRUE,sep="", na.strings="BLAH")

    numCols <- ncol(myT)
    numMetadataCols <- 20

    ## Reprocessing for correct column data type
    myColClasses <- c("character", rep("numeric", numCols - numMetadataCols - 1), rep("character", 11), "numeric", "numeric", "numeric", "character", "character", "character", "character", "character", "character")
    myT <-read.csv(inFileName, header=TRUE, sep="", colClasses=myColClasses, na.strings="BLAH", comment.char ="@")

    ## Removing unwanted samples {controls, replicates, duplicates, poor quality samples}
    removeControls<-c( "C1", "C2", "N1", "N2", "Neg", "Pos")
    myT<-myT[!(myT$Sample_ID %in% removeControls),]

    removetrs<-c("04_125_tr", "04_101_tr", "04_103_tr", "04_74_tr", "04_70_tr", "04_40_tr", "04_41_tr", "04_84_tr")
    myT<-myT[!(myT$Sample_ID %in% removetrs),]

    removeDups<-c("04-04_S63_L001_R1_001")
    myT<-myT[!(myT$MatchFile %in% removeDups),]

    ## Controls not dropped earlier
    manualDrop <- c("Neg_S40_L001_R1_001", "PCR1Neg_S65_L001_R1_001")
    myT<-myT[!(myT$MatchFile %in% manualDrop),]

    labDrop <- c("Harlan Labs")
    myT<-myT[!(myT$MouseOrigin %in% labDrop),]

    lowSeqDrop <- c("04-55_S32_L001_R1_001")
    myT<-myT[!(myT$MatchFile %in% lowSeqDrop),]
    ## Not sure what to do about this though.
    ### myT$Condition[which(myT$Treatment == "Ctrl", arr.ind = TRUE)]<-"Control"

    myT<-myT[myT$Sample_Plate == dropBatch,]
    myT<-myT[myT$StressLength == dropTime,]

    names <- vector()
    pValuesSex<- vector()
    pValuesAcuteChronic<- vector()
    pValuesCage<- vector()
    iccCage <- vector()
    iccKeptCounts <- vector()
    pValuesBatch<- vector()
    pValuesTreatment<- vector()
    pValuesTime <- vector()
    pValuesStressLength <- vector()
    pValuesInteraction <- vector()
    allpvals <- list()

    index <- 1
    pdf( paste(taxa, filePrefix, "boxplots.pdf", sep=""))

    for( i in 2:(ncol(myT) - numMetadataCols))
        if( sum(myT[,i] != 0 ) > nrow(myT) / 4 ){
            ## Easy access names
            bug <- myT[,i]
            ac <- myT$Condition
            sex <- myT$Sex
            cage <- myT$Cage
            batch <- myT$Sample_Plate
            date <- myT$Date
            mo <- myT$MouseOrigin
            group <- myT$SpreadsheetGrouping
            treatment <- myT$Treatment
            time <- myT$StressLength
            multiWay <- paste(ac, myT$StressLength)
            multiWay[which(myT$Treatment == "Ctrl", arr.ind = TRUE)]<-"Control"
            names[index] = names(myT)[i]
            ## Some kind of vector for the variables of interest
            myFrame <- data.frame(bug, ac, time, multiWay, sex, cage, treatment, batch, date, mo, date)
            if(mlm == TRUE){
                fullModel <- gls( bug~ treatment*time*batch, method="REML",correlation=corCompSymm(form=~1|factor(group)),	data = myFrame )
                reducedModel <- gls( bug~ treatment*time*batch, method="REML", data = myFrame )
                fullModelLME <- lme(bug~ treatment*time*batch, method="REML", random = ~1|factor(group), data = myFrame)
            }
            else{
                fullModelLME <- lm(bug~ treatment, x=TRUE)
            }
            ## Potential save time by reducing anova calls
            ## Introduce the goodness of fit tests here
            ## Can streamline vectors to be automatically responsive to changes to the model
            if(mlm == TRUE){
                allNames <- rownames(anova(fullModelLME))[-1]
                allpvals[[index]] <- anova(fullModelLME)$"p-value"[-1]
            }
            else {
                allNames <- rownames(anova(fullModelLME))[-dim(anova(fullModelLME))[1]]
                allpvals[[index]]<-as.data.frame(anova(fullModelLME))[1:dim(anova(fullModelLME))[1]-1,5]
            }

            ## Random Effects and Interclass Correlation Coefficient
            if(mlm == TRUE){
                allNames<-c(allNames, "cage", "iccCage")
                allpvals[[index]]<-c(allpvals[[index]], anova(fullModelLME, reducedModel)$"p-value"[2], coef(fullModel$modelStruct[1]$corStruct,unconstrained=FALSE)[[1]])
                pValuesCage[index] <-  anova(fullModelLME, reducedModel)$"p-value"[2]
                ## This is different as it is not corrected for multiple hypothesis testing.
                iccCage[index]<- coef(fullModel$modelStruct[1]$corStruct,unconstrained=FALSE)[[1]]
            }
    ## Nice plotting
            ## Correct so that it uses corrected p-values
            if(mlm == TRUE){
                graphMain = c(names[i], paste(c(rep("p-",length(allNames)-1),""), allNames, " = ", format(allpvals[[index]], digits=3), sep=""))
            }
            else {
                graphMain = c(names[i], paste(c(rep("p-",length(allNames)),""), allNames, " = ", format(allpvals[[index]], digits=3), sep=""))

            }

            ## mlm is boolean 1/0 value. Basically, don't graph on icc
            ## need a correction for interaction terms as well
            numPlots <- length(allNames) - mlm
            par(mfrow=c(numPlots, 1),
                oma = c(1,1,0,0) + 0.1,
                mar = c(1,4,3,0) + 0.1)

            for(j in 1:numPlots){
                if(j == 1){
                    plot( bug ~ factor(get(allNames[j])), ylab = names[i], main = c(names[index],toString(graphMain[-1])) )
                    points(factor(get(allNames[j])), bug)
                }
                else{
                    testInteract <- grep(":", allNames)
                    if(length(testInteract) > 0){
                        if(j %in% testInteract){
                            intSplit <- unlist(strsplit(allNames[grep(":",allNames)[which(grep(":", allNames) == j)]],split=":"))
                            if(length(intSplit) == 2){
                                plot( bug ~ factor(c( paste( get(intSplit[1]), get(intSplit[2]),sep=""))))
                                points(factor(c( paste( get(intSplit[1]), get(intSplit[2]),sep=""))), bug)
                            }
                            else{
                                plot( bug ~ factor(c( paste( get(intSplit[1]), get(intSplit[2]), get(intSplit[3]),sep=""))))
                                points(factor(c( paste( get(intSplit[1]), get(intSplit[2]), get(intSplit[3]),sep=""))), bug)
                            }
                        }
                    }
                    else{
                        plot( bug ~ factor(get(allNames[j])), ylab = names[i])
                        points(factor(get(allNames[j])), bug)
                    }
                }
            }

            index <- index + 1
	}

    ## This should also be dynamic
    dFrame <- as.data.frame(matrix(unlist(allpvals), nrow= length(allpvals), byrow=TRUE))
    colnames(dFrame) <- unlist(allNames)
    rownames(dFrame) <- names
    orgCol <- ncol(dFrame)

    for(k in 1:(orgCol-mlm)){
        dFrame[, k + orgCol]<-p.adjust(dFrame[,k], method = "BH")
    }
    colnames(dFrame)[(orgCol + 1):length(dFrame)]<-paste0(rep("adjusted_"),colnames(dFrame)[1:(orgCol - mlm)])

    dFrame <- cbind(names, dFrame)
    ## Try and dynamically generate the name of the plot here...
    write.table(dFrame, file=paste("pValues", filePrefix, taxa, ".txt",sep=""), sep="\t",row.names=FALSE)

    ## Get the sig table working
    ## It would also be nice to have a sig-picker for the plots and a combination of all sig results into one plot.
    keepVector <- grep("adj", names(dFrame))
    sigdFrame <-dFrame[which(dFrame[,keepVector] < 0.05,arr.ind=TRUE),]
    write.table(sigdFrame, file=paste("SIGpValues", filePrefix, taxa, ".txt",sep=""), sep="\t",row.names=FALSE)

    dev.off()
}

rm(list=ls())

library("pscl")
library("lmtest")
library("nlme")
library("vegan")

setwd("/Users/mbrown67/Documents/Fodor/Datasets/MarkExperiment/Pooled/")

taxaLevels <- c( "phylum", "class", "order", "family", "genus")

filePrefix <- "_treatment_onebatch_onetime_byGroup"
mlm<-TRUE

dropBatch <- "Lyte_Batch04_Run01_repeat"
dropTime <- 19
dropTreatment <- "Exp"

for(taxa in taxaLevels){

    inFileName <- paste( taxa, "LogNormwithMetadata_R1_Pooled.txt", sep ="")
    myT <-read.csv(inFileName,header=TRUE,sep="", na.strings="BLAH")

    numCols <- ncol(myT)
    numMetadataCols <- 20

    ## Reprocessing for correct column data type
    myColClasses <- c("character", rep("numeric", numCols - numMetadataCols - 1), rep("character", 11), "numeric", "numeric", "numeric", "character", "character", "character", "character", "character", "character")
    myT <-read.csv(inFileName, header=TRUE, sep="", colClasses=myColClasses, na.strings="BLAH", comment.char ="@")

    ## Removing unwanted samples {controls, replicates, duplicates, poor quality samples}
    removeControls<-c( "C1", "C2", "N1", "N2", "Neg", "Pos")
    myT<-myT[!(myT$Sample_ID %in% removeControls),]

    removetrs<-c("04_125_tr", "04_101_tr", "04_103_tr", "04_74_tr", "04_70_tr", "04_40_tr", "04_41_tr", "04_84_tr")
    myT<-myT[!(myT$Sample_ID %in% removetrs),]

    removeDups<-c("04-04_S63_L001_R1_001")
    myT<-myT[!(myT$MatchFile %in% removeDups),]

    ## Controls not dropped earlier
    manualDrop <- c("Neg_S40_L001_R1_001", "PCR1Neg_S65_L001_R1_001")
    myT<-myT[!(myT$MatchFile %in% manualDrop),]

    labDrop <- c("Harlan Labs")
    myT<-myT[!(myT$MouseOrigin %in% labDrop),]

    lowSeqDrop <- c("04-55_S32_L001_R1_001")
    myT<-myT[!(myT$MatchFile %in% lowSeqDrop),]
    ## Not sure what to do about this though.
    ### myT$Condition[which(myT$Treatment == "Ctrl", arr.ind = TRUE)]<-"Control"

    myT<-myT[myT$Sample_Plate == dropBatch,]
    myT<-myT[myT$StressLength == dropTime,]

    names <- vector()
    pValuesSex<- vector()
    pValuesAcuteChronic<- vector()
    pValuesCage<- vector()
    iccCage <- vector()
    iccKeptCounts <- vector()
    pValuesBatch<- vector()
    pValuesTreatment<- vector()
    pValuesTime <- vector()
    pValuesStressLength <- vector()
    pValuesInteraction <- vector()
    allpvals <- list()

    index <- 1
    pdf( paste(taxa, filePrefix, "boxplots.pdf", sep=""))

    for( i in 2:(ncol(myT) - numMetadataCols))
        if( sum(myT[,i] != 0 ) > nrow(myT) / 4 ){
            ## Easy access names
            bug <- myT[,i]
            ac <- myT$Condition
            sex <- myT$Sex
            cage <- myT$Cage
            batch <- myT$Sample_Plate
            date <- myT$Date
            mo <- myT$MouseOrigin
            group <- myT$SpreadsheetGrouping
            treatment <- myT$Treatment
            time <- myT$StressLength
            multiWay <- paste(ac, myT$StressLength)
            multiWay[which(myT$Treatment == "Ctrl", arr.ind = TRUE)]<-"Control"
            names[index] = names(myT)[i]
            ## Some kind of vector for the variables of interest
            myFrame <- data.frame(bug, ac, time, multiWay, sex, cage, treatment, batch, date, mo, date)
            if(mlm == TRUE){
                fullModel <- gls( bug~ treatment, method="REML",correlation=corCompSymm(form=~1|factor(group)),	data = myFrame )
                reducedModel <- gls( bug~ treatment, method="REML", data = myFrame )
                fullModelLME <- lme(bug~ treatment, method="REML", random = ~1|factor(group), data = myFrame)
            }
            else{
                fullModelLME <- lm(bug~ treatment, x=TRUE)
            }
            ## Potential save time by reducing anova calls
            ## Introduce the goodness of fit tests here
            ## Can streamline vectors to be automatically responsive to changes to the model
            if(mlm == TRUE){
                allNames <- rownames(anova(fullModelLME))[-1]
                allpvals[[index]] <- anova(fullModelLME)$"p-value"[-1]
            }
            else {
                allNames <- rownames(anova(fullModelLME))[-dim(anova(fullModelLME))[1]]
                allpvals[[index]]<-as.data.frame(anova(fullModelLME))[1:dim(anova(fullModelLME))[1]-1,5]
            }

            ## Random Effects and Interclass Correlation Coefficient
            if(mlm == TRUE){
                allNames<-c(allNames, "cage", "iccCage")
                allpvals[[index]]<-c(allpvals[[index]], anova(fullModelLME, reducedModel)$"p-value"[2], coef(fullModel$modelStruct[1]$corStruct,unconstrained=FALSE)[[1]])
                pValuesCage[index] <-  anova(fullModelLME, reducedModel)$"p-value"[2]
                ## This is different as it is not corrected for multiple hypothesis testing.
                iccCage[index]<- coef(fullModel$modelStruct[1]$corStruct,unconstrained=FALSE)[[1]]
            }
    ## Nice plotting
            ## Correct so that it uses corrected p-values
            if(mlm == TRUE){
                graphMain = c(names[i], paste(c(rep("p-",length(allNames)-1),""), allNames, " = ", format(allpvals[[index]], digits=3), sep=""))
            }
            else {
                graphMain = c(names[i], paste(c(rep("p-",length(allNames)),""), allNames, " = ", format(allpvals[[index]], digits=3), sep=""))

            }

            ## mlm is boolean 1/0 value. Basically, don't graph on icc
            ## need a correction for interaction terms as well
            numPlots <- length(allNames) - mlm
            par(mfrow=c(numPlots, 1),
                oma = c(1,1,0,0) + 0.1,
                mar = c(1,4,3,0) + 0.1)

            for(j in 1:numPlots){
                if(j == 1){
                    plot( bug ~ factor(get(allNames[j])), ylab = names[i], main = c(names[index],toString(graphMain[-1])) )
                    points(factor(get(allNames[j])), bug)
                }
                else{
                    testInteract <- grep(":", allNames)
                    if(length(testInteract) > 0){
                        if(j %in% testInteract){
                            intSplit <- unlist(strsplit(allNames[grep(":",allNames)[which(grep(":", allNames) == j)]],split=":"))
                            if(length(intSplit) == 2){
                                plot( bug ~ factor(c( paste( get(intSplit[1]), get(intSplit[2]),sep=""))))
                                points(factor(c( paste( get(intSplit[1]), get(intSplit[2]),sep=""))), bug)
                            }
                            else{
                                plot( bug ~ factor(c( paste( get(intSplit[1]), get(intSplit[2]), get(intSplit[3]),sep=""))))
                                points(factor(c( paste( get(intSplit[1]), get(intSplit[2]), get(intSplit[3]),sep=""))), bug)
                            }
                        }
                    }
                    else{
                        plot( bug ~ factor(get(allNames[j])), ylab = names[i])
                        points(factor(get(allNames[j])), bug)
                    }
                }
            }

            index <- index + 1
	}

    ## This should also be dynamic
    dFrame <- as.data.frame(matrix(unlist(allpvals), nrow= length(allpvals), byrow=TRUE))
    colnames(dFrame) <- unlist(allNames)
    rownames(dFrame) <- names
    orgCol <- ncol(dFrame)

    for(k in 1:(orgCol-mlm)){
        dFrame[, k + orgCol]<-p.adjust(dFrame[,k], method = "BH")
    }
    colnames(dFrame)[(orgCol + 1):length(dFrame)]<-paste0(rep("adjusted_"),colnames(dFrame)[1:(orgCol - mlm)])

    dFrame <- cbind(names, dFrame)
    ## Try and dynamically generate the name of the plot here...
    write.table(dFrame, file=paste("pValues", filePrefix, taxa, ".txt",sep=""), sep="\t",row.names=FALSE)

    ## Get the sig table working
    ## It would also be nice to have a sig-picker for the plots and a combination of all sig results into one plot.
    keepVector <- grep("adj", names(dFrame))
    sigdFrame <-dFrame[which(dFrame[,keepVector] < 0.05,arr.ind=TRUE),]
    write.table(sigdFrame, file=paste("SIGpValues", filePrefix, taxa, ".txt",sep=""), sep="\t",row.names=FALSE)

    dev.off()
}

rm(list=ls())

library("pscl")
library("lmtest")
library("nlme")
library("vegan")

setwd("/Users/mbrown67/Documents/Fodor/Datasets/MarkExperiment/Pooled/")

taxaLevels <- c( "phylum", "class", "order", "family", "genus")

filePrefix <- "_treatment_onebatch_onetime"
mlm<- FALSE

dropBatch <- "Lyte_Batch04_Run01_repeat"
dropTime <- 19
dropTreatment <- "Exp"

for(taxa in taxaLevels){

    inFileName <- paste( taxa, "LogNormwithMetadata_R1_Pooled.txt", sep ="")
    myT <-read.csv(inFileName,header=TRUE,sep="", na.strings="BLAH")

    numCols <- ncol(myT)
    numMetadataCols <- 20

    ## Reprocessing for correct column data type
    myColClasses <- c("character", rep("numeric", numCols - numMetadataCols - 1), rep("character", 11), "numeric", "numeric", "numeric", "character", "character", "character", "character", "character", "character")
    myT <-read.csv(inFileName, header=TRUE, sep="", colClasses=myColClasses, na.strings="BLAH", comment.char ="@")

    ## Removing unwanted samples {controls, replicates, duplicates, poor quality samples}
    removeControls<-c( "C1", "C2", "N1", "N2", "Neg", "Pos")
    myT<-myT[!(myT$Sample_ID %in% removeControls),]

    removetrs<-c("04_125_tr", "04_101_tr", "04_103_tr", "04_74_tr", "04_70_tr", "04_40_tr", "04_41_tr", "04_84_tr")
    myT<-myT[!(myT$Sample_ID %in% removetrs),]

    removeDups<-c("04-04_S63_L001_R1_001")
    myT<-myT[!(myT$MatchFile %in% removeDups),]

    ## Controls not dropped earlier
    manualDrop <- c("Neg_S40_L001_R1_001", "PCR1Neg_S65_L001_R1_001")
    myT<-myT[!(myT$MatchFile %in% manualDrop),]

    labDrop <- c("Harlan Labs")
    myT<-myT[!(myT$MouseOrigin %in% labDrop),]

    lowSeqDrop <- c("04-55_S32_L001_R1_001")
    myT<-myT[!(myT$MatchFile %in% lowSeqDrop),]
    ## Not sure what to do about this though.
    ### myT$Condition[which(myT$Treatment == "Ctrl", arr.ind = TRUE)]<-"Control"

    myT<-myT[!(myT$Sample_Plate == dropBatch),]
    myT<-myT[myT$StressLength == dropTime,]

    names <- vector()
    pValuesSex<- vector()
    pValuesAcuteChronic<- vector()
    pValuesCage<- vector()
    iccCage <- vector()
    iccKeptCounts <- vector()
    pValuesBatch<- vector()
    pValuesTreatment<- vector()
    pValuesTime <- vector()
    pValuesStressLength <- vector()
    pValuesInteraction <- vector()
    allpvals <- list()

    index <- 1
    pdf( paste(taxa, filePrefix, "boxplots.pdf", sep=""))

    for( i in 2:(ncol(myT) - numMetadataCols))
        if( sum(myT[,i] != 0 ) > nrow(myT) / 4 ){
            ## Easy access names
            bug <- myT[,i]
            ac <- myT$Condition
            sex <- myT$Sex
            cage <- myT$Cage
            batch <- myT$Sample_Plate
            date <- myT$Date
            mo <- myT$MouseOrigin
            group <- myT$SpreadsheetGrouping
            treatment <- myT$Treatment
            time <- myT$StressLength
            multiWay <- paste(ac, myT$StressLength)
            multiWay[which(myT$Treatment == "Ctrl", arr.ind = TRUE)]<-"Control"
            names[index] = names(myT)[i]
            ## Some kind of vector for the variables of interest
            myFrame <- data.frame(bug, ac, time, multiWay, sex, cage, treatment, batch, date, mo, date)
            if(mlm == TRUE){
                fullModel <- gls( bug~ treatment, method="REML",correlation=corCompSymm(form=~1|factor(group)),	data = myFrame )
                reducedModel <- gls( bug~ treatment, method="REML", data = myFrame )
                fullModelLME <- lme(bug~ treatment, method="REML", random = ~1|factor(group), data = myFrame)
            }
            else{
                fullModelLME <- lm(bug~ treatment, x=TRUE)
            }
            ## Potential save time by reducing anova calls
            ## Introduce the goodness of fit tests here
            ## Can streamline vectors to be automatically responsive to changes to the model
            if(mlm == TRUE){
                allNames <- rownames(anova(fullModelLME))[-1]
                allpvals[[index]] <- anova(fullModelLME)$"p-value"[-1]
            }
            else {
                allNames <- rownames(anova(fullModelLME))[-dim(anova(fullModelLME))[1]]
                allpvals[[index]]<-as.data.frame(anova(fullModelLME))[1:dim(anova(fullModelLME))[1]-1,5]
            }

            ## Random Effects and Interclass Correlation Coefficient
            if(mlm == TRUE){
                allNames<-c(allNames, "cage", "iccCage")
                allpvals[[index]]<-c(allpvals[[index]], anova(fullModelLME, reducedModel)$"p-value"[2], coef(fullModel$modelStruct[1]$corStruct,unconstrained=FALSE)[[1]])
                pValuesCage[index] <-  anova(fullModelLME, reducedModel)$"p-value"[2]
                ## This is different as it is not corrected for multiple hypothesis testing.
                iccCage[index]<- coef(fullModel$modelStruct[1]$corStruct,unconstrained=FALSE)[[1]]
            }
    ## Nice plotting
            ## Correct so that it uses corrected p-values
            if(mlm == TRUE){
                graphMain = c(names[i], paste(c(rep("p-",length(allNames)-1),""), allNames, " = ", format(allpvals[[index]], digits=3), sep=""))
            }
            else {
                graphMain = c(names[i], paste(c(rep("p-",length(allNames)),""), allNames, " = ", format(allpvals[[index]], digits=3), sep=""))

            }

            ## mlm is boolean 1/0 value. Basically, don't graph on icc
            ## need a correction for interaction terms as well
            numPlots <- length(allNames) - mlm
            par(mfrow=c(numPlots, 1),
                oma = c(1,1,0,0) + 0.1,
                mar = c(1,4,3,0) + 0.1)

            for(j in 1:numPlots){
                if(j == 1){
                    plot( bug ~ factor(get(allNames[j])), ylab = names[i], main = c(names[index],toString(graphMain[-1])) )
                    points(factor(get(allNames[j])), bug)
                }
                else{
                    testInteract <- grep(":", allNames)
                    if(length(testInteract) > 0){
                        if(j %in% testInteract){
                            intSplit <- unlist(strsplit(allNames[grep(":",allNames)[which(grep(":", allNames) == j)]],split=":"))
                            if(length(intSplit) == 2){
                                plot( bug ~ factor(c( paste( get(intSplit[1]), get(intSplit[2]),sep=""))))
                                points(factor(c( paste( get(intSplit[1]), get(intSplit[2]),sep=""))), bug)
                            }
                            else{
                                plot( bug ~ factor(c( paste( get(intSplit[1]), get(intSplit[2]), get(intSplit[3]),sep=""))))
                                points(factor(c( paste( get(intSplit[1]), get(intSplit[2]), get(intSplit[3]),sep=""))), bug)
                            }
                        }
                    }
                    else{
                        plot( bug ~ factor(get(allNames[j])), ylab = names[i])
                        points(factor(get(allNames[j])), bug)
                    }
                }
            }

            index <- index + 1
	}

    ## This should also be dynamic
    dFrame <- as.data.frame(matrix(unlist(allpvals), nrow= length(allpvals), byrow=TRUE))
    colnames(dFrame) <- unlist(allNames)
    rownames(dFrame) <- names
    orgCol <- ncol(dFrame)

    for(k in 1:(orgCol-mlm)){
        dFrame[, k + orgCol]<-p.adjust(dFrame[,k], method = "BH")
    }
    colnames(dFrame)[(orgCol + 1):length(dFrame)]<-paste0(rep("adjusted_"),colnames(dFrame)[1:(orgCol - mlm)])

    dFrame <- cbind(names, dFrame)
    ## Try and dynamically generate the name of the plot here...
    write.table(dFrame, file=paste("pValues", filePrefix, taxa, ".txt",sep=""), sep="\t",row.names=FALSE)

    ## Get the sig table working
    ## It would also be nice to have a sig-picker for the plots and a combination of all sig results into one plot.
    keepVector <- grep("adj", names(dFrame))
    sigdFrame <-dFrame[which(dFrame[,keepVector] < 0.05,arr.ind=TRUE),]
    write.table(sigdFrame, file=paste("SIGpValues", filePrefix, taxa, ".txt",sep=""), sep="\t",row.names=FALSE)

    dev.off()
}

rm(list=ls())

library("pscl")
library("lmtest")
library("nlme")
library("vegan")

setwd("/Users/mbrown67/Documents/Fodor/Datasets/MarkExperiment/Pooled/")

taxaLevels <- c( "phylum", "class", "order", "family", "genus")

filePrefix <- "_treatment_onebatch_onetime_"
mlm<- FALSE

dropBatch <- "Lyte_Batch04_Run01_repeat"
dropTime <- 9
dropTreatment <- "Exp"

for(taxa in taxaLevels){

    inFileName <- paste( taxa, "LogNormwithMetadata_R1_Pooled.txt", sep ="")
    myT <-read.csv(inFileName,header=TRUE,sep="", na.strings="BLAH")

    numCols <- ncol(myT)
    numMetadataCols <- 20

    ## Reprocessing for correct column data type
    myColClasses <- c("character", rep("numeric", numCols - numMetadataCols - 1), rep("character", 11), "numeric", "numeric", "numeric", "character", "character", "character", "character", "character", "character")
    myT <-read.csv(inFileName, header=TRUE, sep="", colClasses=myColClasses, na.strings="BLAH", comment.char ="@")

    ## Removing unwanted samples {controls, replicates, duplicates, poor quality samples}
    removeControls<-c( "C1", "C2", "N1", "N2", "Neg", "Pos")
    myT<-myT[!(myT$Sample_ID %in% removeControls),]

    removetrs<-c("04_125_tr", "04_101_tr", "04_103_tr", "04_74_tr", "04_70_tr", "04_40_tr", "04_41_tr", "04_84_tr")
    myT<-myT[!(myT$Sample_ID %in% removetrs),]

    removeDups<-c("04-04_S63_L001_R1_001")
    myT<-myT[!(myT$MatchFile %in% removeDups),]

    ## Controls not dropped earlier
    manualDrop <- c("Neg_S40_L001_R1_001", "PCR1Neg_S65_L001_R1_001")
    myT<-myT[!(myT$MatchFile %in% manualDrop),]

    labDrop <- c("Harlan Labs")
    myT<-myT[!(myT$MouseOrigin %in% labDrop),]

    lowSeqDrop <- c("04-55_S32_L001_R1_001")
    myT<-myT[!(myT$MatchFile %in% lowSeqDrop),]
    ## Not sure what to do about this though.
    ### myT$Condition[which(myT$Treatment == "Ctrl", arr.ind = TRUE)]<-"Control"

    myT<-myT[(myT$Sample_Plate == dropBatch),]
    myT<-myT[myT$StressLength == dropTime,]

    names <- vector()
    pValuesSex<- vector()
    pValuesAcuteChronic<- vector()
    pValuesCage<- vector()
    iccCage <- vector()
    iccKeptCounts <- vector()
    pValuesBatch<- vector()
    pValuesTreatment<- vector()
    pValuesTime <- vector()
    pValuesStressLength <- vector()
    pValuesInteraction <- vector()
    allpvals <- list()

    index <- 1
    pdf( paste(taxa, filePrefix, "boxplots.pdf", sep=""))

    for( i in 2:(ncol(myT) - numMetadataCols))
        if( sum(myT[,i] != 0 ) > nrow(myT) / 4 ){
            ## Easy access names
            bug <- myT[,i]
            ac <- myT$Condition
            sex <- myT$Sex
            cage <- myT$Cage
            batch <- myT$Sample_Plate
            date <- myT$Date
            mo <- myT$MouseOrigin
            group <- myT$SpreadsheetGrouping
            treatment <- myT$Treatment
            time <- myT$StressLength
            multiWay <- paste(ac, myT$StressLength)
            multiWay[which(myT$Treatment == "Ctrl", arr.ind = TRUE)]<-"Control"
            names[index] = names(myT)[i]
            ## Some kind of vector for the variables of interest
            myFrame <- data.frame(bug, ac, time, multiWay, sex, cage, treatment, batch, date, mo, date)
            if(mlm == TRUE){
                fullModel <- gls( bug~ treatment, method="REML",correlation=corCompSymm(form=~1|factor(group)),	data = myFrame )
                reducedModel <- gls( bug~ treatment, method="REML", data = myFrame )
                fullModelLME <- lme(bug~ treatment, method="REML", random = ~1|factor(group), data = myFrame)
            }
            else{
                fullModelLME <- lm(bug~ treatment, x=TRUE)
            }
            ## Potential save time by reducing anova calls
            ## Introduce the goodness of fit tests here
            ## Can streamline vectors to be automatically responsive to changes to the model
            if(mlm == TRUE){
                allNames <- rownames(anova(fullModelLME))[-1]
                allpvals[[index]] <- anova(fullModelLME)$"p-value"[-1]
            }
            else {
                allNames <- rownames(anova(fullModelLME))[-dim(anova(fullModelLME))[1]]
                allpvals[[index]]<-as.data.frame(anova(fullModelLME))[1:dim(anova(fullModelLME))[1]-1,5]
            }

            ## Random Effects and Interclass Correlation Coefficient
            if(mlm == TRUE){
                allNames<-c(allNames, "cage", "iccCage")
                allpvals[[index]]<-c(allpvals[[index]], anova(fullModelLME, reducedModel)$"p-value"[2], coef(fullModel$modelStruct[1]$corStruct,unconstrained=FALSE)[[1]])
                pValuesCage[index] <-  anova(fullModelLME, reducedModel)$"p-value"[2]
                ## This is different as it is not corrected for multiple hypothesis testing.
                iccCage[index]<- coef(fullModel$modelStruct[1]$corStruct,unconstrained=FALSE)[[1]]
            }
    ## Nice plotting
            ## Correct so that it uses corrected p-values
            if(mlm == TRUE){
                graphMain = c(names[i], paste(c(rep("p-",length(allNames)-1),""), allNames, " = ", format(allpvals[[index]], digits=3), sep=""))
            }
            else {
                graphMain = c(names[i], paste(c(rep("p-",length(allNames)),""), allNames, " = ", format(allpvals[[index]], digits=3), sep=""))

            }

            ## mlm is boolean 1/0 value. Basically, don't graph on icc
            ## need a correction for interaction terms as well
            numPlots <- length(allNames) - mlm
            par(mfrow=c(numPlots, 1),
                oma = c(1,1,0,0) + 0.1,
                mar = c(1,4,3,0) + 0.1)

            for(j in 1:numPlots){
                if(j == 1){
                    plot( bug ~ factor(get(allNames[j])), ylab = names[i], main = c(names[index],toString(graphMain[-1])) )
                    points(factor(get(allNames[j])), bug)
                }
                else{
                    testInteract <- grep(":", allNames)
                    if(length(testInteract) > 0){
                        if(j %in% testInteract){
                            intSplit <- unlist(strsplit(allNames[grep(":",allNames)[which(grep(":", allNames) == j)]],split=":"))
                            if(length(intSplit) == 2){
                                plot( bug ~ factor(c( paste( get(intSplit[1]), get(intSplit[2]),sep=""))))
                                points(factor(c( paste( get(intSplit[1]), get(intSplit[2]),sep=""))), bug)
                            }
                            else{
                                plot( bug ~ factor(c( paste( get(intSplit[1]), get(intSplit[2]), get(intSplit[3]),sep=""))))
                                points(factor(c( paste( get(intSplit[1]), get(intSplit[2]), get(intSplit[3]),sep=""))), bug)
                            }
                        }
                    }
                    else{
                        plot( bug ~ factor(get(allNames[j])), ylab = names[i])
                        points(factor(get(allNames[j])), bug)
                    }
                }
            }

            index <- index + 1
	}

    ## This should also be dynamic
    dFrame <- as.data.frame(matrix(unlist(allpvals), nrow= length(allpvals), byrow=TRUE))
    colnames(dFrame) <- unlist(allNames)
    rownames(dFrame) <- names
    orgCol <- ncol(dFrame)

    for(k in 1:(orgCol-mlm)){
        dFrame[, k + orgCol]<-p.adjust(dFrame[,k], method = "BH")
    }
    colnames(dFrame)[(orgCol + 1):length(dFrame)]<-paste0(rep("adjusted_"),colnames(dFrame)[1:(orgCol - mlm)])

    dFrame <- cbind(names, dFrame)
    ## Try and dynamically generate the name of the plot here...
    write.table(dFrame, file=paste("pValues", filePrefix, taxa, ".txt",sep=""), sep="\t",row.names=FALSE)

    ## Get the sig table working
    ## It would also be nice to have a sig-picker for the plots and a combination of all sig results into one plot.
    keepVector <- grep("adj", names(dFrame))
    sigdFrame <-dFrame[which(dFrame[,keepVector] < 0.05,arr.ind=TRUE),]
    write.table(sigdFrame, file=paste("SIGpValues", filePrefix, taxa, ".txt",sep=""), sep="\t",row.names=FALSE)

    dev.off()
}

rm(list=ls())

library("pscl")
library("lmtest")
library("nlme")
library("vegan")

setwd("/Users/mbrown67/Documents/Fodor/Datasets/MarkExperiment/Pooled/")

taxaLevels <- c( "phylum", "class", "order", "family", "genus")

filePrefix <- "_treatment_onebatch_onetime_"
mlm<- FALSE

dropBatch <- "Lyte_Batch04_Run01_repeat"
dropTime <- 9
dropTreatment <- "Exp"

for(taxa in taxaLevels){

    inFileName <- paste( taxa, "LogNormwithMetadata_R1_Pooled.txt", sep ="")
    myT <-read.csv(inFileName,header=TRUE,sep="", na.strings="BLAH")

    numCols <- ncol(myT)
    numMetadataCols <- 20

    ## Reprocessing for correct column data type
    myColClasses <- c("character", rep("numeric", numCols - numMetadataCols - 1), rep("character", 11), "numeric", "numeric", "numeric", "character", "character", "character", "character", "character", "character")
    myT <-read.csv(inFileName, header=TRUE, sep="", colClasses=myColClasses, na.strings="BLAH", comment.char ="@")

    ## Removing unwanted samples {controls, replicates, duplicates, poor quality samples}
    removeControls<-c( "C1", "C2", "N1", "N2", "Neg", "Pos")
    myT<-myT[!(myT$Sample_ID %in% removeControls),]

    removetrs<-c("04_125_tr", "04_101_tr", "04_103_tr", "04_74_tr", "04_70_tr", "04_40_tr", "04_41_tr", "04_84_tr")
    myT<-myT[!(myT$Sample_ID %in% removetrs),]

    removeDups<-c("04-04_S63_L001_R1_001")
    myT<-myT[!(myT$MatchFile %in% removeDups),]

    ## Controls not dropped earlier
    manualDrop <- c("Neg_S40_L001_R1_001", "PCR1Neg_S65_L001_R1_001")
    myT<-myT[!(myT$MatchFile %in% manualDrop),]

    labDrop <- c("Harlan Labs")
    myT<-myT[!(myT$MouseOrigin %in% labDrop),]

    lowSeqDrop <- c("04-55_S32_L001_R1_001")
    myT<-myT[!(myT$MatchFile %in% lowSeqDrop),]
    ## Not sure what to do about this though.
    ### myT$Condition[which(myT$Treatment == "Ctrl", arr.ind = TRUE)]<-"Control"

    myT<-myT[!(myT$Sample_Plate == dropBatch),]
    myT<-myT[myT$StressLength == dropTime,]

    names <- vector()
    pValuesSex<- vector()
    pValuesAcuteChronic<- vector()
    pValuesCage<- vector()
    iccCage <- vector()
    iccKeptCounts <- vector()
    pValuesBatch<- vector()
    pValuesTreatment<- vector()
    pValuesTime <- vector()
    pValuesStressLength <- vector()
    pValuesInteraction <- vector()
    allpvals <- list()

    index <- 1
    pdf( paste(taxa, filePrefix, "boxplots.pdf", sep=""))

    for( i in 2:(ncol(myT) - numMetadataCols))
        if( sum(myT[,i] != 0 ) > nrow(myT) / 4 ){
            ## Easy access names
            bug <- myT[,i]
            ac <- myT$Condition
            sex <- myT$Sex
            cage <- myT$Cage
            batch <- myT$Sample_Plate
            date <- myT$Date
            mo <- myT$MouseOrigin
            group <- myT$SpreadsheetGrouping
            treatment <- myT$Treatment
            time <- myT$StressLength
            multiWay <- paste(ac, myT$StressLength)
            multiWay[which(myT$Treatment == "Ctrl", arr.ind = TRUE)]<-"Control"
            names[index] = names(myT)[i]
            ## Some kind of vector for the variables of interest
            myFrame <- data.frame(bug, ac, time, multiWay, sex, cage, treatment, batch, date, mo, date)
            if(mlm == TRUE){
                fullModel <- gls( bug~ treatment, method="REML",correlation=corCompSymm(form=~1|factor(group)),	data = myFrame )
                reducedModel <- gls( bug~ treatment, method="REML", data = myFrame )
                fullModelLME <- lme(bug~ treatment, method="REML", random = ~1|factor(group), data = myFrame)
            }
            else{
                fullModelLME <- lm(bug~ treatment, x=TRUE)
            }
            ## Potential save time by reducing anova calls
            ## Introduce the goodness of fit tests here
            ## Can streamline vectors to be automatically responsive to changes to the model
            if(mlm == TRUE){
                allNames <- rownames(anova(fullModelLME))[-1]
                allpvals[[index]] <- anova(fullModelLME)$"p-value"[-1]
            }
            else {
                allNames <- rownames(anova(fullModelLME))[-dim(anova(fullModelLME))[1]]
                allpvals[[index]]<-as.data.frame(anova(fullModelLME))[1:dim(anova(fullModelLME))[1]-1,5]
            }

            ## Random Effects and Interclass Correlation Coefficient
            if(mlm == TRUE){
                allNames<-c(allNames, "cage", "iccCage")
                allpvals[[index]]<-c(allpvals[[index]], anova(fullModelLME, reducedModel)$"p-value"[2], coef(fullModel$modelStruct[1]$corStruct,unconstrained=FALSE)[[1]])
                pValuesCage[index] <-  anova(fullModelLME, reducedModel)$"p-value"[2]
                ## This is different as it is not corrected for multiple hypothesis testing.
                iccCage[index]<- coef(fullModel$modelStruct[1]$corStruct,unconstrained=FALSE)[[1]]
            }
    ## Nice plotting
            ## Correct so that it uses corrected p-values
            if(mlm == TRUE){
                graphMain = c(names[i], paste(c(rep("p-",length(allNames)-1),""), allNames, " = ", format(allpvals[[index]], digits=3), sep=""))
            }
            else {
                graphMain = c(names[i], paste(c(rep("p-",length(allNames)),""), allNames, " = ", format(allpvals[[index]], digits=3), sep=""))

            }

            ## mlm is boolean 1/0 value. Basically, don't graph on icc
            ## need a correction for interaction terms as well
            numPlots <- length(allNames) - mlm
            par(mfrow=c(numPlots, 1),
                oma = c(1,1,0,0) + 0.1,
                mar = c(1,4,3,0) + 0.1)

            for(j in 1:numPlots){
                if(j == 1){
                    plot( bug ~ factor(get(allNames[j])), ylab = names[i], main = c(names[index],toString(graphMain[-1])) )
                    points(factor(get(allNames[j])), bug)
                }
                else{
                    testInteract <- grep(":", allNames)
                    if(length(testInteract) > 0){
                        if(j %in% testInteract){
                            intSplit <- unlist(strsplit(allNames[grep(":",allNames)[which(grep(":", allNames) == j)]],split=":"))
                            if(length(intSplit) == 2){
                                plot( bug ~ factor(c( paste( get(intSplit[1]), get(intSplit[2]),sep=""))))
                                points(factor(c( paste( get(intSplit[1]), get(intSplit[2]),sep=""))), bug)
                            }
                            else{
                                plot( bug ~ factor(c( paste( get(intSplit[1]), get(intSplit[2]), get(intSplit[3]),sep=""))))
                                points(factor(c( paste( get(intSplit[1]), get(intSplit[2]), get(intSplit[3]),sep=""))), bug)
                            }
                        }
                    }
                    else{
                        plot( bug ~ factor(get(allNames[j])), ylab = names[i])
                        points(factor(get(allNames[j])), bug)
                    }
                }
            }

            index <- index + 1
	}

    ## This should also be dynamic
    dFrame <- as.data.frame(matrix(unlist(allpvals), nrow= length(allpvals), byrow=TRUE))
    colnames(dFrame) <- unlist(allNames)
    rownames(dFrame) <- names
    orgCol <- ncol(dFrame)

    for(k in 1:(orgCol-mlm)){
        dFrame[, k + orgCol]<-p.adjust(dFrame[,k], method = "BH")
    }
    colnames(dFrame)[(orgCol + 1):length(dFrame)]<-paste0(rep("adjusted_"),colnames(dFrame)[1:(orgCol - mlm)])

    dFrame <- cbind(names, dFrame)
    ## Try and dynamically generate the name of the plot here...
    write.table(dFrame, file=paste("pValues", filePrefix, taxa, ".txt",sep=""), sep="\t",row.names=FALSE)

    ## Get the sig table working
    ## It would also be nice to have a sig-picker for the plots and a combination of all sig results into one plot.
    keepVector <- grep("adj", names(dFrame))
    sigdFrame <-dFrame[which(dFrame[,keepVector] < 0.05,arr.ind=TRUE),]
    write.table(sigdFrame, file=paste("SIGpValues", filePrefix, taxa, ".txt",sep=""), sep="\t",row.names=FALSE)

    dev.off()
}

rm(list=ls())

library("pscl")
library("lmtest")
library("nlme")
library("vegan")

setwd("/Users/mbrown67/Documents/Fodor/Datasets/MarkExperiment/Pooled/")

taxaLevels <- c( "phylum", "class", "order", "family", "genus")

filePrefix <- "_treatment_onebatch_onetime_"
mlm<- FALSE

dropBatch <- "Lyte_Batch04_Run01_repeat"
dropTime <- 14
dropTreatment <- "Exp"

for(taxa in taxaLevels){

    inFileName <- paste( taxa, "LogNormwithMetadata_R1_Pooled.txt", sep ="")
    myT <-read.csv(inFileName,header=TRUE,sep="", na.strings="BLAH")

    numCols <- ncol(myT)
    numMetadataCols <- 20

    ## Reprocessing for correct column data type
    myColClasses <- c("character", rep("numeric", numCols - numMetadataCols - 1), rep("character", 11), "numeric", "numeric", "numeric", "character", "character", "character", "character", "character", "character")
    myT <-read.csv(inFileName, header=TRUE, sep="", colClasses=myColClasses, na.strings="BLAH", comment.char ="@")

    ## Removing unwanted samples {controls, replicates, duplicates, poor quality samples}
    removeControls<-c( "C1", "C2", "N1", "N2", "Neg", "Pos")
    myT<-myT[!(myT$Sample_ID %in% removeControls),]

    removetrs<-c("04_125_tr", "04_101_tr", "04_103_tr", "04_74_tr", "04_70_tr", "04_40_tr", "04_41_tr", "04_84_tr")
    myT<-myT[!(myT$Sample_ID %in% removetrs),]

    removeDups<-c("04-04_S63_L001_R1_001")
    myT<-myT[!(myT$MatchFile %in% removeDups),]

    ## Controls not dropped earlier
    manualDrop <- c("Neg_S40_L001_R1_001", "PCR1Neg_S65_L001_R1_001")
    myT<-myT[!(myT$MatchFile %in% manualDrop),]

    labDrop <- c("Harlan Labs")
    myT<-myT[!(myT$MouseOrigin %in% labDrop),]

    lowSeqDrop <- c("04-55_S32_L001_R1_001")
    myT<-myT[!(myT$MatchFile %in% lowSeqDrop),]
    ## Not sure what to do about this though.
    ### myT$Condition[which(myT$Treatment == "Ctrl", arr.ind = TRUE)]<-"Control"

    myT<-myT[(myT$Sample_Plate == dropBatch),]
    myT<-myT[myT$StressLength == dropTime,]

    names <- vector()
    pValuesSex<- vector()
    pValuesAcuteChronic<- vector()
    pValuesCage<- vector()
    iccCage <- vector()
    iccKeptCounts <- vector()
    pValuesBatch<- vector()
    pValuesTreatment<- vector()
    pValuesTime <- vector()
    pValuesStressLength <- vector()
    pValuesInteraction <- vector()
    allpvals <- list()

    index <- 1
    pdf( paste(taxa, filePrefix, "boxplots.pdf", sep=""))

    for( i in 2:(ncol(myT) - numMetadataCols))
        if( sum(myT[,i] != 0 ) > nrow(myT) / 4 ){
            ## Easy access names
            bug <- myT[,i]
            ac <- myT$Condition
            sex <- myT$Sex
            cage <- myT$Cage
            batch <- myT$Sample_Plate
            date <- myT$Date
            mo <- myT$MouseOrigin
            group <- myT$SpreadsheetGrouping
            treatment <- myT$Treatment
            time <- myT$StressLength
            multiWay <- paste(ac, myT$StressLength)
            multiWay[which(myT$Treatment == "Ctrl", arr.ind = TRUE)]<-"Control"
            names[index] = names(myT)[i]
            ## Some kind of vector for the variables of interest
            myFrame <- data.frame(bug, ac, time, multiWay, sex, cage, treatment, batch, date, mo, date)
            if(mlm == TRUE){
                fullModel <- gls( bug~ treatment, method="REML",correlation=corCompSymm(form=~1|factor(group)),	data = myFrame )
                reducedModel <- gls( bug~ treatment, method="REML", data = myFrame )
                fullModelLME <- lme(bug~ treatment, method="REML", random = ~1|factor(group), data = myFrame)
            }
            else{
                fullModelLME <- lm(bug~ treatment, x=TRUE)
            }
            ## Potential save time by reducing anova calls
            ## Introduce the goodness of fit tests here
            ## Can streamline vectors to be automatically responsive to changes to the model
            if(mlm == TRUE){
                allNames <- rownames(anova(fullModelLME))[-1]
                allpvals[[index]] <- anova(fullModelLME)$"p-value"[-1]
            }
            else {
                allNames <- rownames(anova(fullModelLME))[-dim(anova(fullModelLME))[1]]
                allpvals[[index]]<-as.data.frame(anova(fullModelLME))[1:dim(anova(fullModelLME))[1]-1,5]
            }

            ## Random Effects and Interclass Correlation Coefficient
            if(mlm == TRUE){
                allNames<-c(allNames, "cage", "iccCage")
                allpvals[[index]]<-c(allpvals[[index]], anova(fullModelLME, reducedModel)$"p-value"[2], coef(fullModel$modelStruct[1]$corStruct,unconstrained=FALSE)[[1]])
                pValuesCage[index] <-  anova(fullModelLME, reducedModel)$"p-value"[2]
                ## This is different as it is not corrected for multiple hypothesis testing.
                iccCage[index]<- coef(fullModel$modelStruct[1]$corStruct,unconstrained=FALSE)[[1]]
            }
    ## Nice plotting
            ## Correct so that it uses corrected p-values
            if(mlm == TRUE){
                graphMain = c(names[i], paste(c(rep("p-",length(allNames)-1),""), allNames, " = ", format(allpvals[[index]], digits=3), sep=""))
            }
            else {
                graphMain = c(names[i], paste(c(rep("p-",length(allNames)),""), allNames, " = ", format(allpvals[[index]], digits=3), sep=""))

            }

            ## mlm is boolean 1/0 value. Basically, don't graph on icc
            ## need a correction for interaction terms as well
            numPlots <- length(allNames) - mlm
            par(mfrow=c(numPlots, 1),
                oma = c(1,1,0,0) + 0.1,
                mar = c(1,4,3,0) + 0.1)

            for(j in 1:numPlots){
                if(j == 1){
                    plot( bug ~ factor(get(allNames[j])), ylab = names[i], main = c(names[index],toString(graphMain[-1])) )
                    points(factor(get(allNames[j])), bug)
                }
                else{
                    testInteract <- grep(":", allNames)
                    if(length(testInteract) > 0){
                        if(j %in% testInteract){
                            intSplit <- unlist(strsplit(allNames[grep(":",allNames)[which(grep(":", allNames) == j)]],split=":"))
                            if(length(intSplit) == 2){
                                plot( bug ~ factor(c( paste( get(intSplit[1]), get(intSplit[2]),sep=""))))
                                points(factor(c( paste( get(intSplit[1]), get(intSplit[2]),sep=""))), bug)
                            }
                            else{
                                plot( bug ~ factor(c( paste( get(intSplit[1]), get(intSplit[2]), get(intSplit[3]),sep=""))))
                                points(factor(c( paste( get(intSplit[1]), get(intSplit[2]), get(intSplit[3]),sep=""))), bug)
                            }
                        }
                    }
                    else{
                        plot( bug ~ factor(get(allNames[j])), ylab = names[i])
                        points(factor(get(allNames[j])), bug)
                    }
                }
            }

            index <- index + 1
	}

    ## This should also be dynamic
    dFrame <- as.data.frame(matrix(unlist(allpvals), nrow= length(allpvals), byrow=TRUE))
    colnames(dFrame) <- unlist(allNames)
    rownames(dFrame) <- names
    orgCol <- ncol(dFrame)

    for(k in 1:(orgCol-mlm)){
        dFrame[, k + orgCol]<-p.adjust(dFrame[,k], method = "BH")
    }
    colnames(dFrame)[(orgCol + 1):length(dFrame)]<-paste0(rep("adjusted_"),colnames(dFrame)[1:(orgCol - mlm)])

    dFrame <- cbind(names, dFrame)
    ## Try and dynamically generate the name of the plot here...
    write.table(dFrame, file=paste("pValues", filePrefix, taxa, ".txt",sep=""), sep="\t",row.names=FALSE)

    ## Get the sig table working
    ## It would also be nice to have a sig-picker for the plots and a combination of all sig results into one plot.
    keepVector <- grep("adj", names(dFrame))
    sigdFrame <-dFrame[which(dFrame[,keepVector] < 0.05,arr.ind=TRUE),]
    write.table(sigdFrame, file=paste("SIGpValues", filePrefix, taxa, ".txt",sep=""), sep="\t",row.names=FALSE)

    dev.off()
}

rm(list=ls())

library("pscl")
library("lmtest")
library("nlme")
library("vegan")

setwd("/Users/mbrown67/Documents/Fodor/Datasets/MarkExperiment/Pooled/")

taxaLevels <- c( "phylum", "class", "order", "family", "genus")

filePrefix <- "_treatment_onebatch_onetime_"
mlm<- FALSE

dropBatch <- "Lyte_Batch04_Run01_repeat"
dropTime <- 14
dropTreatment <- "Exp"

for(taxa in taxaLevels){

    inFileName <- paste( taxa, "LogNormwithMetadata_R1_Pooled.txt", sep ="")
    myT <-read.csv(inFileName,header=TRUE,sep="", na.strings="BLAH")

    numCols <- ncol(myT)
    numMetadataCols <- 20

    ## Reprocessing for correct column data type
    myColClasses <- c("character", rep("numeric", numCols - numMetadataCols - 1), rep("character", 11), "numeric", "numeric", "numeric", "character", "character", "character", "character", "character", "character")
    myT <-read.csv(inFileName, header=TRUE, sep="", colClasses=myColClasses, na.strings="BLAH", comment.char ="@")

    ## Removing unwanted samples {controls, replicates, duplicates, poor quality samples}
    removeControls<-c( "C1", "C2", "N1", "N2", "Neg", "Pos")
    myT<-myT[!(myT$Sample_ID %in% removeControls),]

    removetrs<-c("04_125_tr", "04_101_tr", "04_103_tr", "04_74_tr", "04_70_tr", "04_40_tr", "04_41_tr", "04_84_tr")
    myT<-myT[!(myT$Sample_ID %in% removetrs),]

    removeDups<-c("04-04_S63_L001_R1_001")
    myT<-myT[!(myT$MatchFile %in% removeDups),]

    ## Controls not dropped earlier
    manualDrop <- c("Neg_S40_L001_R1_001", "PCR1Neg_S65_L001_R1_001")
    myT<-myT[!(myT$MatchFile %in% manualDrop),]

    labDrop <- c("Harlan Labs")
    myT<-myT[!(myT$MouseOrigin %in% labDrop),]

    lowSeqDrop <- c("04-55_S32_L001_R1_001")
    myT<-myT[!(myT$MatchFile %in% lowSeqDrop),]
    ## Not sure what to do about this though.
    ### myT$Condition[which(myT$Treatment == "Ctrl", arr.ind = TRUE)]<-"Control"

    myT<-myT[!(myT$Sample_Plate == dropBatch),]
    myT<-myT[myT$StressLength == dropTime,]

    names <- vector()
    pValuesSex<- vector()
    pValuesAcuteChronic<- vector()
    pValuesCage<- vector()
    iccCage <- vector()
    iccKeptCounts <- vector()
    pValuesBatch<- vector()
    pValuesTreatment<- vector()
    pValuesTime <- vector()
    pValuesStressLength <- vector()
    pValuesInteraction <- vector()
    allpvals <- list()

    index <- 1
    pdf( paste(taxa, filePrefix, "boxplots.pdf", sep=""))

    for( i in 2:(ncol(myT) - numMetadataCols))
        if( sum(myT[,i] != 0 ) > nrow(myT) / 4 ){
            ## Easy access names
            bug <- myT[,i]
            ac <- myT$Condition
            sex <- myT$Sex
            cage <- myT$Cage
            batch <- myT$Sample_Plate
            date <- myT$Date
            mo <- myT$MouseOrigin
            group <- myT$SpreadsheetGrouping
            treatment <- myT$Treatment
            time <- myT$StressLength
            multiWay <- paste(ac, myT$StressLength)
            multiWay[which(myT$Treatment == "Ctrl", arr.ind = TRUE)]<-"Control"
            names[index] = names(myT)[i]
            ## Some kind of vector for the variables of interest
            myFrame <- data.frame(bug, ac, time, multiWay, sex, cage, treatment, batch, date, mo, date)
            if(mlm == TRUE){
                fullModel <- gls( bug~ treatment, method="REML",correlation=corCompSymm(form=~1|factor(group)),	data = myFrame )
                reducedModel <- gls( bug~ treatment, method="REML", data = myFrame )
                fullModelLME <- lme(bug~ treatment, method="REML", random = ~1|factor(group), data = myFrame)
            }
            else{
                fullModelLME <- lm(bug~ treatment, x=TRUE)
            }
            ## Potential save time by reducing anova calls
            ## Introduce the goodness of fit tests here
            ## Can streamline vectors to be automatically responsive to changes to the model
            if(mlm == TRUE){
                allNames <- rownames(anova(fullModelLME))[-1]
                allpvals[[index]] <- anova(fullModelLME)$"p-value"[-1]
            }
            else {
                allNames <- rownames(anova(fullModelLME))[-dim(anova(fullModelLME))[1]]
                allpvals[[index]]<-as.data.frame(anova(fullModelLME))[1:dim(anova(fullModelLME))[1]-1,5]
            }

            ## Random Effects and Interclass Correlation Coefficient
            if(mlm == TRUE){
                allNames<-c(allNames, "cage", "iccCage")
                allpvals[[index]]<-c(allpvals[[index]], anova(fullModelLME, reducedModel)$"p-value"[2], coef(fullModel$modelStruct[1]$corStruct,unconstrained=FALSE)[[1]])
                pValuesCage[index] <-  anova(fullModelLME, reducedModel)$"p-value"[2]
                ## This is different as it is not corrected for multiple hypothesis testing.
                iccCage[index]<- coef(fullModel$modelStruct[1]$corStruct,unconstrained=FALSE)[[1]]
            }
    ## Nice plotting
            ## Correct so that it uses corrected p-values
            if(mlm == TRUE){
                graphMain = c(names[i], paste(c(rep("p-",length(allNames)-1),""), allNames, " = ", format(allpvals[[index]], digits=3), sep=""))
            }
            else {
                graphMain = c(names[i], paste(c(rep("p-",length(allNames)),""), allNames, " = ", format(allpvals[[index]], digits=3), sep=""))

            }

            ## mlm is boolean 1/0 value. Basically, don't graph on icc
            ## need a correction for interaction terms as well
            numPlots <- length(allNames) - mlm
            par(mfrow=c(numPlots, 1),
                oma = c(1,1,0,0) + 0.1,
                mar = c(1,4,3,0) + 0.1)

            for(j in 1:numPlots){
                if(j == 1){
                    plot( bug ~ factor(get(allNames[j])), ylab = names[i], main = c(names[index],toString(graphMain[-1])) )
                    points(factor(get(allNames[j])), bug)
                }
                else{
                    testInteract <- grep(":", allNames)
                    if(length(testInteract) > 0){
                        if(j %in% testInteract){
                            intSplit <- unlist(strsplit(allNames[grep(":",allNames)[which(grep(":", allNames) == j)]],split=":"))
                            if(length(intSplit) == 2){
                                plot( bug ~ factor(c( paste( get(intSplit[1]), get(intSplit[2]),sep=""))))
                                points(factor(c( paste( get(intSplit[1]), get(intSplit[2]),sep=""))), bug)
                            }
                            else{
                                plot( bug ~ factor(c( paste( get(intSplit[1]), get(intSplit[2]), get(intSplit[3]),sep=""))))
                                points(factor(c( paste( get(intSplit[1]), get(intSplit[2]), get(intSplit[3]),sep=""))), bug)
                            }
                        }
                    }
                    else{
                        plot( bug ~ factor(get(allNames[j])), ylab = names[i])
                        points(factor(get(allNames[j])), bug)
                    }
                }
            }

            index <- index + 1
	}

    ## This should also be dynamic
    dFrame <- as.data.frame(matrix(unlist(allpvals), nrow= length(allpvals), byrow=TRUE))
    colnames(dFrame) <- unlist(allNames)
    rownames(dFrame) <- names
    orgCol <- ncol(dFrame)

    for(k in 1:(orgCol-mlm)){
        dFrame[, k + orgCol]<-p.adjust(dFrame[,k], method = "BH")
    }
    colnames(dFrame)[(orgCol + 1):length(dFrame)]<-paste0(rep("adjusted_"),colnames(dFrame)[1:(orgCol - mlm)])

    dFrame <- cbind(names, dFrame)
    ## Try and dynamically generate the name of the plot here...
    write.table(dFrame, file=paste("pValues", filePrefix, taxa, ".txt",sep=""), sep="\t",row.names=FALSE)

    ## Get the sig table working
    ## It would also be nice to have a sig-picker for the plots and a combination of all sig results into one plot.
    keepVector <- grep("adj", names(dFrame))
    sigdFrame <-dFrame[which(dFrame[,keepVector] < 0.05,arr.ind=TRUE),]
    write.table(sigdFrame, file=paste("SIGpValues", filePrefix, taxa, ".txt",sep=""), sep="\t",row.names=FALSE)

    dev.off()
}

99*99
12^2
4^2*3^2
2^3*3^2
25*60
26*16*5
2^6
3^5
2^3*3*5
2^2*3^2
3^3*5^2
3^2*5^2
2*3*5
2*3*13
99*99
10^2
2^2*5^2
40000*40000*
1
2^63
rm(list=ls())
library("vegan")
library("calibrate")

setwd("/Users/mbrown67/Documents/Fodor/Datasets/MarkExperiment/Pooled/")

taxaLevels <- c( "phylum", "class", "order", "family", "genus" )

checkSizes <- read.csv("phylumRawwithMetadata_R1_Pooled.txt", header=TRUE, sep="", na.strings="BLAH")

checkMerge<-cbind(checkSizes,sampleSizes)

SeqControl <- c("DNAC1_S69_L001_R1_001", "DNAC2_S70_L001_R1_001", "DNAN1_S71_L001_R1_001", "DNAN2_S72_L001_R1_001", "Neg_S40_L001_R1_001",
                    "PCR1Neg_S65_L001_R1_001", "PCR2Pos_S66_L001_R1_001", "Pos_S41_L001_R1_001")
TechControl<-c("04_125_tr", "04_101_tr", "04_103_tr", "04_74_tr", "04_70_tr", "04_40_tr",  "04_41_tr", "04_84_tr", "C1", "C2", "N1", "N2", "Neg", "Pos")
removeReplicates<-c("04_125_tr", "04_101_tr", "04_103_tr", "04_74_tr", "04_70_tr",  "04_40_tr", "04_41_tr", "04_84_tr")
manualDrop <- c("Neg_S40_L001_R1_001", "PCR1Neg_S65_L001_R1_001")
labDrop <- c("Harlan Labs")
lowSeqDrop <- c("04-55_S32_L001_R1_001")
removeDups<-c("04-04_S63_L001_R1_001")

checkMerge<-checkMerge[!(checkMerge$Sample_ID %in% TechControl),]
checkMerge<-checkMerge[!(checkMerge$MatchFile %in% removeDups),]
checkMerge<-checkMerge[!(checkMerge$MatchFile %in% SeqControl),]
checkMerge<-checkMerge[!(checkMerge$MouseOrigin %in% labDrop),]
checkMerge<-checkMerge[!(checkMerge$MatchFile %in% lowSeqDrop),]

numMetadataCols <- 20

sampleSizes<-rowSums(checkSizes[,2:(ncol(checkSizes)-numMetadataCols)])


rm(list=ls())
library("vegan")
library("calibrate")

setwd("/Users/mbrown67/Documents/Fodor/Datasets/MarkExperiment/Pooled/")

taxaLevels <- c( "phylum", "class", "order", "family", "genus" )

checkSizes <- read.csv("phylumRawwithMetadata_R1_Pooled.txt", header=TRUE, sep="", na.strings="BLAH")
sampleSizes<-rowSums(checkSizes[,2:(ncol(checkSizes)-numMetadataCols)])
checkMerge<-cbind(checkSizes,sampleSizes)

SeqControl <- c("DNAC1_S69_L001_R1_001", "DNAC2_S70_L001_R1_001", "DNAN1_S71_L001_R1_001", "DNAN2_S72_L001_R1_001", "Neg_S40_L001_R1_001",
                    "PCR1Neg_S65_L001_R1_001", "PCR2Pos_S66_L001_R1_001", "Pos_S41_L001_R1_001")
TechControl<-c("04_125_tr", "04_101_tr", "04_103_tr", "04_74_tr", "04_70_tr", "04_40_tr",  "04_41_tr", "04_84_tr", "C1", "C2", "N1", "N2", "Neg", "Pos")
removeReplicates<-c("04_125_tr", "04_101_tr", "04_103_tr", "04_74_tr", "04_70_tr",  "04_40_tr", "04_41_tr", "04_84_tr")
manualDrop <- c("Neg_S40_L001_R1_001", "PCR1Neg_S65_L001_R1_001")
labDrop <- c("Harlan Labs")
lowSeqDrop <- c("04-55_S32_L001_R1_001")
removeDups<-c("04-04_S63_L001_R1_001")

checkMerge<-checkMerge[!(checkMerge$Sample_ID %in% TechControl),]
checkMerge<-checkMerge[!(checkMerge$MatchFile %in% removeDups),]
checkMerge<-checkMerge[!(checkMerge$MatchFile %in% SeqControl),]
checkMerge<-checkMerge[!(checkMerge$MouseOrigin %in% labDrop),]
checkMerge<-checkMerge[!(checkMerge$MatchFile %in% lowSeqDrop),]

numMetadataCols <- 20




rm(list=ls())
library("vegan")
library("calibrate")

setwd("/Users/mbrown67/Documents/Fodor/Datasets/MarkExperiment/Pooled/")

taxaLevels <- c( "phylum", "class", "order", "family", "genus" )
numMetadataCols <- 20
checkSizes <- read.csv("phylumRawwithMetadata_R1_Pooled.txt", header=TRUE, sep="", na.strings="BLAH")
sampleSizes<-rowSums(checkSizes[,2:(ncol(checkSizes)-numMetadataCols)])
checkMerge<-cbind(checkSizes,sampleSizes)

SeqControl <- c("DNAC1_S69_L001_R1_001", "DNAC2_S70_L001_R1_001", "DNAN1_S71_L001_R1_001", "DNAN2_S72_L001_R1_001", "Neg_S40_L001_R1_001",
                    "PCR1Neg_S65_L001_R1_001", "PCR2Pos_S66_L001_R1_001", "Pos_S41_L001_R1_001")
TechControl<-c("04_125_tr", "04_101_tr", "04_103_tr", "04_74_tr", "04_70_tr", "04_40_tr",  "04_41_tr", "04_84_tr", "C1", "C2", "N1", "N2", "Neg", "Pos")
removeReplicates<-c("04_125_tr", "04_101_tr", "04_103_tr", "04_74_tr", "04_70_tr",  "04_40_tr", "04_41_tr", "04_84_tr")
manualDrop <- c("Neg_S40_L001_R1_001", "PCR1Neg_S65_L001_R1_001")
labDrop <- c("Harlan Labs")
lowSeqDrop <- c("04-55_S32_L001_R1_001")
removeDups<-c("04-04_S63_L001_R1_001")

checkMerge<-checkMerge[!(checkMerge$Sample_ID %in% TechControl),]
checkMerge<-checkMerge[!(checkMerge$MatchFile %in% removeDups),]
checkMerge<-checkMerge[!(checkMerge$MatchFile %in% SeqControl),]
checkMerge<-checkMerge[!(checkMerge$MouseOrigin %in% labDrop),]
checkMerge<-checkMerge[!(checkMerge$MatchFile %in% lowSeqDrop),]

for(taxa in taxaLevels )
{
    inFileName <- paste( taxa, "LogNormwithMetadata_R1_Pooled.txt", sep ="")
    myT <-read.csv(inFileName,header=TRUE,sep="", na.strings="BLAH")
    numCols <- ncol(myT)

    myT<-myT[!(myT$MatchFile %in% SeqControl),]
    myT<-myT[!(myT$Sample_ID %in% removeReplicates),]
    myT<-myT[!(myT$MouseOrigin %in% labDrop),]
    myT<-myT[!(myT$MatchFile %in% removeDups),]
    myT<-myT[!(myT$MatchFile %in% manualDrop),]
    myT<-myT[!(myT$MatchFile %in% lowSeqDrop),]

    myMDS <- capscale(myT[,2:(ncol(myT)-numMetadataCols)]~1,distance="bray")

        # In the future add a scree plot component here.
        pdf( paste(taxa, "_checkbatch_topMDS_dropPilot.pdf",sep=""))
    for (xrun in 1:4) {
        for (yrun in 2:4) {
            if(xrun == yrun){
                break
            }

            plot(myMDS$CA$u[,xrun], myMDS$CA$u[,yrun],
                 xlab=paste("MDS",xrun,sep=""), ylab=paste("MDS",yrun,sep=""),
                 main=paste("PCoA at level:", taxa,sep=""), cex=2.0,
                 pch=16+myT$StressLength,
                 col=ifelse(myT$Sample_Plate=="Lyte_Batch04_repeat_batch02b", "red","blue"))
            textxy(myMDS$CA$u[,xrun],myMDS$CA$u[,yrun],labs=myT$Sample_ID,
                   cex=0.7, offset=0)
                    legend("topright",
# 		    c("Batch01", "Batch02", "Batch03",
c("Batch1", "Batch2", "Seq",
		    "Acute", "Chronic", "Control"),
		    pch=c(16, 17, 4, 16, 16),
		    col=c("black", "black", "black",
		    #"cornflowerblue", "pink"))
                    "blue", "red"))
                }
        }

        dev.off()
#       write.table(myMDS$CA$u, sep="\t", file=paste("pcoa_NoSeqControl", taxa, ".txt",sep=""))
#	write.table(myMDS$CA$eig,file=paste("eigenValues_NoSeqControl", taxa, ".txt", sep=""), sep="\t")

}

warnings()

### Dropping controls, replicates, duplicates and low sequence counts
for(taxa in taxaLevels )
{
    inFileName <- paste( taxa, "LogNormwithMetadata_R1_Pooled.txt", sep ="")
    myT <-read.csv(inFileName,header=TRUE,sep="", na.strings="BLAH")
    numCols <- ncol(myT)

    myT<-myT[!(myT$MatchFile %in% SeqControl),]
    myT<-myT[!(myT$Sample_ID %in% removeReplicates),]
    myT<-myT[!(myT$MouseOrigin %in% labDrop),]
    myT<-myT[!(myT$MatchFile %in% removeDups),]
    myT<-myT[!(myT$MatchFile %in% manualDrop),]
    myT<-myT[!(myT$MatchFile %in% lowSeqDrop),]

    myMDS <- capscale(myT[,2:(ncol(myT)-numMetadataCols)]~1,distance="bray")

        # In the future add a scree plot component here.
        pdf( paste(taxa, "_checkbatch_topMDS_dropPilot.pdf",sep=""))
    for (xrun in 1:4) {
        for (yrun in 2:4) {
            if(xrun == yrun){
                break
            }

            plot(myMDS$CA$u[,xrun], myMDS$CA$u[,yrun],
                 xlab=paste("MDS",xrun,sep=""), ylab=paste("MDS",yrun,sep=""),
                 main=paste("PCoA at level:", taxa,sep=""), cex=2.0,
                 pch=16+as.numeric(myT$StressLength),
                 col=ifelse(myT$Sample_Plate=="Lyte_Batch04_repeat_batch02b", "red","blue"))
            textxy(myMDS$CA$u[,xrun],myMDS$CA$u[,yrun],labs=myT$Sample_ID,
                   cex=0.7, offset=0)
                    legend("topright",
# 		    c("Batch01", "Batch02", "Batch03",
c("Batch1", "Batch2", "Seq",
		    "Acute", "Chronic", "Control"),
		    pch=c(16, 17, 4, 16, 16),
		    col=c("black", "black", "black",
		    #"cornflowerblue", "pink"))
                    "blue", "red"))
                }
        }

        dev.off()
#       write.table(myMDS$CA$u, sep="\t", file=paste("pcoa_NoSeqControl", taxa, ".txt",sep=""))
#	write.table(myMDS$CA$eig,file=paste("eigenValues_NoSeqControl", taxa, ".txt", sep=""), sep="\t")

}


### Dropping controls, replicates, duplicates and low sequence counts
for(taxa in taxaLevels )
{
    inFileName <- paste( taxa, "LogNormwithMetadata_R1_Pooled.txt", sep ="")
    myT <-read.csv(inFileName,header=TRUE,sep="", na.strings="BLAH")
    numCols <- ncol(myT)

    myT<-myT[!(myT$MatchFile %in% SeqControl),]
    myT<-myT[!(myT$Sample_ID %in% removeReplicates),]
    myT<-myT[!(myT$MouseOrigin %in% labDrop),]
    myT<-myT[!(myT$MatchFile %in% removeDups),]
    myT<-myT[!(myT$MatchFile %in% manualDrop),]
    myT<-myT[!(myT$MatchFile %in% lowSeqDrop),]

    myMDS <- capscale(myT[,2:(ncol(myT)-numMetadataCols)]~1,distance="bray")

        # In the future add a scree plot component here.
        pdf( paste(taxa, "_checkbatch_topMDS_dropPilot.pdf",sep=""))
    for (xrun in 1:4) {
        for (yrun in 2:4) {
            if(xrun == yrun){
                break
            }

            plot(myMDS$CA$u[,xrun], myMDS$CA$u[,yrun],
                 xlab=paste("MDS",xrun,sep=""), ylab=paste("MDS",yrun,sep=""),
                 main=paste("PCoA at level:", taxa,sep=""), cex=2.0,
                 pch=16+as.numeric(myT$StressLength),
                 col=ifelse(myT$Sample_Plate=="Lyte_Batch04_repeat_batch02b", "red","blue"))
            textxy(myMDS$CA$u[,xrun],myMDS$CA$u[,yrun],labs=myT$Sample_ID,
                   cex=0.7, offset=0)
            par(xpd=TRUE)
                    legend("topright",
# 		    c("Batch01", "Batch02", "Batch03",
c("Batch1", "Batch2", "Seq",
		    "Acute", "Chronic", "Control"),
		    pch=c(16, 17, 4, 16, 16),
		    col=c("black", "black", "black",
		    #"cornflowerblue", "pink"))
                    "blue", "red"))
                }
        }

        dev.off()
#       write.table(myMDS$CA$u, sep="\t", file=paste("pcoa_NoSeqControl", taxa, ".txt",sep=""))
#	write.table(myMDS$CA$eig,file=paste("eigenValues_NoSeqControl", taxa, ".txt", sep=""), sep="\t")

}


### Dropping controls, replicates, duplicates and low sequence counts
for(taxa in taxaLevels )
{
    inFileName <- paste( taxa, "LogNormwithMetadata_R1_Pooled.txt", sep ="")
    myT <-read.csv(inFileName,header=TRUE,sep="", na.strings="BLAH")
    numCols <- ncol(myT)

    myT<-myT[!(myT$MatchFile %in% SeqControl),]
    myT<-myT[!(myT$Sample_ID %in% removeReplicates),]
    myT<-myT[!(myT$MouseOrigin %in% labDrop),]
    myT<-myT[!(myT$MatchFile %in% removeDups),]
    myT<-myT[!(myT$MatchFile %in% manualDrop),]
    myT<-myT[!(myT$MatchFile %in% lowSeqDrop),]

    myMDS <- capscale(myT[,2:(ncol(myT)-numMetadataCols)]~1,distance="bray")

        # In the future add a scree plot component here.
        pdf( paste(taxa, "_checkbatch_topMDS_dropPilot.pdf",sep=""))
    for (xrun in 1:4) {
        for (yrun in 2:4) {
            if(xrun == yrun){
                break
            }

            plot(myMDS$CA$u[,xrun], myMDS$CA$u[,yrun],
                 xlab=paste("MDS",xrun,sep=""), ylab=paste("MDS",yrun,sep=""),
                 main=paste("PCoA at level:", taxa,sep=""), cex=2.0,
                 pch=16+as.numeric(myT$StressLength),
                 col=ifelse(myT$Sample_Plate=="Lyte_Batch04_repeat_batch02b", "red","blue"))
            textxy(myMDS$CA$u[,xrun],myMDS$CA$u[,yrun],labs=myT$Sample_ID,
                   cex=0.7, offset=0)
            par(xpd=TRUE)
                    legend(.25,.2,
# 		    c("Batch01", "Batch02", "Batch03",
c("Batch1", "Batch2", "Seq",
		    "Acute", "Chronic", "Control"),
		    pch=c(16, 17, 4, 16, 16),
		    col=c("black", "black", "black",
		    #"cornflowerblue", "pink"))
                    "blue", "red"))
                }
        }

        dev.off()
#       write.table(myMDS$CA$u, sep="\t", file=paste("pcoa_NoSeqControl", taxa, ".txt",sep=""))
#	write.table(myMDS$CA$eig,file=paste("eigenValues_NoSeqControl", taxa, ".txt", sep=""), sep="\t")

}


### Dropping controls, replicates, duplicates and low sequence counts
for(taxa in taxaLevels )
{
    inFileName <- paste( taxa, "LogNormwithMetadata_R1_Pooled.txt", sep ="")
    myT <-read.csv(inFileName,header=TRUE,sep="", na.strings="BLAH")
    numCols <- ncol(myT)

    myT<-myT[!(myT$MatchFile %in% SeqControl),]
    myT<-myT[!(myT$Sample_ID %in% removeReplicates),]
    myT<-myT[!(myT$MouseOrigin %in% labDrop),]
    myT<-myT[!(myT$MatchFile %in% removeDups),]
    myT<-myT[!(myT$MatchFile %in% manualDrop),]
    myT<-myT[!(myT$MatchFile %in% lowSeqDrop),]

    myMDS <- capscale(myT[,2:(ncol(myT)-numMetadataCols)]~1,distance="bray")

        # In the future add a scree plot component here.
        pdf( paste(taxa, "_checkbatch_topMDS_dropPilot.pdf",sep=""))
    for (xrun in 1:4) {
        for (yrun in 2:4) {
            if(xrun == yrun){
                break
            }

            plot(myMDS$CA$u[,xrun], myMDS$CA$u[,yrun],
                 xlab=paste("MDS",xrun,sep=""), ylab=paste("MDS",yrun,sep=""),
                 main=paste("PCoA at level:", taxa,sep=""), cex=2.0,
                 pch=16+as.numeric(myT$StressLength),
                 col=ifelse(myT$Sample_Plate=="Lyte_Batch04_repeat_batch02b", "red","blue"))
            textxy(myMDS$CA$u[,xrun],myMDS$CA$u[,yrun],labs=myT$Sample_ID,
                   cex=0.7, offset=0)
            par(xpd=TRUE)
                    legend(.25,.2,
# 		    c("Batch01", "Batch02", "Batch03",
c("9", "14", "19",
		    "Batch1", "Batch2"),
		    pch=c(16, 17, 18, 16, 16),
		    col=c("black", "black", "black",
		    #"cornflowerblue", "pink"))
                    "blue", "red"))
                }
        }

        dev.off()
#       write.table(myMDS$CA$u, sep="\t", file=paste("pcoa_NoSeqControl", taxa, ".txt",sep=""))
#	write.table(myMDS$CA$eig,file=paste("eigenValues_NoSeqControl", taxa, ".txt", sep=""), sep="\t")

}


### Dropping controls, replicates, duplicates and low sequence counts
for(taxa in taxaLevels )
{
    inFileName <- paste( taxa, "LogNormwithMetadata_R1_Pooled.txt", sep ="")
    myT <-read.csv(inFileName,header=TRUE,sep="", na.strings="BLAH")
    numCols <- ncol(myT)

    myT<-myT[!(myT$MatchFile %in% SeqControl),]
    myT<-myT[!(myT$Sample_ID %in% removeReplicates),]
    myT<-myT[!(myT$MouseOrigin %in% labDrop),]
    myT<-myT[!(myT$MatchFile %in% removeDups),]
    myT<-myT[!(myT$MatchFile %in% manualDrop),]
    myT<-myT[!(myT$MatchFile %in% lowSeqDrop),]

    myMDS <- capscale(myT[,2:(ncol(myT)-numMetadataCols)]~1,distance="bray")

        # In the future add a scree plot component here.
        pdf( paste(taxa, "_checkbatch_topMDS_dropPilot.pdf",sep=""))
    for (xrun in 1:4) {
        for (yrun in 2:4) {
            if(xrun == yrun){
                break
            }

            plot(myMDS$CA$u[,xrun], myMDS$CA$u[,yrun],
                 xlab=paste("MDS",xrun,sep=""), ylab=paste("MDS",yrun,sep=""),
                 main=paste("PCoA at level:", taxa,sep=""), cex=2.0,
                 pch=16+as.numeric(myT$StressLength),
                 col=ifelse(myT$Treatment=="Exp", "red","blue"))
            textxy(myMDS$CA$u[,xrun],myMDS$CA$u[,yrun],
                   labs=ifelse(myT$Sample_Plate == "Lyte_Batch04_repeat_batch02b", 2, 1),
                   cex=0.7, offset=0)
            par(xpd=TRUE)
                    legend(.3, .3,
                           c("9", "14", "19", "Batch1", "Batch2"),
                           pch=c(16, 17, 18, 16, 16),
                           col=c("black", "black", "black", "blue", "red"))
                }
        }

        dev.off()
#       write.table(myMDS$CA$u, sep="\t", file=paste("pcoa_NoSeqControl", taxa, ".txt",sep=""))
#	write.table(myMDS$CA$eig,file=paste("eigenValues_NoSeqControl", taxa, ".txt", sep=""), sep="\t")

}


### Dropping controls, replicates, duplicates and low sequence counts
for(taxa in taxaLevels )
{
    inFileName <- paste( taxa, "LogNormwithMetadata_R1_Pooled.txt", sep ="")
    myT <-read.csv(inFileName,header=TRUE,sep="", na.strings="BLAH")
    numCols <- ncol(myT)

    myT<-myT[!(myT$MatchFile %in% SeqControl),]
    myT<-myT[!(myT$Sample_ID %in% removeReplicates),]
    myT<-myT[!(myT$MouseOrigin %in% labDrop),]
    myT<-myT[!(myT$MatchFile %in% removeDups),]
    myT<-myT[!(myT$MatchFile %in% manualDrop),]
    myT<-myT[!(myT$MatchFile %in% lowSeqDrop),]

    myMDS <- capscale(myT[,2:(ncol(myT)-numMetadataCols)]~1,distance="bray")

        # In the future add a scree plot component here.
        pdf( paste(taxa, "_checkbatch_topMDS_dropPilot.pdf",sep=""))
    for (xrun in 1:4) {
        for (yrun in 2:4) {
            if(xrun == yrun){
                break
            }

            plot(myMDS$CA$u[,xrun], myMDS$CA$u[,yrun],
                 xlab=paste("MDS",xrun,sep=""), ylab=paste("MDS",yrun,sep=""),
                 main=paste("PCoA at level:", taxa,sep=""), cex=2.0,
                 pch=16+as.numeric(myT$StressLength),
                 col=ifelse(myT$Treatment=="Exp", "red","blue"))
            textxy(myMDS$CA$u[,xrun],myMDS$CA$u[,yrun],
                   labs=ifelse(myT$Sample_Plate == "Lyte_Batch04_repeat_batch02b", 2, 1),
                   cex=0.7, offset=0)
            par(xpd=TRUE)
                    legend("topright",
                           c("9", "14", "19", "Batch1", "Batch2"),
                           pch=c(16, 17, 18, 16, 16),
                           col=c("black", "black", "black", "blue", "red"))
                }
        }

        dev.off()
#       write.table(myMDS$CA$u, sep="\t", file=paste("pcoa_NoSeqControl", taxa, ".txt",sep=""))
#	write.table(myMDS$CA$eig,file=paste("eigenValues_NoSeqControl", taxa, ".txt", sep=""), sep="\t")

}


### Dropping controls, replicates, duplicates and low sequence counts
for(taxa in taxaLevels )
{
    inFileName <- paste( taxa, "LogNormwithMetadata_R1_Pooled.txt", sep ="")
    myT <-read.csv(inFileName,header=TRUE,sep="", na.strings="BLAH")
    numCols <- ncol(myT)

    myT<-myT[!(myT$MatchFile %in% SeqControl),]
    myT<-myT[!(myT$Sample_ID %in% removeReplicates),]
    myT<-myT[!(myT$MouseOrigin %in% labDrop),]
    myT<-myT[!(myT$MatchFile %in% removeDups),]
    myT<-myT[!(myT$MatchFile %in% manualDrop),]
    myT<-myT[!(myT$MatchFile %in% lowSeqDrop),]

    myMDS <- capscale(myT[,2:(ncol(myT)-numMetadataCols)]~1,distance="bray")

        # In the future add a scree plot component here.
        pdf( paste(taxa, "_checkbatch_topMDS_dropPilot.pdf",sep=""))
    for (xrun in 1:4) {
        for (yrun in 2:4) {
            if(xrun == yrun){
                break
            }

            plot(myMDS$CA$u[,xrun], myMDS$CA$u[,yrun],
                 xlab=paste("MDS",xrun,sep=""), ylab=paste("MDS",yrun,sep=""),
                 main=paste("PCoA at level:", taxa,sep=""), cex=2.0,
                 pch=16+ifelse(myT$Sample_Plate == "Lyte_Batch04_repeat_batch02b", 2, 1),
                 col=ifelse(myT$Treatment=="Exp", "red","blue"))
            textxy(myMDS$CA$u[,xrun],myMDS$CA$u[,yrun],
                   labs=as.numeric(myT$StressLength),
                   cex=0.7, offset=0)
            par(xpd=TRUE)
                    legend("topright",
                           c("9", "14", "19", "Batch1", "Batch2"),
                           pch=c(16, 17, 18, 16, 16),
                           col=c("black", "black", "black", "blue", "red"))
                }
        }

        dev.off()
#       write.table(myMDS$CA$u, sep="\t", file=paste("pcoa_NoSeqControl", taxa, ".txt",sep=""))
#	write.table(myMDS$CA$eig,file=paste("eigenValues_NoSeqControl", taxa, ".txt", sep=""), sep="\t")

}

 
### Dropping controls, replicates, duplicates and low sequence counts
for(taxa in taxaLevels )
{
    inFileName <- paste( taxa, "LogNormwithMetadata_R1_Pooled.txt", sep ="")
    myT <-read.csv(inFileName,header=TRUE,sep="", na.strings="BLAH")
    numCols <- ncol(myT)

    myT<-myT[!(myT$MatchFile %in% SeqControl),]
    myT<-myT[!(myT$Sample_ID %in% removeReplicates),]
    myT<-myT[!(myT$MouseOrigin %in% labDrop),]
    myT<-myT[!(myT$MatchFile %in% removeDups),]
    myT<-myT[!(myT$MatchFile %in% manualDrop),]
    myT<-myT[!(myT$MatchFile %in% lowSeqDrop),]

    myMDS <- capscale(myT[,2:(ncol(myT)-numMetadataCols)]~1,distance="bray")

        # In the future add a scree plot component here.
        pdf( paste(taxa, "_checkbatch_topMDS_dropPilot.pdf",sep=""))
    for (xrun in 1:4) {
        for (yrun in 2:4) {
            if(xrun == yrun){
                break
            }

            plot(myMDS$CA$u[,xrun], myMDS$CA$u[,yrun],
                 xlab=paste("MDS",xrun,sep=""), ylab=paste("MDS",yrun,sep=""),
                 main=paste("PCoA at level:", taxa,sep=""), cex=2.0,
                 pch=15+ifelse(myT$Sample_Plate == "Lyte_Batch04_repeat_batch02b", 2, 1),
                 col=ifelse(myT$Treatment=="Exp", "red","green"))
            textxy(myMDS$CA$u[,xrun],myMDS$CA$u[,yrun],
                   labs=as.numeric(myT$StressLength),
                   cex=0.7, offset=0)
            par(xpd=TRUE)
                    legend("topright",
                           c("Batch1", "Batch2", "Exp", "Ctrl"),
                           pch=c(16, 17, 16, 16),
                           col=c("black", "black", "red", "green"))
                }
        }

        dev.off()
#       write.table(myMDS$CA$u, sep="\t", file=paste("pcoa_NoSeqControl", taxa, ".txt",sep=""))
#	write.table(myMDS$CA$eig,file=paste("eigenValues_NoSeqControl", taxa, ".txt", sep=""), sep="\t")

}


### Dropping controls, replicates, duplicates and low sequence counts
for(taxa in taxaLevels )
{
    inFileName <- paste( taxa, "LogNormwithMetadata_R1_Pooled.txt", sep ="")
    myT <-read.csv(inFileName,header=TRUE,sep="", na.strings="BLAH")
    numCols <- ncol(myT)
    myColClasses <- c("character", rep("numeric", numCols - numMetadataCols - 1), rep("character", 11), "numeric", "numeric", "numeric", "character", "character", "character", "character", "character", "character")
    myT <-read.csv(inFileName, header=TRUE, sep="", colClasses=myColClasses, na.strings="BLAH", comment.char ="@")

    myT<-myT[!(myT$MatchFile %in% SeqControl),]
    myT<-myT[!(myT$Sample_ID %in% removeReplicates),]
    myT<-myT[!(myT$MouseOrigin %in% labDrop),]
    myT<-myT[!(myT$MatchFile %in% removeDups),]
    myT<-myT[!(myT$MatchFile %in% manualDrop),]
    myT<-myT[!(myT$MatchFile %in% lowSeqDrop),]

    myMDS <- capscale(myT[,2:(ncol(myT)-numMetadataCols)]~1,distance="bray")

        # In the future add a scree plot component here.
        pdf( paste(taxa, "_checkbatch_topMDS_dropPilot.pdf",sep=""))
    for (xrun in 1:4) {
        for (yrun in 2:4) {
            if(xrun == yrun){
                break
            }

            plot(myMDS$CA$u[,xrun], myMDS$CA$u[,yrun],
                 xlab=paste("MDS",xrun,sep=""), ylab=paste("MDS",yrun,sep=""),
                 main=paste("PCoA at level:", taxa,sep=""), cex=2.0,
                 pch=15+ifelse(myT$Sample_Plate == "Lyte_Batch04_repeat_batch02b", 2, 1),
                 col=ifelse(myT$Treatment=="Exp", "red","green"))
            textxy(myMDS$CA$u[,xrun],myMDS$CA$u[,yrun],
                   labs=as.numeric(myT$StressLength),
                   cex=0.7, offset=0)
            par(xpd=TRUE)
                    legend("topright",
                           c("Batch1", "Batch2", "Exp", "Ctrl"),
                           pch=c(16, 17, 16, 16),
                           col=c("black", "black", "red", "green"))
                }
        }

        dev.off()
#       write.table(myMDS$CA$u, sep="\t", file=paste("pcoa_NoSeqControl", taxa, ".txt",sep=""))
#	write.table(myMDS$CA$eig,file=paste("eigenValues_NoSeqControl", taxa, ".txt", sep=""), sep="\t")

}


### Dropping controls, replicates, duplicates and low sequence counts
for(taxa in taxaLevels )
{
    inFileName <- paste( taxa, "LogNormwithMetadata_R1_Pooled.txt", sep ="")
    myT <-read.csv(inFileName,header=TRUE,sep="", na.strings="BLAH")
    numCols <- ncol(myT)
    myColClasses <- c("character", rep("numeric", numCols - numMetadataCols - 1), rep("character", 11), "numeric", "numeric", "numeric", "character", "character", "character", "character", "character", "character")
    myT <-read.csv(inFileName, header=TRUE, sep="", colClasses=myColClasses, na.strings="BLAH", comment.char ="@")

    myT<-myT[!(myT$MatchFile %in% SeqControl),]
    myT<-myT[!(myT$Sample_ID %in% removeReplicates),]
    myT<-myT[!(myT$MouseOrigin %in% labDrop),]
    myT<-myT[!(myT$MatchFile %in% removeDups),]
    myT<-myT[!(myT$MatchFile %in% manualDrop),]
    myT<-myT[!(myT$MatchFile %in% lowSeqDrop),]

    myMDS <- capscale(myT[,2:(ncol(myT)-numMetadataCols)]~1,distance="bray")

        # In the future add a scree plot component here.
        pdf( paste(taxa, "_checkbatch_topMDS_dropPilot.pdf",sep=""))
    for (xrun in 1:4) {
        for (yrun in 2:4) {
            if(xrun == yrun){
                break
            }

            plot(myMDS$CA$u[,xrun], myMDS$CA$u[,yrun],
                 xlab=paste("MDS",xrun,sep=""), ylab=paste("MDS",yrun,sep=""),
                 main=paste("PCoA at level:", taxa,sep=""), cex=2.0,
                 pch=15+ifelse(myT$Sample_Plate == "Lyte_Batch04_repeat_batch02b", 2, 1),
                 col=ifelse(myT$Treatment=="Exp", "red","green"))
            textxy(myMDS$CA$u[,xrun],myMDS$CA$u[,yrun],
                   labs=as.numeric(myT$StressLength),
                   cex=0.7, offset=0)
            par(xpd=TRUE)
                    legend("topright",
                           c("Batch1", "Batch2", "Exp", "Ctrl"),
                           pch=c(16, 17, 16, 16),
                           col=c("black", "black", "red", "green"))
                }
        }

        dev.off()
#       write.table(myMDS$CA$u, sep="\t", file=paste("pcoa_NoSeqControl", taxa, ".txt",sep=""))
#	write.table(myMDS$CA$eig,file=paste("eigenValues_NoSeqControl", taxa, ".txt", sep=""), sep="\t")

}


### Dropping controls, replicates, duplicates and low sequence counts
for(taxa in taxaLevels )
{
    inFileName <- paste( taxa, "LogNormwithMetadata_R1_Pooled.txt", sep ="")
    myT <-read.csv(inFileName,header=TRUE,sep="", na.strings="BLAH")
    numCols <- ncol(myT)
    myColClasses <- c("character", rep("numeric", numCols - numMetadataCols - 1), rep("character", 11), "numeric", "numeric", "numeric", "character", "character", "character", "character", "character", "character")
    myT <-read.csv(inFileName, header=TRUE, sep="", colClasses=myColClasses, na.strings="BLAH", comment.char ="@")

    myT<-myT[!(myT$MatchFile %in% SeqControl),]
    myT<-myT[!(myT$Sample_ID %in% removeReplicates),]
    myT<-myT[!(myT$MouseOrigin %in% labDrop),]
    myT<-myT[!(myT$MatchFile %in% removeDups),]
    myT<-myT[!(myT$MatchFile %in% manualDrop),]
    myT<-myT[!(myT$MatchFile %in% lowSeqDrop),]

    myMDS <- capscale(myT[,2:(ncol(myT)-numMetadataCols)]~1,distance="bray")

        # In the future add a scree plot component here.
        pdf( paste(taxa, "_checkbatch_topMDS_dropPilot.pdf",sep=""))
    for (xrun in 1:4) {
        for (yrun in 2:4) {
            if(xrun == yrun){
                break
            }

            plot(myMDS$CA$u[,xrun], myMDS$CA$u[,yrun],
                 xlab=paste("MDS",xrun,sep=""), ylab=paste("MDS",yrun,sep=""),
                 main=paste("PCoA at level:", taxa,sep=""), cex=2.0,
                 pch = 15 + ifelse(myT$Treatment=="Exp", "1","2")
                 ## pch=15+ifelse(myT$Sample_Plate == "Lyte_Batch04_repeat_batch02b", 2, 1),
                 ## col=ifelse(myT$Treatment=="Exp", "red","green"))
                 col=as.numeric(myT$StressLength)
                 )
            textxy(myMDS$CA$u[,xrun],myMDS$CA$u[,yrun],
                   #labs=as.numeric(myT$StressLength),
                   #labs =
                   cex=0.7, offset=0)
            par(xpd=TRUE)
        legend("topright",
                                        #                           c("Batch1", "Batch2", "Exp", "Ctrl"),
               c("Exp", "Ctrl", "9", "14", "19"),
                           pch=c(16, 17, 16, 16, 16),
                           col=c("black", "black", "black", "red", "blue"))
                }
        }

        dev.off()
#       write.table(myMDS$CA$u, sep="\t", file=paste("pcoa_NoSeqControl", taxa, ".txt",sep=""))
#	write.table(myMDS$CA$eig,file=paste("eigenValues_NoSeqControl", taxa, ".txt", sep=""), sep="\t")

}


### Dropping controls, replicates, duplicates and low sequence counts
for(taxa in taxaLevels )
{
    inFileName <- paste( taxa, "LogNormwithMetadata_R1_Pooled.txt", sep ="")
    myT <-read.csv(inFileName,header=TRUE,sep="", na.strings="BLAH")
    numCols <- ncol(myT)
    myColClasses <- c("character", rep("numeric", numCols - numMetadataCols - 1), rep("character", 11), "numeric", "numeric", "numeric", "character", "character", "character", "character", "character", "character")
    myT <-read.csv(inFileName, header=TRUE, sep="", colClasses=myColClasses, na.strings="BLAH", comment.char ="@")

    myT<-myT[!(myT$MatchFile %in% SeqControl),]
    myT<-myT[!(myT$Sample_ID %in% removeReplicates),]
    myT<-myT[!(myT$MouseOrigin %in% labDrop),]
    myT<-myT[!(myT$MatchFile %in% removeDups),]
    myT<-myT[!(myT$MatchFile %in% manualDrop),]
    myT<-myT[!(myT$MatchFile %in% lowSeqDrop),]

    myMDS <- capscale(myT[,2:(ncol(myT)-numMetadataCols)]~1,distance="bray")

        # In the future add a scree plot component here.
        pdf( paste(taxa, "_checkbatch_topMDS_dropPilot.pdf",sep=""))
    for (xrun in 1:4) {
        for (yrun in 2:4) {
            if(xrun == yrun){
                break
            }

            plot(myMDS$CA$u[,xrun], myMDS$CA$u[,yrun],
                 xlab=paste("MDS",xrun,sep=""), ylab=paste("MDS",yrun,sep=""),
                 main=paste("PCoA at level:", taxa,sep=""), cex=2.0,
                 pch = 15 + ifelse(myT$Treatment=="Exp", "1","2"),
                 ## pch=15+ifelse(myT$Sample_Plate == "Lyte_Batch04_repeat_batch02b", 2, 1),
                 ## col=ifelse(myT$Treatment=="Exp", "red","green"))
                 col=as.numeric(myT$StressLength)
                 )
            textxy(myMDS$CA$u[,xrun],myMDS$CA$u[,yrun],
                   #labs=as.numeric(myT$StressLength),
                   #labs =
                   cex=0.7, offset=0)
            par(xpd=TRUE)
        legend("topright",
                                        #                           c("Batch1", "Batch2", "Exp", "Ctrl"),
               c("Exp", "Ctrl", "9", "14", "19"),
                           pch=c(16, 17, 16, 16, 16),
                           col=c("black", "black", "black", "red", "blue"))
                }
        }

        dev.off()
#       write.table(myMDS$CA$u, sep="\t", file=paste("pcoa_NoSeqControl", taxa, ".txt",sep=""))
#	write.table(myMDS$CA$eig,file=paste("eigenValues_NoSeqControl", taxa, ".txt", sep=""), sep="\t")

}


### Dropping controls, replicates, duplicates and low sequence counts
for(taxa in taxaLevels )
{
    inFileName <- paste( taxa, "LogNormwithMetadata_R1_Pooled.txt", sep ="")
    myT <-read.csv(inFileName,header=TRUE,sep="", na.strings="BLAH")
    numCols <- ncol(myT)
    myColClasses <- c("character", rep("numeric", numCols - numMetadataCols - 1), rep("character", 11), "numeric", "numeric", "numeric", "character", "character", "character", "character", "character", "character")
    myT <-read.csv(inFileName, header=TRUE, sep="", colClasses=myColClasses, na.strings="BLAH", comment.char ="@")

    myT<-myT[!(myT$MatchFile %in% SeqControl),]
    myT<-myT[!(myT$Sample_ID %in% removeReplicates),]
    myT<-myT[!(myT$MouseOrigin %in% labDrop),]
    myT<-myT[!(myT$MatchFile %in% removeDups),]
    myT<-myT[!(myT$MatchFile %in% manualDrop),]
    myT<-myT[!(myT$MatchFile %in% lowSeqDrop),]

    myMDS <- capscale(myT[,2:(ncol(myT)-numMetadataCols)]~1,distance="bray")

        # In the future add a scree plot component here.
        pdf( paste(taxa, "_checkbatch_topMDS_dropPilot.pdf",sep=""))
    for (xrun in 1:4) {
        for (yrun in 2:4) {
            if(xrun == yrun){
                break
            }

            plot(myMDS$CA$u[,xrun], myMDS$CA$u[,yrun],
                 xlab=paste("MDS",xrun,sep=""), ylab=paste("MDS",yrun,sep=""),
                 main=paste("PCoA at level:", taxa,sep=""), cex=2.0,
                 pch = 15 + ifelse(myT$Treatment=="Exp", 1, 2),
                 ## pch=15+ifelse(myT$Sample_Plate == "Lyte_Batch04_repeat_batch02b", 2, 1),
                 ## col=ifelse(myT$Treatment=="Exp", "red","green"))
                 col=as.numeric(myT$StressLength)
                 )
            textxy(myMDS$CA$u[,xrun],myMDS$CA$u[,yrun],
                   #labs=as.numeric(myT$StressLength),
                   #labs =
                   cex=0.7, offset=0)
            par(xpd=TRUE)
        legend("topright",
                                        #                           c("Batch1", "Batch2", "Exp", "Ctrl"),
               c("Exp", "Ctrl", "9", "14", "19"),
                           pch=c(16, 17, 16, 16, 16),
                           col=c("black", "black", "black", "red", "blue"))
                }
        }

        dev.off()
#       write.table(myMDS$CA$u, sep="\t", file=paste("pcoa_NoSeqControl", taxa, ".txt",sep=""))
#	write.table(myMDS$CA$eig,file=paste("eigenValues_NoSeqControl", taxa, ".txt", sep=""), sep="\t")

}


### Dropping controls, replicates, duplicates and low sequence counts
for(taxa in taxaLevels )
{
    inFileName <- paste( taxa, "LogNormwithMetadata_R1_Pooled.txt", sep ="")
    myT <-read.csv(inFileName,header=TRUE,sep="", na.strings="BLAH")
    numCols <- ncol(myT)
    myColClasses <- c("character", rep("numeric", numCols - numMetadataCols - 1), rep("character", 11), "numeric", "numeric", "numeric", "character", "character", "character", "character", "character", "character")
    myT <-read.csv(inFileName, header=TRUE, sep="", colClasses=myColClasses, na.strings="BLAH", comment.char ="@")

    myT<-myT[!(myT$MatchFile %in% SeqControl),]
    myT<-myT[!(myT$Sample_ID %in% removeReplicates),]
    myT<-myT[!(myT$MouseOrigin %in% labDrop),]
    myT<-myT[!(myT$MatchFile %in% removeDups),]
    myT<-myT[!(myT$MatchFile %in% manualDrop),]
    myT<-myT[!(myT$MatchFile %in% lowSeqDrop),]

    myMDS <- capscale(myT[,2:(ncol(myT)-numMetadataCols)]~1,distance="bray")

        # In the future add a scree plot component here.
        pdf( paste(taxa, "_checkbatch_topMDS_dropPilot.pdf",sep=""))
    for (xrun in 1:4) {
        for (yrun in 2:4) {
            if(xrun == yrun){
                break
            }

            plot(myMDS$CA$u[,xrun], myMDS$CA$u[,yrun],
                 xlab=paste("MDS",xrun,sep=""), ylab=paste("MDS",yrun,sep=""),
                 main=paste("PCoA at level:", taxa,sep=""), cex=2.0,
                 pch = 15 + ifelse(myT$Treatment=="Exp", 1, 2),
                 ## pch=15+ifelse(myT$Sample_Plate == "Lyte_Batch04_repeat_batch02b", 2, 1),
                 ## col=ifelse(myT$Treatment=="Exp", "red","green"))
                 col=as.numeric(myT$StressLength)
                 )
            ## textxy(myMDS$CA$u[,xrun],myMDS$CA$u[,yrun],                    labs=as.numeric(myT$StressLength), cex=0.7, offset=0)
            par(xpd=TRUE)
        legend("topright",
                                        #                           c("Batch1", "Batch2", "Exp", "Ctrl"),
               c("Exp", "Ctrl", "9", "14", "19"),
                           pch=c(16, 17, 16, 16, 16),
                           col=c("black", "black", "black", "red", "blue"))
                }
        }

        dev.off()
#       write.table(myMDS$CA$u, sep="\t", file=paste("pcoa_NoSeqControl", taxa, ".txt",sep=""))
#	write.table(myMDS$CA$eig,file=paste("eigenValues_NoSeqControl", taxa, ".txt", sep=""), sep="\t")

}


### Dropping controls, replicates, duplicates and low sequence counts
for(taxa in taxaLevels )
{
    inFileName <- paste( taxa, "LogNormwithMetadata_R1_Pooled.txt", sep ="")
    myT <-read.csv(inFileName,header=TRUE,sep="", na.strings="BLAH")
    numCols <- ncol(myT)
    myColClasses <- c("character", rep("numeric", numCols - numMetadataCols - 1), rep("character", 11), "numeric", "numeric", "numeric", "character", "character", "character", "character", "character", "character")
    myT <-read.csv(inFileName, header=TRUE, sep="", colClasses=myColClasses, na.strings="BLAH", comment.char ="@")

    myT<-myT[!(myT$MatchFile %in% SeqControl),]
    myT<-myT[!(myT$Sample_ID %in% removeReplicates),]
    myT<-myT[!(myT$MouseOrigin %in% labDrop),]
    myT<-myT[!(myT$MatchFile %in% removeDups),]
    myT<-myT[!(myT$MatchFile %in% manualDrop),]
    myT<-myT[!(myT$MatchFile %in% lowSeqDrop),]

    myMDS <- capscale(myT[,2:(ncol(myT)-numMetadataCols)]~1,distance="bray")

        # In the future add a scree plot component here.
        pdf( paste(taxa, "_checkbatch_topMDS_dropPilot.pdf",sep=""))
    for (xrun in 1:4) {
        for (yrun in 2:4) {
            if(xrun == yrun){
                break
            }

            plot(myMDS$CA$u[,xrun], myMDS$CA$u[,yrun],
                 xlab=paste("MDS",xrun,sep=""), ylab=paste("MDS",yrun,sep=""),
                 main=paste("PCoA at level:", taxa,sep=""), cex=2.0,
                 pch = 15 + ifelse(myT$Treatment=="Exp", 1, 2),
                 ## pch=15+ifelse(myT$Sample_Plate == "Lyte_Batch04_repeat_batch02b", 2, 1),
                 ## col=ifelse(myT$Treatment=="Exp", "red","green"))
                 col=as.numeric(myT$StressLength)
                 )
            ## textxy(myMDS$CA$u[,xrun],myMDS$CA$u[,yrun],                    labs=as.numeric(myT$StressLength), cex=0.7, offset=0)
            par(xpd=TRUE)
        legend("topright",
                                        #                           c("Batch1", "Batch2", "Exp", "Ctrl"),
               c("Exp", "Ctrl", "9", "14", "19"),
                           pch=c(16, 17, 16, 16, 16),
                           col=c("black", "black", "black", "red", "blue"))
                }
        }

        dev.off()
#       write.table(myMDS$CA$u, sep="\t", file=paste("pcoa_NoSeqControl", taxa, ".txt",sep=""))
#	write.table(myMDS$CA$eig,file=paste("eigenValues_NoSeqControl", taxa, ".txt", sep=""), sep="\t")

}


### Dropping controls, replicates, duplicates and low sequence counts
for(taxa in taxaLevels )
{
    inFileName <- paste( taxa, "LogNormwithMetadata_R1_Pooled.txt", sep ="")
    myT <-read.csv(inFileName,header=TRUE,sep="", na.strings="BLAH")
    numCols <- ncol(myT)
    myColClasses <- c("character", rep("numeric", numCols - numMetadataCols - 1), rep("character", 11), "numeric", "numeric", "numeric", "character", "character", "character", "character", "character", "character")
    myT <-read.csv(inFileName, header=TRUE, sep="", colClasses=myColClasses, na.strings="BLAH", comment.char ="@")

    myT<-myT[!(myT$MatchFile %in% SeqControl),]
    myT<-myT[!(myT$Sample_ID %in% removeReplicates),]
    myT<-myT[!(myT$MouseOrigin %in% labDrop),]
    myT<-myT[!(myT$MatchFile %in% removeDups),]
    myT<-myT[!(myT$MatchFile %in% manualDrop),]
    myT<-myT[!(myT$MatchFile %in% lowSeqDrop),]

    myMDS <- capscale(myT[,2:(ncol(myT)-numMetadataCols)]~1,distance="bray")

        # In the future add a scree plot component here.
        pdf( paste(taxa, "_checkbatch_topMDS_dropPilot.pdf",sep=""))
    for (xrun in 1:4) {
        for (yrun in 2:4) {
            if(xrun == yrun){
                break
            }

            plot(myMDS$CA$u[,xrun], myMDS$CA$u[,yrun],
                 xlab=paste("MDS",xrun,sep=""), ylab=paste("MDS",yrun,sep=""),
                 main=paste("PCoA at level:", taxa,sep=""), cex=2.0,
                 pch = 15 + ifelse(myT$Treatment=="Exp", 1, 2),
                 ## pch=15+ifelse(myT$Sample_Plate == "Lyte_Batch04_repeat_batch02b", 2, 1),
                 ## col=ifelse(myT$Treatment=="Exp", "red","green"))
                 col=as.numeric(myT$StressLength)
                 )
            ## textxy(myMDS$CA$u[,xrun],myMDS$CA$u[,yrun],                    labs=as.numeric(myT$StressLength), cex=0.7, offset=0)
            par(xpd=TRUE)
        legend("topright",
                                        #                           c("Batch1", "Batch2", "Exp", "Ctrl"),
               c("Exp", "Ctrl", "9", "14", "19"),
                           pch=c(16, 17, 16, 16, 16),
                           col=c("black", "black", 0, 1, 2))
                }
        }

        dev.off()
#       write.table(myMDS$CA$u, sep="\t", file=paste("pcoa_NoSeqControl", taxa, ".txt",sep=""))
#	write.table(myMDS$CA$eig,file=paste("eigenValues_NoSeqControl", taxa, ".txt", sep=""), sep="\t")

}


### Dropping controls, replicates, duplicates and low sequence counts
for(taxa in taxaLevels )
{
    inFileName <- paste( taxa, "LogNormwithMetadata_R1_Pooled.txt", sep ="")
    myT <-read.csv(inFileName,header=TRUE,sep="", na.strings="BLAH")
    numCols <- ncol(myT)
    myColClasses <- c("character", rep("numeric", numCols - numMetadataCols - 1), rep("character", 11), "numeric", "numeric", "numeric", "character", "character", "character", "character", "character", "character")
    myT <-read.csv(inFileName, header=TRUE, sep="", colClasses=myColClasses, na.strings="BLAH", comment.char ="@")

    myT<-myT[!(myT$MatchFile %in% SeqControl),]
    myT<-myT[!(myT$Sample_ID %in% removeReplicates),]
    myT<-myT[!(myT$MouseOrigin %in% labDrop),]
    myT<-myT[!(myT$MatchFile %in% removeDups),]
    myT<-myT[!(myT$MatchFile %in% manualDrop),]
    myT<-myT[!(myT$MatchFile %in% lowSeqDrop),]

    myMDS <- capscale(myT[,2:(ncol(myT)-numMetadataCols)]~1,distance="bray")

        # In the future add a scree plot component here.
        pdf( paste(taxa, "_checkbatch_topMDS_dropPilot.pdf",sep=""))
    for (xrun in 1:4) {
        for (yrun in 2:4) {
            if(xrun == yrun){
                break
            }

            plot(myMDS$CA$u[,xrun], myMDS$CA$u[,yrun],
                 xlab=paste("MDS",xrun,sep=""), ylab=paste("MDS",yrun,sep=""),
                 main=paste("PCoA at level:", taxa,sep=""), cex=2.0,
                 pch = 15 + ifelse(myT$Treatment=="Exp", 1, 2),
                 ## pch=15+ifelse(myT$Sample_Plate == "Lyte_Batch04_repeat_batch02b", 2, 1),
                 ## col=ifelse(myT$Treatment=="Exp", "red","green"))
                 col=as.numeric(myT$StressLength)
                 )
            ## textxy(myMDS$CA$u[,xrun],myMDS$CA$u[,yrun],                    labs=as.numeric(myT$StressLength), cex=0.7, offset=0)
            par(xpd=TRUE)
        legend("topright",
                                        #                           c("Batch1", "Batch2", "Exp", "Ctrl"),
               c("Exp", "Ctrl", "9", "14", "19"),
                           pch=c(16, 17, 16, 16, 16),
                           col=c("black", "black", 9, 14, 19))
                }
        }

        dev.off()
#       write.table(myMDS$CA$u, sep="\t", file=paste("pcoa_NoSeqControl", taxa, ".txt",sep=""))
#	write.table(myMDS$CA$eig,file=paste("eigenValues_NoSeqControl", taxa, ".txt", sep=""), sep="\t")

}


### Dropping controls, replicates, duplicates and low sequence counts
for(taxa in taxaLevels )
{
    inFileName <- paste( taxa, "LogNormwithMetadata_R1_Pooled.txt", sep ="")
    myT <-read.csv(inFileName,header=TRUE,sep="", na.strings="BLAH")
    numCols <- ncol(myT)
    myColClasses <- c("character", rep("numeric", numCols - numMetadataCols - 1), rep("character", 11), "numeric", "numeric", "numeric", "character", "character", "character", "character", "character", "character")
    myT <-read.csv(inFileName, header=TRUE, sep="", colClasses=myColClasses, na.strings="BLAH", comment.char ="@")

    myT<-myT[!(myT$MatchFile %in% SeqControl),]
    myT<-myT[!(myT$Sample_ID %in% removeReplicates),]
    myT<-myT[!(myT$MouseOrigin %in% labDrop),]
    myT<-myT[!(myT$MatchFile %in% removeDups),]
    myT<-myT[!(myT$MatchFile %in% manualDrop),]
    myT<-myT[!(myT$MatchFile %in% lowSeqDrop),]

    myMDS <- capscale(myT[,2:(ncol(myT)-numMetadataCols)]~1,distance="bray")

        # In the future add a scree plot component here.
        pdf( paste(taxa, "_checkbatch_topMDS_dropPilot.pdf",sep=""))
    for (xrun in 1:4) {
        for (yrun in 2:4) {
            if(xrun == yrun){
                break
            }

            plot(myMDS$CA$u[,xrun], myMDS$CA$u[,yrun],
                 xlab=paste("MDS",xrun,sep=""), ylab=paste("MDS",yrun,sep=""),
                 main=paste("PCoA at level:", taxa,sep=""), cex = 1.0,
                 pch = 15 + ifelse(myT$Treatment=="Exp", 1, 2),
                 ## pch=15+ifelse(myT$Sample_Plate == "Lyte_Batch04_repeat_batch02b", 2, 1),
                 ## col=ifelse(myT$Treatment=="Exp", "red","green"))
                 col=as.numeric(myT$StressLength)
                 )
            ## textxy(myMDS$CA$u[,xrun],myMDS$CA$u[,yrun],                    labs=as.numeric(myT$StressLength), cex=0.7, offset=0)
            par(xpd=TRUE)
        legend("topright",
                                        #                           c("Batch1", "Batch2", "Exp", "Ctrl"),
               c("Exp", "Ctrl", "9", "14", "19"),
                           pch=c(16, 17, 16, 16, 16),
                           col=c("black", "black", 9, 14, 19))
                }
        }

        dev.off()
#       write.table(myMDS$CA$u, sep="\t", file=paste("pcoa_NoSeqControl", taxa, ".txt",sep=""))
#	write.table(myMDS$CA$eig,file=paste("eigenValues_NoSeqControl", taxa, ".txt", sep=""), sep="\t")

}

help(pairs)
ls()
dim(myT)
pairs(myT[,numCols - numMetadataCols])
pairs(myT[,1:(numCols - numMetadataCols)])
pairs(as.numeric(myT[,1:(numCols - numMetadataCols)]))
pairs(myT[,2:5])
dev.off()
dev.off()
dev.off()
dev.off()
pairs(myT[,2:5])
help(drop1)
colnames(myT)
rm(list=ls())

library("pscl")
library("lmtest")
library("nlme")
library("vegan")

setwd("/Users/mbrown67/Documents/Fodor/Datasets/MarkExperiment/Pooled/")

taxaLevels <- c( "phylum", "class", "order", "family", "genus")

filePrefix <- "_treatment_onebatch_onetime_"
mlm<- FALSE

dropBatch <- "Lyte_Batch04_Run01_repeat"
dropTime <- 14
dropTreatment <- "Exp"

for(taxa in taxaLevels){

    inFileName <- paste( taxa, "LogNormwithMetadata_R1_Pooled.txt", sep ="")
    myT <-read.csv(inFileName,header=TRUE,sep="", na.strings="BLAH")

    numCols <- ncol(myT)
    numMetadataCols <- 20

    ## Reprocessing for correct column data type
    myColClasses <- c("character", rep("numeric", numCols - numMetadataCols - 1), rep("character", 11), "numeric", "numeric", "numeric", "character", "character", "character", "character", "character", "character")
    myT <-read.csv(inFileName, header=TRUE, sep="", colClasses=myColClasses, na.strings="BLAH", comment.char ="@")

    ## Removing unwanted samples {controls, replicates, duplicates, poor quality samples}
    removeControls<-c( "C1", "C2", "N1", "N2", "Neg", "Pos")
    myT<-myT[!(myT$Sample_ID %in% removeControls),]

    removetrs<-c("04_125_tr", "04_101_tr", "04_103_tr", "04_74_tr", "04_70_tr", "04_40_tr", "04_41_tr", "04_84_tr")
    myT<-myT[!(myT$Sample_ID %in% removetrs),]

    removeDups<-c("04-04_S63_L001_R1_001")
    myT<-myT[!(myT$MatchFile %in% removeDups),]

    ## Controls not dropped earlier
    manualDrop <- c("Neg_S40_L001_R1_001", "PCR1Neg_S65_L001_R1_001")
    myT<-myT[!(myT$MatchFile %in% manualDrop),]

    labDrop <- c("Harlan Labs")
    myT<-myT[!(myT$MouseOrigin %in% labDrop),]

    lowSeqDrop <- c("04-55_S32_L001_R1_001")
    myT<-myT[!(myT$MatchFile %in% lowSeqDrop),]
    ## Not sure what to do about this though.
    ### myT$Condition[which(myT$Treatment == "Ctrl", arr.ind = TRUE)]<-"Control"

    myT<-myT[!(myT$Sample_Plate == dropBatch),]
    myT<-myT[myT$StressLength == dropTime,]

    names <- vector()
    pValuesSex<- vector()
    pValuesAcuteChronic<- vector()
    pValuesCage<- vector()
    iccCage <- vector()
    iccKeptCounts <- vector()
    pValuesBatch<- vector()
    pValuesTreatment<- vector()
    pValuesTime <- vector()
    pValuesStressLength <- vector()
    pValuesInteraction <- vector()
    allpvals <- list()

    index <- 1
    pdf( paste(taxa, filePrefix, "boxplots.pdf", sep=""))

    for( i in 2:(ncol(myT) - numMetadataCols))
        if( sum(myT[,i] != 0 ) > nrow(myT) / 4 ){
            ## Easy access names
            bug <- myT[,i]
            ac <- myT$Condition
            sex <- myT$Sex
            cage <- myT$Cage
            batch <- myT$Sample_Plate
            date <- myT$Date
            mo <- myT$MouseOrigin
            group <- myT$SpreadsheetGrouping
            treatment <- myT$Treatment
            time <- myT$StressLength
            multiWay <- paste(ac, myT$StressLength)
            multiWay[which(myT$Treatment == "Ctrl", arr.ind = TRUE)]<-"Control"
            names[index] = names(myT)[i]
            ## Some kind of vector for the variables of interest
            myFrame <- data.frame(bug, ac, time, multiWay, sex, cage, treatment, batch, date, mo, date)
            ## M1 <- lm(bug ~ sex + treatment + time + batch + group + cage + date, data = myFrame)
            ## drop1(M1, test=
            if(mlm == TRUE){
                fullModel <- gls( bug~ treatment, method="REML",correlation=corCompSymm(form=~1|factor(group)),	data = myFrame )
                reducedModel <- gls( bug~ treatment, method="REML", data = myFrame )
                fullModelLME <- lme(bug~ treatment, method="REML", random = ~1|factor(group), data = myFrame)
            }
            else{
                fullModelLME <- lm(bug~ treatment, x=TRUE)
            }
            ## Potential save time by reducing anova calls
            ## Introduce the goodness of fit tests here
            ## Can streamline vectors to be automatically responsive to changes to the model
            if(mlm == TRUE){
                allNames <- rownames(anova(fullModelLME))[-1]
                allpvals[[index]] <- anova(fullModelLME)$"p-value"[-1]
            }
            else {
                allNames <- rownames(anova(fullModelLME))[-dim(anova(fullModelLME))[1]]
                allpvals[[index]]<-as.data.frame(anova(fullModelLME))[1:dim(anova(fullModelLME))[1]-1,5]
            }

            ## Random Effects and Interclass Correlation Coefficient
            if(mlm == TRUE){
                allNames<-c(allNames, "cage", "iccCage")
                allpvals[[index]]<-c(allpvals[[index]], anova(fullModelLME, reducedModel)$"p-value"[2], coef(fullModel$modelStruct[1]$corStruct,unconstrained=FALSE)[[1]])
                pValuesCage[index] <-  anova(fullModelLME, reducedModel)$"p-value"[2]
                ## This is different as it is not corrected for multiple hypothesis testing.
                iccCage[index]<- coef(fullModel$modelStruct[1]$corStruct,unconstrained=FALSE)[[1]]
            }
    ## Nice plotting
            ## Correct so that it uses corrected p-values
            if(mlm == TRUE){
                graphMain = c(names[i], paste(c(rep("p-",length(allNames)-1),""), allNames, " = ", format(allpvals[[index]], digits=3), sep=""))
            }
            else {
                graphMain = c(names[i], paste(c(rep("p-",length(allNames)),""), allNames, " = ", format(allpvals[[index]], digits=3), sep=""))

            }

            ## mlm is boolean 1/0 value. Basically, don't graph on icc
            ## need a correction for interaction terms as well
            numPlots <- length(allNames) - mlm
            par(mfrow=c(numPlots, 1),
                oma = c(1,1,0,0) + 0.1,
                mar = c(1,4,3,0) + 0.1)

            for(j in 1:numPlots){
                if(j == 1){
                    plot( bug ~ factor(get(allNames[j])), ylab = names[i], main = c(names[index],toString(graphMain[-1])) )
                    points(factor(get(allNames[j])), bug)
                }
                else{
                    testInteract <- grep(":", allNames)
                    if(length(testInteract) > 0){
                        if(j %in% testInteract){
                            intSplit <- unlist(strsplit(allNames[grep(":",allNames)[which(grep(":", allNames) == j)]],split=":"))
                            if(length(intSplit) == 2){
                                plot( bug ~ factor(c( paste( get(intSplit[1]), get(intSplit[2]),sep=""))))
                                points(factor(c( paste( get(intSplit[1]), get(intSplit[2]),sep=""))), bug)
                            }
                            else{
                                plot( bug ~ factor(c( paste( get(intSplit[1]), get(intSplit[2]), get(intSplit[3]),sep=""))))
                                points(factor(c( paste( get(intSplit[1]), get(intSplit[2]), get(intSplit[3]),sep=""))), bug)
                            }
                        }
                    }
                    else{
                        plot( bug ~ factor(get(allNames[j])), ylab = names[i])
                        points(factor(get(allNames[j])), bug)
                    }
                }
            }

            index <- index + 1
	}

    ## This should also be dynamic
    dFrame <- as.data.frame(matrix(unlist(allpvals), nrow= length(allpvals), byrow=TRUE))
    colnames(dFrame) <- unlist(allNames)
    rownames(dFrame) <- names
    orgCol <- ncol(dFrame)

    for(k in 1:(orgCol-mlm)){
        dFrame[, k + orgCol]<-p.adjust(dFrame[,k], method = "BH")
    }
    colnames(dFrame)[(orgCol + 1):length(dFrame)]<-paste0(rep("adjusted_"),colnames(dFrame)[1:(orgCol - mlm)])

    dFrame <- cbind(names, dFrame)
    ## Try and dynamically generate the name of the plot here...
    write.table(dFrame, file=paste("pValues", filePrefix, taxa, ".txt",sep=""), sep="\t",row.names=FALSE)

    ## Get the sig table working
    ## It would also be nice to have a sig-picker for the plots and a combination of all sig results into one plot.
    keepVector <- grep("adj", names(dFrame))
    sigdFrame <-dFrame[which(dFrame[,keepVector] < 0.05,arr.ind=TRUE),]
    write.table(sigdFrame, file=paste("SIGpValues", filePrefix, taxa, ".txt",sep=""), sep="\t",row.names=FALSE)

    dev.off()
}

M1 <- lm(bug ~ sex + treatment + time + batch + group + cage + date, data = myFrame)
rm(list=ls())

library("pscl")
library("lmtest")
library("nlme")
library("vegan")

setwd("/Users/mbrown67/Documents/Fodor/Datasets/MarkExperiment/Pooled/")

taxaLevels <- c( "phylum", "class", "order", "family", "genus")

filePrefix <- "_treatment_onebatch_onetime_"
mlm<- FALSE

dropBatch <- "Lyte_Batch04_Run01_repeat"
dropTime <- 14
dropTreatment <- "Exp"

for(taxa in taxaLevels){

    inFileName <- paste( taxa, "LogNormwithMetadata_R1_Pooled.txt", sep ="")
    myT <-read.csv(inFileName,header=TRUE,sep="", na.strings="BLAH")

    numCols <- ncol(myT)
    numMetadataCols <- 20

    ## Reprocessing for correct column data type
    myColClasses <- c("character", rep("numeric", numCols - numMetadataCols - 1), rep("character", 11), "numeric", "numeric", "numeric", "character", "character", "character", "character", "character", "character")
    myT <-read.csv(inFileName, header=TRUE, sep="", colClasses=myColClasses, na.strings="BLAH", comment.char ="@")

    ## Removing unwanted samples {controls, replicates, duplicates, poor quality samples}
    removeControls<-c( "C1", "C2", "N1", "N2", "Neg", "Pos")
    myT<-myT[!(myT$Sample_ID %in% removeControls),]

    removetrs<-c("04_125_tr", "04_101_tr", "04_103_tr", "04_74_tr", "04_70_tr", "04_40_tr", "04_41_tr", "04_84_tr")
    myT<-myT[!(myT$Sample_ID %in% removetrs),]

    removeDups<-c("04-04_S63_L001_R1_001")
    myT<-myT[!(myT$MatchFile %in% removeDups),]

    ## Controls not dropped earlier
    manualDrop <- c("Neg_S40_L001_R1_001", "PCR1Neg_S65_L001_R1_001")
    myT<-myT[!(myT$MatchFile %in% manualDrop),]

    labDrop <- c("Harlan Labs")
    myT<-myT[!(myT$MouseOrigin %in% labDrop),]

    lowSeqDrop <- c("04-55_S32_L001_R1_001")
    myT<-myT[!(myT$MatchFile %in% lowSeqDrop),]
    ## Not sure what to do about this though.
    ### myT$Condition[which(myT$Treatment == "Ctrl", arr.ind = TRUE)]<-"Control"

##    myT<-myT[!(myT$Sample_Plate == dropBatch),]
##    myT<-myT[myT$StressLength == dropTime,]

    names <- vector()
    pValuesSex<- vector()
    pValuesAcuteChronic<- vector()
    pValuesCage<- vector()
    iccCage <- vector()
    iccKeptCounts <- vector()
    pValuesBatch<- vector()
    pValuesTreatment<- vector()
    pValuesTime <- vector()
    pValuesStressLength <- vector()
    pValuesInteraction <- vector()
    allpvals <- list()

    index <- 1
    pdf( paste(taxa, filePrefix, "boxplots.pdf", sep=""))

    for( i in 2:(ncol(myT) - numMetadataCols))
        if( sum(myT[,i] != 0 ) > nrow(myT) / 4 ){
            ## Easy access names
            bug <- myT[,i]
            ac <- myT$Condition
            sex <- myT$Sex
            cage <- myT$Cage
            batch <- myT$Sample_Plate
            date <- myT$Date
            mo <- myT$MouseOrigin
            group <- myT$SpreadsheetGrouping
            treatment <- myT$Treatment
            time <- myT$StressLength
            multiWay <- paste(ac, myT$StressLength)
            multiWay[which(myT$Treatment == "Ctrl", arr.ind = TRUE)]<-"Control"
            names[index] = names(myT)[i]
            ## Some kind of vector for the variables of interest
            myFrame <- data.frame(bug, ac, time, multiWay, sex, cage, treatment, batch, date, mo, date)
            ## M1 <- lm(bug ~ sex + treatment + time + batch + group + cage + date, data = myFrame)
            ## drop1(M1, test=
            if(mlm == TRUE){
                fullModel <- gls( bug~ treatment, method="REML",correlation=corCompSymm(form=~1|factor(group)),	data = myFrame )
                reducedModel <- gls( bug~ treatment, method="REML", data = myFrame )
                fullModelLME <- lme(bug~ treatment, method="REML", random = ~1|factor(group), data = myFrame)
            }
            else{
                fullModelLME <- lm(bug~ treatment, x=TRUE)
            }
            ## Potential save time by reducing anova calls
            ## Introduce the goodness of fit tests here
            ## Can streamline vectors to be automatically responsive to changes to the model
            if(mlm == TRUE){
                allNames <- rownames(anova(fullModelLME))[-1]
                allpvals[[index]] <- anova(fullModelLME)$"p-value"[-1]
            }
            else {
                allNames <- rownames(anova(fullModelLME))[-dim(anova(fullModelLME))[1]]
                allpvals[[index]]<-as.data.frame(anova(fullModelLME))[1:dim(anova(fullModelLME))[1]-1,5]
            }

            ## Random Effects and Interclass Correlation Coefficient
            if(mlm == TRUE){
                allNames<-c(allNames, "cage", "iccCage")
                allpvals[[index]]<-c(allpvals[[index]], anova(fullModelLME, reducedModel)$"p-value"[2], coef(fullModel$modelStruct[1]$corStruct,unconstrained=FALSE)[[1]])
                pValuesCage[index] <-  anova(fullModelLME, reducedModel)$"p-value"[2]
                ## This is different as it is not corrected for multiple hypothesis testing.
                iccCage[index]<- coef(fullModel$modelStruct[1]$corStruct,unconstrained=FALSE)[[1]]
            }
    ## Nice plotting
            ## Correct so that it uses corrected p-values
            if(mlm == TRUE){
                graphMain = c(names[i], paste(c(rep("p-",length(allNames)-1),""), allNames, " = ", format(allpvals[[index]], digits=3), sep=""))
            }
            else {
                graphMain = c(names[i], paste(c(rep("p-",length(allNames)),""), allNames, " = ", format(allpvals[[index]], digits=3), sep=""))

            }

            ## mlm is boolean 1/0 value. Basically, don't graph on icc
            ## need a correction for interaction terms as well
            numPlots <- length(allNames) - mlm
            par(mfrow=c(numPlots, 1),
                oma = c(1,1,0,0) + 0.1,
                mar = c(1,4,3,0) + 0.1)

            for(j in 1:numPlots){
                if(j == 1){
                    plot( bug ~ factor(get(allNames[j])), ylab = names[i], main = c(names[index],toString(graphMain[-1])) )
                    points(factor(get(allNames[j])), bug)
                }
                else{
                    testInteract <- grep(":", allNames)
                    if(length(testInteract) > 0){
                        if(j %in% testInteract){
                            intSplit <- unlist(strsplit(allNames[grep(":",allNames)[which(grep(":", allNames) == j)]],split=":"))
                            if(length(intSplit) == 2){
                                plot( bug ~ factor(c( paste( get(intSplit[1]), get(intSplit[2]),sep=""))))
                                points(factor(c( paste( get(intSplit[1]), get(intSplit[2]),sep=""))), bug)
                            }
                            else{
                                plot( bug ~ factor(c( paste( get(intSplit[1]), get(intSplit[2]), get(intSplit[3]),sep=""))))
                                points(factor(c( paste( get(intSplit[1]), get(intSplit[2]), get(intSplit[3]),sep=""))), bug)
                            }
                        }
                    }
                    else{
                        plot( bug ~ factor(get(allNames[j])), ylab = names[i])
                        points(factor(get(allNames[j])), bug)
                    }
                }
            }

            index <- index + 1
	}

    ## This should also be dynamic
    dFrame <- as.data.frame(matrix(unlist(allpvals), nrow= length(allpvals), byrow=TRUE))
    colnames(dFrame) <- unlist(allNames)
    rownames(dFrame) <- names
    orgCol <- ncol(dFrame)

    for(k in 1:(orgCol-mlm)){
        dFrame[, k + orgCol]<-p.adjust(dFrame[,k], method = "BH")
    }
    colnames(dFrame)[(orgCol + 1):length(dFrame)]<-paste0(rep("adjusted_"),colnames(dFrame)[1:(orgCol - mlm)])

    dFrame <- cbind(names, dFrame)
    ## Try and dynamically generate the name of the plot here...
    write.table(dFrame, file=paste("pValues", filePrefix, taxa, ".txt",sep=""), sep="\t",row.names=FALSE)

    ## Get the sig table working
    ## It would also be nice to have a sig-picker for the plots and a combination of all sig results into one plot.
    keepVector <- grep("adj", names(dFrame))
    sigdFrame <-dFrame[which(dFrame[,keepVector] < 0.05,arr.ind=TRUE),]
    write.table(sigdFrame, file=paste("SIGpValues", filePrefix, taxa, ".txt",sep=""), sep="\t",row.names=FALSE)

    dev.off()
}

M1 <- lm(bug ~ sex + treatment + time + batch + group + cage + date, data = myFrame)
M1
M1 <- lm(bug ~ sex + treatment + time + batch + group + date, data = myFrame)
M1
summary(M1)
drop1(M1, test="F")
M2 <- lm(bug ~ sex + treatment + time + batch, data = myFrame)
anova(M1, M2)
M3 <- lm(bug ~ sex*treatment*time*batch, data = myFrame)
M3
anova(M3)
M4 <- lm(bug ~ treatment*batch + sex*time*batch, data = myFrame) 
anova(M4)
help(step)
step(M1)
step(M2)
step(M3)
step(M4)
plot(bug, time)
plot(time, bug)
plot(treatment, bug)
treatment
plot(time, bug)
D1<-data.frame(time = myT$StressLength[MyT$Treatment == 1], treatment = "1")
D1<-data.frame(time = myT$StressLength[myT$Treatment == 1], treatment = "1")
D1<-data.frame(time = myT$StressLength[myT$Treatment == "Exp"], treatment = "1")
D2<-data.frame(time = myT$StressLength[myT$Treatment == "Ctrl"], treatment = "2")
D1
P1 <- predict(M1, newdata = D1)
M5 <- lm(bug ~ treatment*time, data = myFrame)
P1 <- predict(M5, newdata = D1)
P1 <- predict(M5, newdata = D1)
D1<-data.frame(time = myT$StressLength[myT$Treatment == "Exp"], treatment = "Exp")
D2<-data.frame(time = myT$StressLength[myT$Treatment == "Ctrl"], treatment = "Ctrl")
P1 <- predict(M5, newdata = D1)  C-c C-c
P1 <- predict(M5, newdata = D1)
P2 <- predict(M5, newdata = D2)
colnames(D1)
lines(D1$time, P1, lty = 1)
lines(D2$time, P2, lty = 1, col="BLUE")
 plot(time, bug)
M1
M5
M5$coef
abline(M5$coef[1], M5$coef[3], col="RED")
abline(M5$coef[1] + M5$coef[2], M5$coef[3] + M5$coef[4], col="BLUE")
M1
anova(M1)
anova(M2)
M6 <- lm(bug ~ sex + time + batch, data = myFrame)
anova(M6)
M7 <- lm(bug ~ sex + batch, data = myFrame)
M7
anova(M7)
M8 <- lm(bug ~ sex + treatment*time + batch, data  = myFrame)
anova(M8)
lm(myT[,2] ~ sex + time + batch, data = myFrame)
anova(lm(myT[,2] ~ sex + time + batch, data = myFrame))
anova(lm(myT[,3] ~ sex + time + batch, data = myFrame))
anova(lm(myT[,4] ~ sex + time + batch, data = myFrame))
summary(anova(lm(myT[,4] ~ sex + time + batch, data = myFrame)))
anova(lm(myT[,4] ~ sex + time + batch, data = myFrame))
ls()
summary(anova(M1))
anova(M1)
summary(M1)
summary(M2)
summary(M3)
summary(M4)
summary(M5)
ls()
colnames(myT)
length(factor(myT$Cage))
length(unique(factor(myT$Cage)))
rm(list=ls())

library("pscl")
library("lmtest")
library("nlme")
library("vegan")

setwd("/Users/mbrown67/Documents/Fodor/Datasets/MarkExperiment/Pooled/")

taxaLevels <- c( "phylum", "class", "order", "family", "genus")

filePrefix <- "_time_time*time_"
mlm<- FALSE

dropBatch <- "Lyte_Batch04_Run01_repeat"
dropTime <- 14
dropTreatment <- "Exp"

for(taxa in taxaLevels){

    inFileName <- paste( taxa, "LogNormwithMetadata_R1_Pooled.txt", sep ="")
    myT <-read.csv(inFileName,header=TRUE,sep="", na.strings="BLAH")

    numCols <- ncol(myT)
    numMetadataCols <- 20

    ## Reprocessing for correct column data type
    myColClasses <- c("character", rep("numeric", numCols - numMetadataCols - 1), rep("character", 11), "numeric", "numeric", "numeric", "character", "character", "character", "character", "character", "character")
    myT <-read.csv(inFileName, header=TRUE, sep="", colClasses=myColClasses, na.strings="BLAH", comment.char ="@")

    ## Removing unwanted samples {controls, replicates, duplicates, poor quality samples}
    removeControls<-c( "C1", "C2", "N1", "N2", "Neg", "Pos")
    myT<-myT[!(myT$Sample_ID %in% removeControls),]

    removetrs<-c("04_125_tr", "04_101_tr", "04_103_tr", "04_74_tr", "04_70_tr", "04_40_tr", "04_41_tr", "04_84_tr")
    myT<-myT[!(myT$Sample_ID %in% removetrs),]

    removeDups<-c("04-04_S63_L001_R1_001")
    myT<-myT[!(myT$MatchFile %in% removeDups),]

    ## Controls not dropped earlier
    manualDrop <- c("Neg_S40_L001_R1_001", "PCR1Neg_S65_L001_R1_001")
    myT<-myT[!(myT$MatchFile %in% manualDrop),]

    labDrop <- c("Harlan Labs")
    myT<-myT[!(myT$MouseOrigin %in% labDrop),]

    lowSeqDrop <- c("04-55_S32_L001_R1_001")
    myT<-myT[!(myT$MatchFile %in% lowSeqDrop),]
    ## Not sure what to do about this though.
    ### myT$Condition[which(myT$Treatment == "Ctrl", arr.ind = TRUE)]<-"Control"

##    myT<-myT[!(myT$Sample_Plate == dropBatch),]
##    myT<-myT[myT$StressLength == dropTime,]

    names <- vector()
    pValuesSex<- vector()
    pValuesAcuteChronic<- vector()
    pValuesCage<- vector()
    iccCage <- vector()
    iccKeptCounts <- vector()
    pValuesBatch<- vector()
    pValuesTreatment<- vector()
    pValuesTime <- vector()
    pValuesStressLength <- vector()
    pValuesInteraction <- vector()
    allpvals <- list()

    index <- 1
    pdf( paste(taxa, filePrefix, "boxplots.pdf", sep=""))

    for( i in 2:(ncol(myT) - numMetadataCols))
        if( sum(myT[,i] != 0 ) > nrow(myT) / 4 ){
            ## Easy access names
            bug <- myT[,i]
            ac <- myT$Condition
            sex <- myT$Sex
            cage <- myT$Cage
            batch <- myT$Sample_Plate
            date <- myT$Date
            mo <- myT$MouseOrigin
            group <- myT$SpreadsheetGrouping
            treatment <- myT$Treatment
            time <- myT$StressLength
            multiWay <- paste(ac, myT$StressLength)
            multiWay[which(myT$Treatment == "Ctrl", arr.ind = TRUE)]<-"Control"
            names[index] = names(myT)[i]
            ## Some kind of vector for the variables of interest
            myFrame <- data.frame(bug, ac, time, multiWay, sex, cage, treatment, batch, date, mo, date)
            ## M1 <- lm(bug ~ sex + treatment + time + batch + group + date, data = myFrame)
            ## M2 <- lm(bug ~ sex + treatment + time + batch, data = myFrame)
            ## M3 <- lm(bug ~ sex*treatment*time*batch, data = myFrame)
            ## M4 <- lm(bug ~ treatment*batch + sex*time*batch, data = myFrame)
            ## M5 <- lm(bug ~ treatment*time, data = myFrame)
            ## M6 <- lm(bug ~ sex + time + batch, data = myFrame)
            ## M7 <- lm(bug ~ sex + batch, data = myFrame)
            ## drop1(M1, test=
            if(mlm == TRUE){
                fullModel <- gls( bug~ treatment, method="REML",correlation=corCompSymm(form=~1|factor(group)),	data = myFrame )
                reducedModel <- gls( bug~ treatment, method="REML", data = myFrame )
                fullModelLME <- lme(bug~ treatment, method="REML", random = ~1|factor(group), data = myFrame)
            }
            else{
                fullModelLME <- lm(bug~ time + time^2 + batch, x=TRUE)
            }
            ## Potential save time by reducing anova calls
            ## Introduce the goodness of fit tests here
            ## Can streamline vectors to be automatically responsive to changes to the model
            if(mlm == TRUE){
                allNames <- rownames(anova(fullModelLME))[-1]
                allpvals[[index]] <- anova(fullModelLME)$"p-value"[-1]
            }
            else {
                allNames <- rownames(anova(fullModelLME))[-dim(anova(fullModelLME))[1]]
                allpvals[[index]]<-as.data.frame(anova(fullModelLME))[1:dim(anova(fullModelLME))[1]-1,5]
            }

            ## Random Effects and Interclass Correlation Coefficient
            if(mlm == TRUE){
                allNames<-c(allNames, "cage", "iccCage")
                allpvals[[index]]<-c(allpvals[[index]], anova(fullModelLME, reducedModel)$"p-value"[2], coef(fullModel$modelStruct[1]$corStruct,unconstrained=FALSE)[[1]])
                pValuesCage[index] <-  anova(fullModelLME, reducedModel)$"p-value"[2]
                ## This is different as it is not corrected for multiple hypothesis testing.
                iccCage[index]<- coef(fullModel$modelStruct[1]$corStruct,unconstrained=FALSE)[[1]]
            }
    ## Nice plotting
            ## Correct so that it uses corrected p-values
            if(mlm == TRUE){
                graphMain = c(names[i], paste(c(rep("p-",length(allNames)-1),""), allNames, " = ", format(allpvals[[index]], digits=3), sep=""))
            }
            else {
                graphMain = c(names[i], paste(c(rep("p-",length(allNames)),""), allNames, " = ", format(allpvals[[index]], digits=3), sep=""))

            }

            ## mlm is boolean 1/0 value. Basically, don't graph on icc
            ## need a correction for interaction terms as well
            numPlots <- length(allNames) - mlm
            par(mfrow=c(numPlots, 1),
                oma = c(1,1,0,0) + 0.1,
                mar = c(1,4,3,0) + 0.1)

            for(j in 1:numPlots){
                if(j == 1){
                    plot( bug ~ factor(get(allNames[j])), ylab = names[i], main = c(names[index],toString(graphMain[-1])) )
                    points(factor(get(allNames[j])), bug)
                }
                else{
                    testInteract <- grep(":", allNames)
                    if(length(testInteract) > 0){
                        if(j %in% testInteract){
                            intSplit <- unlist(strsplit(allNames[grep(":",allNames)[which(grep(":", allNames) == j)]],split=":"))
                            if(length(intSplit) == 2){
                                plot( bug ~ factor(c( paste( get(intSplit[1]), get(intSplit[2]),sep=""))))
                                points(factor(c( paste( get(intSplit[1]), get(intSplit[2]),sep=""))), bug)
                            }
                            else{
                                plot( bug ~ factor(c( paste( get(intSplit[1]), get(intSplit[2]), get(intSplit[3]),sep=""))))
                                points(factor(c( paste( get(intSplit[1]), get(intSplit[2]), get(intSplit[3]),sep=""))), bug)
                            }
                        }
                    }
                    else{
                        plot( bug ~ factor(get(allNames[j])), ylab = names[i])
                        points(factor(get(allNames[j])), bug)
                    }
                }
            }

            index <- index + 1
	}

    ## This should also be dynamic
    dFrame <- as.data.frame(matrix(unlist(allpvals), nrow= length(allpvals), byrow=TRUE))
    colnames(dFrame) <- unlist(allNames)
    rownames(dFrame) <- names
    orgCol <- ncol(dFrame)

    for(k in 1:(orgCol-mlm)){
        dFrame[, k + orgCol]<-p.adjust(dFrame[,k], method = "BH")
    }
    colnames(dFrame)[(orgCol + 1):length(dFrame)]<-paste0(rep("adjusted_"),colnames(dFrame)[1:(orgCol - mlm)])

    dFrame <- cbind(names, dFrame)
    ## Try and dynamically generate the name of the plot here...
    write.table(dFrame, file=paste("pValues", filePrefix, taxa, ".txt",sep=""), sep="\t",row.names=FALSE)

    ## Get the sig table working
    ## It would also be nice to have a sig-picker for the plots and a combination of all sig results into one plot.
    keepVector <- grep("adj", names(dFrame))
    sigdFrame <-dFrame[which(dFrame[,keepVector] < 0.05,arr.ind=TRUE),]
    write.table(sigdFrame, file=paste("SIGpValues", filePrefix, taxa, ".txt",sep=""), sep="\t",row.names=FALSE)

    dev.off()
}

ls()
anova(fullModelLME)
help(lm)
rm(list=ls())

library("pscl")
library("lmtest")
library("nlme")
library("vegan")

setwd("/Users/mbrown67/Documents/Fodor/Datasets/MarkExperiment/Pooled/")

taxaLevels <- c( "phylum", "class", "order", "family", "genus")

filePrefix <- "_time*time_batch"
mlm<- FALSE

dropBatch <- "Lyte_Batch04_Run01_repeat"
dropTime <- 14
dropTreatment <- "Exp"

for(taxa in taxaLevels){

    inFileName <- paste( taxa, "LogNormwithMetadata_R1_Pooled.txt", sep ="")
    myT <-read.csv(inFileName,header=TRUE,sep="", na.strings="BLAH")

    numCols <- ncol(myT)
    numMetadataCols <- 20

    ## Reprocessing for correct column data type
    myColClasses <- c("character", rep("numeric", numCols - numMetadataCols - 1), rep("character", 11), "numeric", "numeric", "numeric", "character", "character", "character", "character", "character", "character")
    myT <-read.csv(inFileName, header=TRUE, sep="", colClasses=myColClasses, na.strings="BLAH", comment.char ="@")

    ## Removing unwanted samples {controls, replicates, duplicates, poor quality samples}
    removeControls<-c( "C1", "C2", "N1", "N2", "Neg", "Pos")
    myT<-myT[!(myT$Sample_ID %in% removeControls),]

    removetrs<-c("04_125_tr", "04_101_tr", "04_103_tr", "04_74_tr", "04_70_tr", "04_40_tr", "04_41_tr", "04_84_tr")
    myT<-myT[!(myT$Sample_ID %in% removetrs),]

    removeDups<-c("04-04_S63_L001_R1_001")
    myT<-myT[!(myT$MatchFile %in% removeDups),]

    ## Controls not dropped earlier
    manualDrop <- c("Neg_S40_L001_R1_001", "PCR1Neg_S65_L001_R1_001")
    myT<-myT[!(myT$MatchFile %in% manualDrop),]

    labDrop <- c("Harlan Labs")
    myT<-myT[!(myT$MouseOrigin %in% labDrop),]

    lowSeqDrop <- c("04-55_S32_L001_R1_001")
    myT<-myT[!(myT$MatchFile %in% lowSeqDrop),]
    ## Not sure what to do about this though.
    ### myT$Condition[which(myT$Treatment == "Ctrl", arr.ind = TRUE)]<-"Control"

##    myT<-myT[!(myT$Sample_Plate == dropBatch),]
##    myT<-myT[myT$StressLength == dropTime,]

    names <- vector()
    pValuesSex<- vector()
    pValuesAcuteChronic<- vector()
    pValuesCage<- vector()
    iccCage <- vector()
    iccKeptCounts <- vector()
    pValuesBatch<- vector()
    pValuesTreatment<- vector()
    pValuesTime <- vector()
    pValuesStressLength <- vector()
    pValuesInteraction <- vector()
    allpvals <- list()

    index <- 1
    pdf( paste(taxa, filePrefix, "boxplots.pdf", sep=""))

    for( i in 2:(ncol(myT) - numMetadataCols))
        if( sum(myT[,i] != 0 ) > nrow(myT) / 4 ){
            ## Easy access names
            bug <- myT[,i]
            ac <- myT$Condition
            sex <- myT$Sex
            cage <- myT$Cage
            batch <- myT$Sample_Plate
            date <- myT$Date
            mo <- myT$MouseOrigin
            group <- myT$SpreadsheetGrouping
            treatment <- myT$Treatment
            time <- myT$StressLength
            multiWay <- paste(ac, myT$StressLength)
            multiWay[which(myT$Treatment == "Ctrl", arr.ind = TRUE)]<-"Control"
            names[index] = names(myT)[i]
            ## Some kind of vector for the variables of interest
            myFrame <- data.frame(bug, ac, time, multiWay, sex, cage, treatment, batch, date, mo, date)
            ## M1 <- lm(bug ~ sex + treatment + time + batch + group + date, data = myFrame)
            ## M2 <- lm(bug ~ sex + treatment + time + batch, data = myFrame)
            ## M3 <- lm(bug ~ sex*treatment*time*batch, data = myFrame)
            ## M4 <- lm(bug ~ treatment*batch + sex*time*batch, data = myFrame)
            ## M5 <- lm(bug ~ treatment*time, data = myFrame)
            ## M6 <- lm(bug ~ sex + time + batch, data = myFrame)
            ## M7 <- lm(bug ~ sex + batch, data = myFrame)
            ## drop1(M1, test=
            if(mlm == TRUE){
                fullModel <- gls( bug~ treatment, method="REML",correlation=corCompSymm(form=~1|factor(group)),	data = myFrame )
                reducedModel <- gls( bug~ treatment, method="REML", data = myFrame )
                fullModelLME <- lme(bug~ treatment, method="REML", random = ~1|factor(group), data = myFrame)
            }
            else{
                fullModelLME <- lm(bug~ time^2 + batch, x=TRUE)
            }
            ## Potential save time by reducing anova calls
            ## Introduce the goodness of fit tests here
            ## Can streamline vectors to be automatically responsive to changes to the model
            if(mlm == TRUE){
                allNames <- rownames(anova(fullModelLME))[-1]
                allpvals[[index]] <- anova(fullModelLME)$"p-value"[-1]
            }
            else {
                allNames <- rownames(anova(fullModelLME))[-dim(anova(fullModelLME))[1]]
                allpvals[[index]]<-as.data.frame(anova(fullModelLME))[1:dim(anova(fullModelLME))[1]-1,5]
            }

            ## Random Effects and Interclass Correlation Coefficient
            if(mlm == TRUE){
                allNames<-c(allNames, "cage", "iccCage")
                allpvals[[index]]<-c(allpvals[[index]], anova(fullModelLME, reducedModel)$"p-value"[2], coef(fullModel$modelStruct[1]$corStruct,unconstrained=FALSE)[[1]])
                pValuesCage[index] <-  anova(fullModelLME, reducedModel)$"p-value"[2]
                ## This is different as it is not corrected for multiple hypothesis testing.
                iccCage[index]<- coef(fullModel$modelStruct[1]$corStruct,unconstrained=FALSE)[[1]]
            }
    ## Nice plotting
            ## Correct so that it uses corrected p-values
            if(mlm == TRUE){
                graphMain = c(names[i], paste(c(rep("p-",length(allNames)-1),""), allNames, " = ", format(allpvals[[index]], digits=3), sep=""))
            }
            else {
                graphMain = c(names[i], paste(c(rep("p-",length(allNames)),""), allNames, " = ", format(allpvals[[index]], digits=3), sep=""))

            }

            ## mlm is boolean 1/0 value. Basically, don't graph on icc
            ## need a correction for interaction terms as well
            numPlots <- length(allNames) - mlm
            par(mfrow=c(numPlots, 1),
                oma = c(1,1,0,0) + 0.1,
                mar = c(1,4,3,0) + 0.1)

            for(j in 1:numPlots){
                if(j == 1){
                    plot( bug ~ factor(get(allNames[j])), ylab = names[i], main = c(names[index],toString(graphMain[-1])) )
                    points(factor(get(allNames[j])), bug)
                }
                else{
                    testInteract <- grep(":", allNames)
                    if(length(testInteract) > 0){
                        if(j %in% testInteract){
                            intSplit <- unlist(strsplit(allNames[grep(":",allNames)[which(grep(":", allNames) == j)]],split=":"))
                            if(length(intSplit) == 2){
                                plot( bug ~ factor(c( paste( get(intSplit[1]), get(intSplit[2]),sep=""))))
                                points(factor(c( paste( get(intSplit[1]), get(intSplit[2]),sep=""))), bug)
                            }
                            else{
                                plot( bug ~ factor(c( paste( get(intSplit[1]), get(intSplit[2]), get(intSplit[3]),sep=""))))
                                points(factor(c( paste( get(intSplit[1]), get(intSplit[2]), get(intSplit[3]),sep=""))), bug)
                            }
                        }
                    }
                    else{
                        plot( bug ~ factor(get(allNames[j])), ylab = names[i])
                        points(factor(get(allNames[j])), bug)
                    }
                }
            }

            index <- index + 1
	}

    ## This should also be dynamic
    dFrame <- as.data.frame(matrix(unlist(allpvals), nrow= length(allpvals), byrow=TRUE))
    colnames(dFrame) <- unlist(allNames)
    rownames(dFrame) <- names
    orgCol <- ncol(dFrame)

    for(k in 1:(orgCol-mlm)){
        dFrame[, k + orgCol]<-p.adjust(dFrame[,k], method = "BH")
    }
    colnames(dFrame)[(orgCol + 1):length(dFrame)]<-paste0(rep("adjusted_"),colnames(dFrame)[1:(orgCol - mlm)])

    dFrame <- cbind(names, dFrame)
    ## Try and dynamically generate the name of the plot here...
    write.table(dFrame, file=paste("pValues", filePrefix, taxa, ".txt",sep=""), sep="\t",row.names=FALSE)

    ## Get the sig table working
    ## It would also be nice to have a sig-picker for the plots and a combination of all sig results into one plot.
    keepVector <- grep("adj", names(dFrame))
    sigdFrame <-dFrame[which(dFrame[,keepVector] < 0.05,arr.ind=TRUE),]
    write.table(sigdFrame, file=paste("SIGpValues", filePrefix, taxa, ".txt",sep=""), sep="\t",row.names=FALSE)

    dev.off()
}

rm(list=ls())

library("pscl")
library("lmtest")
library("nlme")
library("vegan")

setwd("/Users/mbrown67/Documents/Fodor/Datasets/MarkExperiment/Pooled/")

taxaLevels <- c( "phylum", "class", "order", "family", "genus")

filePrefix <- "_treatment*time_batch"
mlm<- FALSE

dropBatch <- "Lyte_Batch04_Run01_repeat"
dropTime <- 14
dropTreatment <- "Exp"

for(taxa in taxaLevels){

    inFileName <- paste( taxa, "LogNormwithMetadata_R1_Pooled.txt", sep ="")
    myT <-read.csv(inFileName,header=TRUE,sep="", na.strings="BLAH")

    numCols <- ncol(myT)
    numMetadataCols <- 20

    ## Reprocessing for correct column data type
    myColClasses <- c("character", rep("numeric", numCols - numMetadataCols - 1), rep("character", 11), "numeric", "numeric", "numeric", "character", "character", "character", "character", "character", "character")
    myT <-read.csv(inFileName, header=TRUE, sep="", colClasses=myColClasses, na.strings="BLAH", comment.char ="@")

    ## Removing unwanted samples {controls, replicates, duplicates, poor quality samples}
    removeControls<-c( "C1", "C2", "N1", "N2", "Neg", "Pos")
    myT<-myT[!(myT$Sample_ID %in% removeControls),]

    removetrs<-c("04_125_tr", "04_101_tr", "04_103_tr", "04_74_tr", "04_70_tr", "04_40_tr", "04_41_tr", "04_84_tr")
    myT<-myT[!(myT$Sample_ID %in% removetrs),]

    removeDups<-c("04-04_S63_L001_R1_001")
    myT<-myT[!(myT$MatchFile %in% removeDups),]

    ## Controls not dropped earlier
    manualDrop <- c("Neg_S40_L001_R1_001", "PCR1Neg_S65_L001_R1_001")
    myT<-myT[!(myT$MatchFile %in% manualDrop),]

    labDrop <- c("Harlan Labs")
    myT<-myT[!(myT$MouseOrigin %in% labDrop),]

    lowSeqDrop <- c("04-55_S32_L001_R1_001")
    myT<-myT[!(myT$MatchFile %in% lowSeqDrop),]
    ## Not sure what to do about this though.
    ### myT$Condition[which(myT$Treatment == "Ctrl", arr.ind = TRUE)]<-"Control"

##    myT<-myT[!(myT$Sample_Plate == dropBatch),]
##    myT<-myT[myT$StressLength == dropTime,]

    names <- vector()
    pValuesSex<- vector()
    pValuesAcuteChronic<- vector()
    pValuesCage<- vector()
    iccCage <- vector()
    iccKeptCounts <- vector()
    pValuesBatch<- vector()
    pValuesTreatment<- vector()
    pValuesTime <- vector()
    pValuesStressLength <- vector()
    pValuesInteraction <- vector()
    allpvals <- list()

    index <- 1
    pdf( paste(taxa, filePrefix, "boxplots.pdf", sep=""))

    for( i in 2:(ncol(myT) - numMetadataCols))
        if( sum(myT[,i] != 0 ) > nrow(myT) / 4 ){
            ## Easy access names
            bug <- myT[,i]
            ac <- myT$Condition
            sex <- myT$Sex
            cage <- myT$Cage
            batch <- myT$Sample_Plate
            date <- myT$Date
            mo <- myT$MouseOrigin
            group <- myT$SpreadsheetGrouping
            treatment <- myT$Treatment
            time <- myT$StressLength
            multiWay <- paste(ac, myT$StressLength)
            multiWay[which(myT$Treatment == "Ctrl", arr.ind = TRUE)]<-"Control"
            names[index] = names(myT)[i]
            ## Some kind of vector for the variables of interest
            myFrame <- data.frame(bug, ac, time, multiWay, sex, cage, treatment, batch, date, mo, date)
            ## M1 <- lm(bug ~ sex + treatment + time + batch + group + date, data = myFrame)
            ## M2 <- lm(bug ~ sex + treatment + time + batch, data = myFrame)
            ## M3 <- lm(bug ~ sex*treatment*time*batch, data = myFrame)
            ## M4 <- lm(bug ~ treatment*batch + sex*time*batch, data = myFrame)
            ## M5 <- lm(bug ~ treatment*time, data = myFrame)
            ## M6 <- lm(bug ~ sex + time + batch, data = myFrame)
            ## M7 <- lm(bug ~ sex + batch, data = myFrame)
            ## drop1(M1, test=
            if(mlm == TRUE){
                fullModel <- gls( bug~ treatment, method="REML",correlation=corCompSymm(form=~1|factor(group)),	data = myFrame )
                reducedModel <- gls( bug~ treatment, method="REML", data = myFrame )
                fullModelLME <- lme(bug~ treatment, method="REML", random = ~1|factor(group), data = myFrame)
            }
            else{
                fullModelLME <- lm(bug~ treatment*time + batch, x=TRUE)
            }
            ## Potential save time by reducing anova calls
            ## Introduce the goodness of fit tests here
            ## Can streamline vectors to be automatically responsive to changes to the model
            if(mlm == TRUE){
                allNames <- rownames(anova(fullModelLME))[-1]
                allpvals[[index]] <- anova(fullModelLME)$"p-value"[-1]
            }
            else {
                allNames <- rownames(anova(fullModelLME))[-dim(anova(fullModelLME))[1]]
                allpvals[[index]]<-as.data.frame(anova(fullModelLME))[1:dim(anova(fullModelLME))[1]-1,5]
            }

            ## Random Effects and Interclass Correlation Coefficient
            if(mlm == TRUE){
                allNames<-c(allNames, "cage", "iccCage")
                allpvals[[index]]<-c(allpvals[[index]], anova(fullModelLME, reducedModel)$"p-value"[2], coef(fullModel$modelStruct[1]$corStruct,unconstrained=FALSE)[[1]])
                pValuesCage[index] <-  anova(fullModelLME, reducedModel)$"p-value"[2]
                ## This is different as it is not corrected for multiple hypothesis testing.
                iccCage[index]<- coef(fullModel$modelStruct[1]$corStruct,unconstrained=FALSE)[[1]]
            }
    ## Nice plotting
            ## Correct so that it uses corrected p-values
            if(mlm == TRUE){
                graphMain = c(names[i], paste(c(rep("p-",length(allNames)-1),""), allNames, " = ", format(allpvals[[index]], digits=3), sep=""))
            }
            else {
                graphMain = c(names[i], paste(c(rep("p-",length(allNames)),""), allNames, " = ", format(allpvals[[index]], digits=3), sep=""))

            }

            ## mlm is boolean 1/0 value. Basically, don't graph on icc
            ## need a correction for interaction terms as well
            numPlots <- length(allNames) - mlm
            par(mfrow=c(numPlots, 1),
                oma = c(1,1,0,0) + 0.1,
                mar = c(1,4,3,0) + 0.1)

            for(j in 1:numPlots){
                if(j == 1){
                    plot( bug ~ factor(get(allNames[j])), ylab = names[i], main = c(names[index],toString(graphMain[-1])) )
                    points(factor(get(allNames[j])), bug)
                }
                else{
                    testInteract <- grep(":", allNames)
                    if(length(testInteract) > 0){
                        if(j %in% testInteract){
                            intSplit <- unlist(strsplit(allNames[grep(":",allNames)[which(grep(":", allNames) == j)]],split=":"))
                            if(length(intSplit) == 2){
                                plot( bug ~ factor(c( paste( get(intSplit[1]), get(intSplit[2]),sep=""))))
                                points(factor(c( paste( get(intSplit[1]), get(intSplit[2]),sep=""))), bug)
                            }
                            else{
                                plot( bug ~ factor(c( paste( get(intSplit[1]), get(intSplit[2]), get(intSplit[3]),sep=""))))
                                points(factor(c( paste( get(intSplit[1]), get(intSplit[2]), get(intSplit[3]),sep=""))), bug)
                            }
                        }
                    }
                    else{
                        plot( bug ~ factor(get(allNames[j])), ylab = names[i])
                        points(factor(get(allNames[j])), bug)
                    }
                }
            }

            index <- index + 1
	}

    ## This should also be dynamic
    dFrame <- as.data.frame(matrix(unlist(allpvals), nrow= length(allpvals), byrow=TRUE))
    colnames(dFrame) <- unlist(allNames)
    rownames(dFrame) <- names
    orgCol <- ncol(dFrame)

    for(k in 1:(orgCol-mlm)){
        dFrame[, k + orgCol]<-p.adjust(dFrame[,k], method = "BH")
    }
    colnames(dFrame)[(orgCol + 1):length(dFrame)]<-paste0(rep("adjusted_"),colnames(dFrame)[1:(orgCol - mlm)])

    dFrame <- cbind(names, dFrame)
    ## Try and dynamically generate the name of the plot here...
    write.table(dFrame, file=paste("pValues", filePrefix, taxa, ".txt",sep=""), sep="\t",row.names=FALSE)

    ## Get the sig table working
    ## It would also be nice to have a sig-picker for the plots and a combination of all sig results into one plot.
    keepVector <- grep("adj", names(dFrame))
    sigdFrame <-dFrame[which(dFrame[,keepVector] < 0.05,arr.ind=TRUE),]
    write.table(sigdFrame, file=paste("SIGpValues", filePrefix, taxa, ".txt",sep=""), sep="\t",row.names=FALSE)

    dev.off()
}

rm(list=ls())

library("pscl")
library("lmtest")
library("nlme")
library("vegan")

setwd("/Users/mbrown67/Documents/Fodor/Datasets/MarkExperiment/Pooled/")

taxaLevels <- c( "phylum", "class", "order", "family", "genus")

filePrefix <- "_treatment*time_batch*time_"
mlm<- FALSE

dropBatch <- "Lyte_Batch04_Run01_repeat"
dropTime <- 14
dropTreatment <- "Exp"

for(taxa in taxaLevels){

    inFileName <- paste( taxa, "LogNormwithMetadata_R1_Pooled.txt", sep ="")
    myT <-read.csv(inFileName,header=TRUE,sep="", na.strings="BLAH")

    numCols <- ncol(myT)
    numMetadataCols <- 20

    ## Reprocessing for correct column data type
    myColClasses <- c("character", rep("numeric", numCols - numMetadataCols - 1), rep("character", 11), "numeric", "numeric", "numeric", "character", "character", "character", "character", "character", "character")
    myT <-read.csv(inFileName, header=TRUE, sep="", colClasses=myColClasses, na.strings="BLAH", comment.char ="@")

    ## Removing unwanted samples {controls, replicates, duplicates, poor quality samples}
    removeControls<-c( "C1", "C2", "N1", "N2", "Neg", "Pos")
    myT<-myT[!(myT$Sample_ID %in% removeControls),]

    removetrs<-c("04_125_tr", "04_101_tr", "04_103_tr", "04_74_tr", "04_70_tr", "04_40_tr", "04_41_tr", "04_84_tr")
    myT<-myT[!(myT$Sample_ID %in% removetrs),]

    removeDups<-c("04-04_S63_L001_R1_001")
    myT<-myT[!(myT$MatchFile %in% removeDups),]

    ## Controls not dropped earlier
    manualDrop <- c("Neg_S40_L001_R1_001", "PCR1Neg_S65_L001_R1_001")
    myT<-myT[!(myT$MatchFile %in% manualDrop),]

    labDrop <- c("Harlan Labs")
    myT<-myT[!(myT$MouseOrigin %in% labDrop),]

    lowSeqDrop <- c("04-55_S32_L001_R1_001")
    myT<-myT[!(myT$MatchFile %in% lowSeqDrop),]
    ## Not sure what to do about this though.
    ### myT$Condition[which(myT$Treatment == "Ctrl", arr.ind = TRUE)]<-"Control"

##    myT<-myT[!(myT$Sample_Plate == dropBatch),]
##    myT<-myT[myT$StressLength == dropTime,]

    names <- vector()
    pValuesSex<- vector()
    pValuesAcuteChronic<- vector()
    pValuesCage<- vector()
    iccCage <- vector()
    iccKeptCounts <- vector()
    pValuesBatch<- vector()
    pValuesTreatment<- vector()
    pValuesTime <- vector()
    pValuesStressLength <- vector()
    pValuesInteraction <- vector()
    allpvals <- list()

    index <- 1
    pdf( paste(taxa, filePrefix, "boxplots.pdf", sep=""))

    for( i in 2:(ncol(myT) - numMetadataCols))
        if( sum(myT[,i] != 0 ) > nrow(myT) / 4 ){
            ## Easy access names
            bug <- myT[,i]
            ac <- myT$Condition
            sex <- myT$Sex
            cage <- myT$Cage
            batch <- myT$Sample_Plate
            date <- myT$Date
            mo <- myT$MouseOrigin
            group <- myT$SpreadsheetGrouping
            treatment <- myT$Treatment
            time <- myT$StressLength
            multiWay <- paste(ac, myT$StressLength)
            multiWay[which(myT$Treatment == "Ctrl", arr.ind = TRUE)]<-"Control"
            names[index] = names(myT)[i]
            ## Some kind of vector for the variables of interest
            myFrame <- data.frame(bug, ac, time, multiWay, sex, cage, treatment, batch, date, mo, date)
            ## M1 <- lm(bug ~ sex + treatment + time + batch + group + date, data = myFrame)
            ## M2 <- lm(bug ~ sex + treatment + time + batch, data = myFrame)
            ## M3 <- lm(bug ~ sex*treatment*time*batch, data = myFrame)
            ## M4 <- lm(bug ~ treatment*batch + sex*time*batch, data = myFrame)
            ## M5 <- lm(bug ~ treatment*time, data = myFrame)
            ## M6 <- lm(bug ~ sex + time + batch, data = myFrame)
            ## M7 <- lm(bug ~ sex + batch, data = myFrame)
            ## drop1(M1, test=
            if(mlm == TRUE){
                fullModel <- gls( bug~ treatment, method="REML",correlation=corCompSymm(form=~1|factor(group)),	data = myFrame )
                reducedModel <- gls( bug~ treatment, method="REML", data = myFrame )
                fullModelLME <- lme(bug~ treatment, method="REML", random = ~1|factor(group), data = myFrame)
            }
            else{
                fullModelLME <- lm(bug~ treatment*time + batch*time, x=TRUE)
            }
            ## Potential save time by reducing anova calls
            ## Introduce the goodness of fit tests here
            ## Can streamline vectors to be automatically responsive to changes to the model
            if(mlm == TRUE){
                allNames <- rownames(anova(fullModelLME))[-1]
                allpvals[[index]] <- anova(fullModelLME)$"p-value"[-1]
            }
            else {
                allNames <- rownames(anova(fullModelLME))[-dim(anova(fullModelLME))[1]]
                allpvals[[index]]<-as.data.frame(anova(fullModelLME))[1:dim(anova(fullModelLME))[1]-1,5]
            }

            ## Random Effects and Interclass Correlation Coefficient
            if(mlm == TRUE){
                allNames<-c(allNames, "cage", "iccCage")
                allpvals[[index]]<-c(allpvals[[index]], anova(fullModelLME, reducedModel)$"p-value"[2], coef(fullModel$modelStruct[1]$corStruct,unconstrained=FALSE)[[1]])
                pValuesCage[index] <-  anova(fullModelLME, reducedModel)$"p-value"[2]
                ## This is different as it is not corrected for multiple hypothesis testing.
                iccCage[index]<- coef(fullModel$modelStruct[1]$corStruct,unconstrained=FALSE)[[1]]
            }
    ## Nice plotting
            ## Correct so that it uses corrected p-values
            if(mlm == TRUE){
                graphMain = c(names[i], paste(c(rep("p-",length(allNames)-1),""), allNames, " = ", format(allpvals[[index]], digits=3), sep=""))
            }
            else {
                graphMain = c(names[i], paste(c(rep("p-",length(allNames)),""), allNames, " = ", format(allpvals[[index]], digits=3), sep=""))

            }

            ## mlm is boolean 1/0 value. Basically, don't graph on icc
            ## need a correction for interaction terms as well
            numPlots <- length(allNames) - mlm
            par(mfrow=c(numPlots, 1),
                oma = c(1,1,0,0) + 0.1,
                mar = c(1,4,3,0) + 0.1)

            for(j in 1:numPlots){
                if(j == 1){
                    plot( bug ~ factor(get(allNames[j])), ylab = names[i], main = c(names[index],toString(graphMain[-1])) )
                    points(factor(get(allNames[j])), bug)
                }
                else{
                    testInteract <- grep(":", allNames)
                    if(length(testInteract) > 0){
                        if(j %in% testInteract){
                            intSplit <- unlist(strsplit(allNames[grep(":",allNames)[which(grep(":", allNames) == j)]],split=":"))
                            if(length(intSplit) == 2){
                                plot( bug ~ factor(c( paste( get(intSplit[1]), get(intSplit[2]),sep=""))))
                                points(factor(c( paste( get(intSplit[1]), get(intSplit[2]),sep=""))), bug)
                            }
                            else{
                                plot( bug ~ factor(c( paste( get(intSplit[1]), get(intSplit[2]), get(intSplit[3]),sep=""))))
                                points(factor(c( paste( get(intSplit[1]), get(intSplit[2]), get(intSplit[3]),sep=""))), bug)
                            }
                        }
                    }
                    else{
                        plot( bug ~ factor(get(allNames[j])), ylab = names[i])
                        points(factor(get(allNames[j])), bug)
                    }
                }
            }

            index <- index + 1
	}

    ## This should also be dynamic
    dFrame <- as.data.frame(matrix(unlist(allpvals), nrow= length(allpvals), byrow=TRUE))
    colnames(dFrame) <- unlist(allNames)
    rownames(dFrame) <- names
    orgCol <- ncol(dFrame)

    for(k in 1:(orgCol-mlm)){
        dFrame[, k + orgCol]<-p.adjust(dFrame[,k], method = "BH")
    }
    colnames(dFrame)[(orgCol + 1):length(dFrame)]<-paste0(rep("adjusted_"),colnames(dFrame)[1:(orgCol - mlm)])

    dFrame <- cbind(names, dFrame)
    ## Try and dynamically generate the name of the plot here...
    write.table(dFrame, file=paste("pValues", filePrefix, taxa, ".txt",sep=""), sep="\t",row.names=FALSE)

    ## Get the sig table working
    ## It would also be nice to have a sig-picker for the plots and a combination of all sig results into one plot.
    keepVector <- grep("adj", names(dFrame))
    sigdFrame <-dFrame[which(dFrame[,keepVector] < 0.05,arr.ind=TRUE),]
    write.table(sigdFrame, file=paste("SIGpValues", filePrefix, taxa, ".txt",sep=""), sep="\t",row.names=FALSE)

    dev.off()
}

rm(list=ls())

library("pscl")
library("lmtest")
library("nlme")
library("vegan")

setwd("/Users/mbrown67/Documents/Fodor/Datasets/MarkExperiment/Pooled/")

taxaLevels <- c( "phylum", "class", "order", "family", "genus")

filePrefix <- "_sex*treatment*time_batch*time_"
mlm<- FALSE

dropBatch <- "Lyte_Batch04_Run01_repeat"
dropTime <- 14
dropTreatment <- "Exp"

for(taxa in taxaLevels){

    inFileName <- paste( taxa, "LogNormwithMetadata_R1_Pooled.txt", sep ="")
    myT <-read.csv(inFileName,header=TRUE,sep="", na.strings="BLAH")

    numCols <- ncol(myT)
    numMetadataCols <- 20

    ## Reprocessing for correct column data type
    myColClasses <- c("character", rep("numeric", numCols - numMetadataCols - 1), rep("character", 11), "numeric", "numeric", "numeric", "character", "character", "character", "character", "character", "character")
    myT <-read.csv(inFileName, header=TRUE, sep="", colClasses=myColClasses, na.strings="BLAH", comment.char ="@")

    ## Removing unwanted samples {controls, replicates, duplicates, poor quality samples}
    removeControls<-c( "C1", "C2", "N1", "N2", "Neg", "Pos")
    myT<-myT[!(myT$Sample_ID %in% removeControls),]

    removetrs<-c("04_125_tr", "04_101_tr", "04_103_tr", "04_74_tr", "04_70_tr", "04_40_tr", "04_41_tr", "04_84_tr")
    myT<-myT[!(myT$Sample_ID %in% removetrs),]

    removeDups<-c("04-04_S63_L001_R1_001")
    myT<-myT[!(myT$MatchFile %in% removeDups),]

    ## Controls not dropped earlier
    manualDrop <- c("Neg_S40_L001_R1_001", "PCR1Neg_S65_L001_R1_001")
    myT<-myT[!(myT$MatchFile %in% manualDrop),]

    labDrop <- c("Harlan Labs")
    myT<-myT[!(myT$MouseOrigin %in% labDrop),]

    lowSeqDrop <- c("04-55_S32_L001_R1_001")
    myT<-myT[!(myT$MatchFile %in% lowSeqDrop),]
    ## Not sure what to do about this though.
    ### myT$Condition[which(myT$Treatment == "Ctrl", arr.ind = TRUE)]<-"Control"

##    myT<-myT[!(myT$Sample_Plate == dropBatch),]
##    myT<-myT[myT$StressLength == dropTime,]

    names <- vector()
    pValuesSex<- vector()
    pValuesAcuteChronic<- vector()
    pValuesCage<- vector()
    iccCage <- vector()
    iccKeptCounts <- vector()
    pValuesBatch<- vector()
    pValuesTreatment<- vector()
    pValuesTime <- vector()
    pValuesStressLength <- vector()
    pValuesInteraction <- vector()
    allpvals <- list()

    index <- 1
    pdf( paste(taxa, filePrefix, "boxplots.pdf", sep=""))

    for( i in 2:(ncol(myT) - numMetadataCols))
        if( sum(myT[,i] != 0 ) > nrow(myT) / 4 ){
            ## Easy access names
            bug <- myT[,i]
            ac <- myT$Condition
            sex <- myT$Sex
            cage <- myT$Cage
            batch <- myT$Sample_Plate
            date <- myT$Date
            mo <- myT$MouseOrigin
            group <- myT$SpreadsheetGrouping
            treatment <- myT$Treatment
            time <- myT$StressLength
            multiWay <- paste(ac, myT$StressLength)
            multiWay[which(myT$Treatment == "Ctrl", arr.ind = TRUE)]<-"Control"
            names[index] = names(myT)[i]
            ## Some kind of vector for the variables of interest
            myFrame <- data.frame(bug, ac, time, multiWay, sex, cage, treatment, batch, date, mo, date)
            ## M1 <- lm(bug ~ sex + treatment + time + batch + group + date, data = myFrame)
            ## M2 <- lm(bug ~ sex + treatment + time + batch, data = myFrame)
            ## M3 <- lm(bug ~ sex*treatment*time*batch, data = myFrame)
            ## M4 <- lm(bug ~ treatment*batch + sex*time*batch, data = myFrame)
            ## M5 <- lm(bug ~ treatment*time, data = myFrame)
            ## M6 <- lm(bug ~ sex + time + batch, data = myFrame)
            ## M7 <- lm(bug ~ sex + batch, data = myFrame)
            ## drop1(M1, test=
            if(mlm == TRUE){
                fullModel <- gls( bug~ treatment, method="REML",correlation=corCompSymm(form=~1|factor(group)),	data = myFrame )
                reducedModel <- gls( bug~ treatment, method="REML", data = myFrame )
                fullModelLME <- lme(bug~ treatment, method="REML", random = ~1|factor(group), data = myFrame)
            }
            else{
                fullModelLME <- lm(bug~ sex*treatment*time + batch*time, x=TRUE)
            }
            ## Potential save time by reducing anova calls
            ## Introduce the goodness of fit tests here
            ## Can streamline vectors to be automatically responsive to changes to the model
            if(mlm == TRUE){
                allNames <- rownames(anova(fullModelLME))[-1]
                allpvals[[index]] <- anova(fullModelLME)$"p-value"[-1]
            }
            else {
                allNames <- rownames(anova(fullModelLME))[-dim(anova(fullModelLME))[1]]
                allpvals[[index]]<-as.data.frame(anova(fullModelLME))[1:dim(anova(fullModelLME))[1]-1,5]
            }

            ## Random Effects and Interclass Correlation Coefficient
            if(mlm == TRUE){
                allNames<-c(allNames, "cage", "iccCage")
                allpvals[[index]]<-c(allpvals[[index]], anova(fullModelLME, reducedModel)$"p-value"[2], coef(fullModel$modelStruct[1]$corStruct,unconstrained=FALSE)[[1]])
                pValuesCage[index] <-  anova(fullModelLME, reducedModel)$"p-value"[2]
                ## This is different as it is not corrected for multiple hypothesis testing.
                iccCage[index]<- coef(fullModel$modelStruct[1]$corStruct,unconstrained=FALSE)[[1]]
            }
    ## Nice plotting
            ## Correct so that it uses corrected p-values
            if(mlm == TRUE){
                graphMain = c(names[i], paste(c(rep("p-",length(allNames)-1),""), allNames, " = ", format(allpvals[[index]], digits=3), sep=""))
            }
            else {
                graphMain = c(names[i], paste(c(rep("p-",length(allNames)),""), allNames, " = ", format(allpvals[[index]], digits=3), sep=""))

            }

            ## mlm is boolean 1/0 value. Basically, don't graph on icc
            ## need a correction for interaction terms as well
            numPlots <- length(allNames) - mlm
            par(mfrow=c(numPlots, 1),
                oma = c(1,1,0,0) + 0.1,
                mar = c(1,4,3,0) + 0.1)

            for(j in 1:numPlots){
                if(j == 1){
                    plot( bug ~ factor(get(allNames[j])), ylab = names[i], main = c(names[index],toString(graphMain[-1])) )
                    points(factor(get(allNames[j])), bug)
                }
                else{
                    testInteract <- grep(":", allNames)
                    if(length(testInteract) > 0){
                        if(j %in% testInteract){
                            intSplit <- unlist(strsplit(allNames[grep(":",allNames)[which(grep(":", allNames) == j)]],split=":"))
                            if(length(intSplit) == 2){
                                plot( bug ~ factor(c( paste( get(intSplit[1]), get(intSplit[2]),sep=""))))
                                points(factor(c( paste( get(intSplit[1]), get(intSplit[2]),sep=""))), bug)
                            }
                            else{
                                plot( bug ~ factor(c( paste( get(intSplit[1]), get(intSplit[2]), get(intSplit[3]),sep=""))))
                                points(factor(c( paste( get(intSplit[1]), get(intSplit[2]), get(intSplit[3]),sep=""))), bug)
                            }
                        }
                    }
                    else{
                        plot( bug ~ factor(get(allNames[j])), ylab = names[i])
                        points(factor(get(allNames[j])), bug)
                    }
                }
            }

            index <- index + 1
	}

    ## This should also be dynamic
    dFrame <- as.data.frame(matrix(unlist(allpvals), nrow= length(allpvals), byrow=TRUE))
    colnames(dFrame) <- unlist(allNames)
    rownames(dFrame) <- names
    orgCol <- ncol(dFrame)

    for(k in 1:(orgCol-mlm)){
        dFrame[, k + orgCol]<-p.adjust(dFrame[,k], method = "BH")
    }
    colnames(dFrame)[(orgCol + 1):length(dFrame)]<-paste0(rep("adjusted_"),colnames(dFrame)[1:(orgCol - mlm)])

    dFrame <- cbind(names, dFrame)
    ## Try and dynamically generate the name of the plot here...
    write.table(dFrame, file=paste("pValues", filePrefix, taxa, ".txt",sep=""), sep="\t",row.names=FALSE)

    ## Get the sig table working
    ## It would also be nice to have a sig-picker for the plots and a combination of all sig results into one plot.
    keepVector <- grep("adj", names(dFrame))
    sigdFrame <-dFrame[which(dFrame[,keepVector] < 0.05,arr.ind=TRUE),]
    write.table(sigdFrame, file=paste("SIGpValues", filePrefix, taxa, ".txt",sep=""), sep="\t",row.names=FALSE)

    dev.off()
}

rm(list=ls())

library("pscl")
library("lmtest")
library("nlme")
library("vegan")

setwd("/Users/mbrown67/Documents/Fodor/Datasets/MarkExperiment/Pooled/")

taxaLevels <- c( "phylum", "class", "order", "family", "genus")

filePrefix <- "_sex*time*batch_"
mlm<- FALSE

dropBatch <- "Lyte_Batch04_Run01_repeat"
dropTime <- 14
dropTreatment <- "Exp"

for(taxa in taxaLevels){

    inFileName <- paste( taxa, "LogNormwithMetadata_R1_Pooled.txt", sep ="")
    myT <-read.csv(inFileName,header=TRUE,sep="", na.strings="BLAH")

    numCols <- ncol(myT)
    numMetadataCols <- 20

    ## Reprocessing for correct column data type
    myColClasses <- c("character", rep("numeric", numCols - numMetadataCols - 1), rep("character", 11), "numeric", "numeric", "numeric", "character", "character", "character", "character", "character", "character")
    myT <-read.csv(inFileName, header=TRUE, sep="", colClasses=myColClasses, na.strings="BLAH", comment.char ="@")

    ## Removing unwanted samples {controls, replicates, duplicates, poor quality samples}
    removeControls<-c( "C1", "C2", "N1", "N2", "Neg", "Pos")
    myT<-myT[!(myT$Sample_ID %in% removeControls),]

    removetrs<-c("04_125_tr", "04_101_tr", "04_103_tr", "04_74_tr", "04_70_tr", "04_40_tr", "04_41_tr", "04_84_tr")
    myT<-myT[!(myT$Sample_ID %in% removetrs),]

    removeDups<-c("04-04_S63_L001_R1_001")
    myT<-myT[!(myT$MatchFile %in% removeDups),]

    ## Controls not dropped earlier
    manualDrop <- c("Neg_S40_L001_R1_001", "PCR1Neg_S65_L001_R1_001")
    myT<-myT[!(myT$MatchFile %in% manualDrop),]

    labDrop <- c("Harlan Labs")
    myT<-myT[!(myT$MouseOrigin %in% labDrop),]

    lowSeqDrop <- c("04-55_S32_L001_R1_001")
    myT<-myT[!(myT$MatchFile %in% lowSeqDrop),]
    ## Not sure what to do about this though.
    ### myT$Condition[which(myT$Treatment == "Ctrl", arr.ind = TRUE)]<-"Control"

##    myT<-myT[!(myT$Sample_Plate == dropBatch),]
##    myT<-myT[myT$StressLength == dropTime,]

    names <- vector()
    pValuesSex<- vector()
    pValuesAcuteChronic<- vector()
    pValuesCage<- vector()
    iccCage <- vector()
    iccKeptCounts <- vector()
    pValuesBatch<- vector()
    pValuesTreatment<- vector()
    pValuesTime <- vector()
    pValuesStressLength <- vector()
    pValuesInteraction <- vector()
    allpvals <- list()

    index <- 1
    pdf( paste(taxa, filePrefix, "boxplots.pdf", sep=""))

    for( i in 2:(ncol(myT) - numMetadataCols))
        if( sum(myT[,i] != 0 ) > nrow(myT) / 4 ){
            ## Easy access names
            bug <- myT[,i]
            ac <- myT$Condition
            sex <- myT$Sex
            cage <- myT$Cage
            batch <- myT$Sample_Plate
            date <- myT$Date
            mo <- myT$MouseOrigin
            group <- myT$SpreadsheetGrouping
            treatment <- myT$Treatment
            time <- myT$StressLength
            multiWay <- paste(ac, myT$StressLength)
            multiWay[which(myT$Treatment == "Ctrl", arr.ind = TRUE)]<-"Control"
            names[index] = names(myT)[i]
            ## Some kind of vector for the variables of interest
            myFrame <- data.frame(bug, ac, time, multiWay, sex, cage, treatment, batch, date, mo, date)
            ## M1 <- lm(bug ~ sex + treatment + time + batch + group + date, data = myFrame)
            ## M2 <- lm(bug ~ sex + treatment + time + batch, data = myFrame)
            ## M3 <- lm(bug ~ sex*treatment*time*batch, data = myFrame)
            ## M4 <- lm(bug ~ treatment*batch + sex*time*batch, data = myFrame)
            ## M5 <- lm(bug ~ treatment*time, data = myFrame)
            ## M6 <- lm(bug ~ sex + time + batch, data = myFrame)
            ## M7 <- lm(bug ~ sex + batch, data = myFrame)
            ## drop1(M1, test=
            if(mlm == TRUE){
                fullModel <- gls( bug~ treatment, method="REML",correlation=corCompSymm(form=~1|factor(group)),	data = myFrame )
                reducedModel <- gls( bug~ treatment, method="REML", data = myFrame )
                fullModelLME <- lme(bug~ treatment, method="REML", random = ~1|factor(group), data = myFrame)
            }
            else{
                fullModelLME <- lm(bug~ sex*time*batch, x=TRUE)
            }
            ## Potential save time by reducing anova calls
            ## Introduce the goodness of fit tests here
            ## Can streamline vectors to be automatically responsive to changes to the model
            if(mlm == TRUE){
                allNames <- rownames(anova(fullModelLME))[-1]
                allpvals[[index]] <- anova(fullModelLME)$"p-value"[-1]
            }
            else {
                allNames <- rownames(anova(fullModelLME))[-dim(anova(fullModelLME))[1]]
                allpvals[[index]]<-as.data.frame(anova(fullModelLME))[1:dim(anova(fullModelLME))[1]-1,5]
            }

            ## Random Effects and Interclass Correlation Coefficient
            if(mlm == TRUE){
                allNames<-c(allNames, "cage", "iccCage")
                allpvals[[index]]<-c(allpvals[[index]], anova(fullModelLME, reducedModel)$"p-value"[2], coef(fullModel$modelStruct[1]$corStruct,unconstrained=FALSE)[[1]])
                pValuesCage[index] <-  anova(fullModelLME, reducedModel)$"p-value"[2]
                ## This is different as it is not corrected for multiple hypothesis testing.
                iccCage[index]<- coef(fullModel$modelStruct[1]$corStruct,unconstrained=FALSE)[[1]]
            }
    ## Nice plotting
            ## Correct so that it uses corrected p-values
            if(mlm == TRUE){
                graphMain = c(names[i], paste(c(rep("p-",length(allNames)-1),""), allNames, " = ", format(allpvals[[index]], digits=3), sep=""))
            }
            else {
                graphMain = c(names[i], paste(c(rep("p-",length(allNames)),""), allNames, " = ", format(allpvals[[index]], digits=3), sep=""))

            }

            ## mlm is boolean 1/0 value. Basically, don't graph on icc
            ## need a correction for interaction terms as well
            numPlots <- length(allNames) - mlm
            par(mfrow=c(numPlots, 1),
                oma = c(1,1,0,0) + 0.1,
                mar = c(1,4,3,0) + 0.1)

            for(j in 1:numPlots){
                if(j == 1){
                    plot( bug ~ factor(get(allNames[j])), ylab = names[i], main = c(names[index],toString(graphMain[-1])) )
                    points(factor(get(allNames[j])), bug)
                }
                else{
                    testInteract <- grep(":", allNames)
                    if(length(testInteract) > 0){
                        if(j %in% testInteract){
                            intSplit <- unlist(strsplit(allNames[grep(":",allNames)[which(grep(":", allNames) == j)]],split=":"))
                            if(length(intSplit) == 2){
                                plot( bug ~ factor(c( paste( get(intSplit[1]), get(intSplit[2]),sep=""))))
                                points(factor(c( paste( get(intSplit[1]), get(intSplit[2]),sep=""))), bug)
                            }
                            else{
                                plot( bug ~ factor(c( paste( get(intSplit[1]), get(intSplit[2]), get(intSplit[3]),sep=""))))
                                points(factor(c( paste( get(intSplit[1]), get(intSplit[2]), get(intSplit[3]),sep=""))), bug)
                            }
                        }
                    }
                    else{
                        plot( bug ~ factor(get(allNames[j])), ylab = names[i])
                        points(factor(get(allNames[j])), bug)
                    }
                }
            }

            index <- index + 1
	}

    ## This should also be dynamic
    dFrame <- as.data.frame(matrix(unlist(allpvals), nrow= length(allpvals), byrow=TRUE))
    colnames(dFrame) <- unlist(allNames)
    rownames(dFrame) <- names
    orgCol <- ncol(dFrame)

    for(k in 1:(orgCol-mlm)){
        dFrame[, k + orgCol]<-p.adjust(dFrame[,k], method = "BH")
    }
    colnames(dFrame)[(orgCol + 1):length(dFrame)]<-paste0(rep("adjusted_"),colnames(dFrame)[1:(orgCol - mlm)])

    dFrame <- cbind(names, dFrame)
    ## Try and dynamically generate the name of the plot here...
    write.table(dFrame, file=paste("pValues", filePrefix, taxa, ".txt",sep=""), sep="\t",row.names=FALSE)

    ## Get the sig table working
    ## It would also be nice to have a sig-picker for the plots and a combination of all sig results into one plot.
    keepVector <- grep("adj", names(dFrame))
    sigdFrame <-dFrame[which(dFrame[,keepVector] < 0.05,arr.ind=TRUE),]
    write.table(sigdFrame, file=paste("SIGpValues", filePrefix, taxa, ".txt",sep=""), sep="\t",row.names=FALSE)

    dev.off()
}

Beta <- vector()
for( i in 2:8){
    Mi <- summary(lm(bug ~ cage, subset = (group == i), data = myFrame)
    Beta[i] <- Mi$coef[2,1]
}


Beta <- vector()
for( i in 2:8){
    Mi <- summary(lm(bug ~ cage, subset = (group == i), data = myFrame))
    Beta[i] <- Mi$coef[2,1]
}

Beta

Beta <- vector()
for( i in 1:4){
    Mi <- summary(lm(bug ~ cage, subset = (date == i), data = myFrame))
    Beta[i] <- Mi$coef[2,1]
}

factor(date)
as.numeric(date)
as.numeric(factor(date))

Beta <- vector()
for( i in 1:4){
    Mi <- summary(lm(bug ~ cage, subset = (as.numeric(factor(date)) == i), data = myFrame))
    Beta[i] <- Mi$coef[2,1]
}

Beta
factor(date)
rm(list=ls())

library("pscl")
library("lmtest")
library("nlme")
# Below is what I need for the Shannon diversity.
library("vegan")

# for experiment, treatment, and batch, and no confounder

setwd("/Users/mbrown67/Documents/Fodor/Datasets/MarkExperiment/Pooled/")

taxaLevels <- c( "phylum", "class", "order", "family", "genus")
# All of this data should be present in any analysis, so there is no reason to make it optional or subject to a switch/case statement.

#inforShannon<-read.table("otuTaxaAsColumnsLogNormWithMetadata.txt.temp", header=TRUE, sep="\t")
#numColsS <- ncol(inforShannon)
#myColClassesS <- c(rep("character",8), rep("numeric", numColsS-8))
#inforShannon <-read.table("otuTaxaAsColumnsLogNormWithMetadata.txt.temp", header=TRUE,sep="\t",row.names=1,colClasses=myColClassesS)
for(groupNum in 2:8){
    for(taxa in taxaLevels ){
	inFileName <- paste( taxa, "LogNormwithMetadata_R1_Pooled.txt", sep ="")
	myT <-read.csv(inFileName,header=TRUE,sep="", na.strings="BLAH")
	numCols <- ncol(myT)
        numMetadataCols <- 20
        ## Reprocessing for correct interpretation
        ## myColClasses <- c("character", rep("numeric", numCols - 16), rep("character", 17))
        ## myT <-read.csv(inFileName, header=TRUE, sep="", colClasses=myColClasses, na.strings="BLAH")
        ## Drop unneeded rows

        removeControls<-c( "C1", "C2", "N1", "N2", "Neg", "Pos")
        myT<-myT[!(myT$Sample_ID %in% removeControls),]
        removetrs<-c("04_125_tr", "04_101_tr", "04_103_tr", "04_74_tr", "04_70_tr", "04_40_tr", "04_41_tr", "04_84_tr")
        myT<-myT[!(myT$Sample_ID %in% removetrs),]
        removeDups<-c("04-04_S63_L001_R1_001")
        ## Somewhat arbitrarily here
        myT<-myT[!(myT$MatchFile %in% removeDups),]
        ## removeLow<-c("04-55_S32_L001_R1_001")
        ## myT<-myT[!(myT$MatchFile %in% removeLow),]

        ## Have to manually drop these for some reason
        manualDrop <- c("Neg_S40_L001_R1_001", "PCR1Neg_S65_L001_R1_001")
        myT<-myT[!(myT$MatchFile %in% manualDrop),]

        myT<-myT[myT$SpreadsheetGrouping == groupNum,]
        lowSeqDrop <- c("04-55_S32_L001_R1_001")
        myT<-myT[!(myT$MatchFile %in% lowSeqDrop),]


        ## print("Got through Processing")

	# our initial model not worrying about confounders except cage
	names <- vector()
	pValuesSex<- vector()
	pValuesAcuteChronic<- vector()
	pValuesCage<- vector()
        iccCage <- vector()
        iccKeptCounts <- vector()
        pValuesBatch<- vector()
        pValuesTreatment<- vector()
        ## pValuesShannon<- vector()
        pValuesKeptCounts<- vector()
	## WARNING:  EXPERIMENT IS CONFOUNDED WITH AC  + SEX - INTERPRET WITH CAUTION!!!!!
	pValuesExperiment <- vector()
        acConf <- vector()
        sexConf <- vector()
        time <- vector()
        pValuesTime <- vector()

	index <- 1
	pdf( paste(taxa, "_", groupNum,"_Treatment_batch_Cage_eachGroup_boxplots.pdf", sep=""))
        print(groupNum)
	for( i in 2:(ncol(myT)-numMetadataCols))
 		if( sum(myT[,i] != 0 ) > nrow(myT) / 4 )
		{
			bug <- myT[,i]
			ac <- myT$Condition
			sex <- myT$Sex
			cage <- myT$Cage
                        batch <- myT$Sample_Project
                        date <- myT$Date
                        time <- myT$StressLength
                        mo <- myT$MouseOrigin
                        treatment <- myT$Treatment

                        myFrame <- data.frame(bug, ac, sex, cage, treatment, batch, date, mo)

                        ##fullModel <- lm(bug ~ treatment + batch, x=TRUE)

			fullModel <- gls( bug~   treatment + batch, method="REML",correlation=corCompSymm(form=~1|factor(cage)), data = myFrame )
                        reducedModel <- gls( bug~  treatment + batch, method="REML", data = myFrame )
                        fullModelLME <- lme(bug~  treatment + batch, method="REML", random = ~1|factor(cage), data = myFrame)
                        ## It seems like reducing the anova calls could speed things up a bit

      			pValuesTreatment[index] <- anova(fullModelLME)$"p-value"[2]
                        ##pValuesTime[index] <- anova(fullModelLME)$"p-value"[5]
			## pValuesSex[index] <- anova(fullModelLME)$"p-value"[5]
			## pValuesExperiment[index] <- anova(fullModelLME)$"p-value"[5]
                        ## pValuesStressLength[index] <- anova(fullModel)$"Pr(>F)"[2]
                        pValuesBatch[index] <- anova(fullModelLME)$"p-value"[3]

                        ## Why do you mix model functions here?

			pValuesCage[index] <-  anova(fullModelLME, reducedModel)$"p-value"[2]
			iccCage[index]<- coef(fullModel$modelStruct[1]$corStruct,unconstrained=FALSE)[[1]]

			names[index] = names(myT)[i]

			graphMain =  paste( names(myT)[i], "\n",
                            ## " pSex=", format( pValuesSex[index], digits=3),
                            ## " pAcuteChronic= ", format( pValuesAcuteChronic[index],digits=3),
                            " pBatch= ", format(pValuesBatch[index], digits=3), "\n",
                            " pTreatment= ", format(pValuesTreatment[index], digits=3)
                            ## " pExperiment= ", format(pValuesExperiment[index], digits=3),
                            " pCage= " , format( pValuesCage[index], digits=3),
                            " icc= " , format( iccCage[index], digits=3 ), sep=""
                                           )
			par(mfrow=c(3,1),
                            oma = c(1,1,0,0) + 0.1,
                            mar = c(1,4,2.5,0) + 0.1)

			plot( bug ~ factor(batch), ylab = names[index],main = graphMain )
                        points(factor(batch), bug)

			## plot ( bug ~ factor(ac) )
                        ## points(factor(ac), bug)

                        plot( bug ~ factor(c( paste( myT$Sex, treatment,sep=""))))
                        points(factor(c( paste( myT$Sex, treatment,sep=""))), bug)

                        ## plot ( bug ~ factor(treatment) )
                        ## points(factor(treatment), bug)

                        plot( bug ~ factor(cage), ylab=names[index])
                        points(factor(cage), bug)
			index=index+1
		}

	dFrame <- data.frame( names, pValuesTreatment, pValuesBatch, pValuesCage, iccCage)#, #pValuesTreatment)#, pValuesBatch)#, pValuesExperiment)

	## dFrame <- dFrame[order(pValuesAcuteChronic),]
	## dFrame$adjustedAcuteChronic <- p.adjust( dFrame$pValuesAcuteChronic, method = "BH" )
	dFrame$adjustedTreatment<- p.adjust( dFrame$pValuesTreatment, method = "BH" )
        dFrame$adjustedBatch<- p.adjust( dFrame$pValuesBatch, method = "BH" )
        ## dFrame$adjustedTreatment<- p.adjust( dFrame$pValuesTreatment, method = "BH" )

	dFrame$adjustedCage <- p.adjust( dFrame$pValuesCage, method = "BH" )
	## dFrame$adjustedExperiment <- p.adjust( dFrame$pValuesExperiment, method = "BH" )

        write.table(dFrame, file=paste("pValuesForTaxa_bug_treatment_batch_cage_eachgroup_", taxa, "_", groupNum, ".txt",sep=""),
                    sep="\t",row.names=FALSE)

##        keepVector <- grep("adj", names(dFrame))
##        sigdFrame <-dFrame[which(dFrame[,keepVector] < 0.05,arr.ind=TRUE),]
##        write.table(sigdFrame, file=paste("pValuesForTaxa_bug_treatment_batch_nocage_eachgroup_sig_", taxa, "_", groupNum,".txt",sep=""), sep="\t",row.names=FALSE)

        dev.off()
    }
}

rm(list=ls())

library("pscl")
library("lmtest")
library("nlme")
# Below is what I need for the Shannon diversity.
library("vegan")

# for experiment, treatment, and batch, and no confounder

setwd("/Users/mbrown67/Documents/Fodor/Datasets/MarkExperiment/Pooled/")

taxaLevels <- c( "phylum", "class", "order", "family", "genus")
# All of this data should be present in any analysis, so there is no reason to make it optional or subject to a switch/case statement.

#inforShannon<-read.table("otuTaxaAsColumnsLogNormWithMetadata.txt.temp", header=TRUE, sep="\t")
#numColsS <- ncol(inforShannon)
#myColClassesS <- c(rep("character",8), rep("numeric", numColsS-8))
#inforShannon <-read.table("otuTaxaAsColumnsLogNormWithMetadata.txt.temp", header=TRUE,sep="\t",row.names=1,colClasses=myColClassesS)
for(groupNum in 2:8){
    for(taxa in taxaLevels ){
	inFileName <- paste( taxa, "LogNormwithMetadata_R1_Pooled.txt", sep ="")
	myT <-read.csv(inFileName,header=TRUE,sep="", na.strings="BLAH")
	numCols <- ncol(myT)
        numMetadataCols <- 20
        ## Reprocessing for correct interpretation
        ## myColClasses <- c("character", rep("numeric", numCols - 16), rep("character", 17))
        ## myT <-read.csv(inFileName, header=TRUE, sep="", colClasses=myColClasses, na.strings="BLAH")
        ## Drop unneeded rows

        removeControls<-c( "C1", "C2", "N1", "N2", "Neg", "Pos")
        myT<-myT[!(myT$Sample_ID %in% removeControls),]
        removetrs<-c("04_125_tr", "04_101_tr", "04_103_tr", "04_74_tr", "04_70_tr", "04_40_tr", "04_41_tr", "04_84_tr")
        myT<-myT[!(myT$Sample_ID %in% removetrs),]
        removeDups<-c("04-04_S63_L001_R1_001")
        ## Somewhat arbitrarily here
        myT<-myT[!(myT$MatchFile %in% removeDups),]
        ## removeLow<-c("04-55_S32_L001_R1_001")
        ## myT<-myT[!(myT$MatchFile %in% removeLow),]

        ## Have to manually drop these for some reason
        manualDrop <- c("Neg_S40_L001_R1_001", "PCR1Neg_S65_L001_R1_001")
        myT<-myT[!(myT$MatchFile %in% manualDrop),]

        myT<-myT[myT$SpreadsheetGrouping == groupNum,]
        lowSeqDrop <- c("04-55_S32_L001_R1_001")
        myT<-myT[!(myT$MatchFile %in% lowSeqDrop),]


        ## print("Got through Processing")

	# our initial model not worrying about confounders except cage
	names <- vector()
	pValuesSex<- vector()
	pValuesAcuteChronic<- vector()
	pValuesCage<- vector()
        iccCage <- vector()
        iccKeptCounts <- vector()
        pValuesBatch<- vector()
        pValuesTreatment<- vector()
        ## pValuesShannon<- vector()
        pValuesKeptCounts<- vector()
	## WARNING:  EXPERIMENT IS CONFOUNDED WITH AC  + SEX - INTERPRET WITH CAUTION!!!!!
	pValuesExperiment <- vector()
        acConf <- vector()
        sexConf <- vector()
        time <- vector()
        pValuesTime <- vector()

	index <- 1
	pdf( paste(taxa, "_", groupNum,"_Treatment_batch_Cage_eachGroup_boxplots.pdf", sep=""))
        print(groupNum)
	for( i in 2:(ncol(myT)-numMetadataCols))
 		if( sum(myT[,i] != 0 ) > nrow(myT) / 4 )
		{
			bug <- myT[,i]
			ac <- myT$Condition
			sex <- myT$Sex
			cage <- myT$Cage
                        batch <- myT$Sample_Project
                        date <- myT$Date
                        time <- myT$StressLength
                        mo <- myT$MouseOrigin
                        treatment <- myT$Treatment

                        myFrame <- data.frame(bug, ac, sex, cage, treatment, batch, date, mo)

                        ##fullModel <- lm(bug ~ treatment + batch, x=TRUE)

			fullModel <- gls( bug~   treatment + batch, method="REML",correlation=corCompSymm(form=~1|factor(cage)), data = myFrame )
                        reducedModel <- gls( bug~  treatment + batch, method="REML", data = myFrame )
                        fullModelLME <- lme(bug~  treatment + batch, method="REML", random = ~1|factor(cage), data = myFrame)
                        ## It seems like reducing the anova calls could speed things up a bit

      			pValuesTreatment[index] <- anova(fullModelLME)$"p-value"[2]
                        ##pValuesTime[index] <- anova(fullModelLME)$"p-value"[5]
			## pValuesSex[index] <- anova(fullModelLME)$"p-value"[5]
			## pValuesExperiment[index] <- anova(fullModelLME)$"p-value"[5]
                        ## pValuesStressLength[index] <- anova(fullModel)$"Pr(>F)"[2]
                        pValuesBatch[index] <- anova(fullModelLME)$"p-value"[3]

                        ## Why do you mix model functions here?

			pValuesCage[index] <-  anova(fullModelLME, reducedModel)$"p-value"[2]
			iccCage[index]<- coef(fullModel$modelStruct[1]$corStruct,unconstrained=FALSE)[[1]]

			names[index] = names(myT)[i]

			graphMain =  paste( names(myT)[i], "\n",
                            ## " pSex=", format( pValuesSex[index], digits=3),
                            ## " pAcuteChronic= ", format( pValuesAcuteChronic[index],digits=3),
                            " pBatch= ", format(pValuesBatch[index], digits=3),
                            " pTreatment= ", format(pValuesTreatment[index], digits=3), "\n",
                            ## " pExperiment= ", format(pValuesExperiment[index], digits=3),
                            " pCage= " , format( pValuesCage[index], digits=3),
                            " icc= " , format( iccCage[index], digits=3 ), sep=""
                                           )
			par(mfrow=c(3,1),
                            oma = c(1,1,0,0) + 0.1,
                            mar = c(1,4,2.5,0) + 0.1)

			plot( bug ~ factor(batch), ylab = names[index],main = graphMain )
                        points(factor(batch), bug)

			## plot ( bug ~ factor(ac) )
                        ## points(factor(ac), bug)

                        plot( bug ~ factor(c( paste( myT$Sex, treatment,sep=""))))
                        points(factor(c( paste( myT$Sex, treatment,sep=""))), bug)

                        ## plot ( bug ~ factor(treatment) )
                        ## points(factor(treatment), bug)

                        plot( bug ~ factor(cage), ylab=names[index])
                        points(factor(cage), bug)
			index=index+1
		}

	dFrame <- data.frame( names, pValuesTreatment, pValuesBatch, pValuesCage, iccCage)#, #pValuesTreatment)#, pValuesBatch)#, pValuesExperiment)

	## dFrame <- dFrame[order(pValuesAcuteChronic),]
	## dFrame$adjustedAcuteChronic <- p.adjust( dFrame$pValuesAcuteChronic, method = "BH" )
	dFrame$adjustedTreatment<- p.adjust( dFrame$pValuesTreatment, method = "BH" )
        dFrame$adjustedBatch<- p.adjust( dFrame$pValuesBatch, method = "BH" )
        ## dFrame$adjustedTreatment<- p.adjust( dFrame$pValuesTreatment, method = "BH" )

	dFrame$adjustedCage <- p.adjust( dFrame$pValuesCage, method = "BH" )
	## dFrame$adjustedExperiment <- p.adjust( dFrame$pValuesExperiment, method = "BH" )

        write.table(dFrame, file=paste("pValuesForTaxa_bug_treatment_batch_cage_eachgroup_", taxa, "_", groupNum, ".txt",sep=""),
                    sep="\t",row.names=FALSE)

##        keepVector <- grep("adj", names(dFrame))
##        sigdFrame <-dFrame[which(dFrame[,keepVector] < 0.05,arr.ind=TRUE),]
##        write.table(sigdFrame, file=paste("pValuesForTaxa_bug_treatment_batch_nocage_eachgroup_sig_", taxa, "_", groupNum,".txt",sep=""), sep="\t",row.names=FALSE)

        dev.off()
    }
}

rm(list=ls())

library("pscl")
library("lmtest")
library("nlme")
# Below is what I need for the Shannon diversity.
library("vegan")

# for experiment, treatment, and batch, and no confounder

setwd("/Users/mbrown67/Documents/Fodor/Datasets/MarkExperiment/Pooled/")

taxaLevels <- c( "phylum", "class", "order", "family", "genus")
# All of this data should be present in any analysis, so there is no reason to make it optional or subject to a switch/case statement.

#inforShannon<-read.table("otuTaxaAsColumnsLogNormWithMetadata.txt.temp", header=TRUE, sep="\t")
#numColsS <- ncol(inforShannon)
#myColClassesS <- c(rep("character",8), rep("numeric", numColsS-8))
#inforShannon <-read.table("otuTaxaAsColumnsLogNormWithMetadata.txt.temp", header=TRUE,sep="\t",row.names=1,colClasses=myColClassesS)
for(groupNum in 5:8){
    for(taxa in taxaLevels ){
	inFileName <- paste( taxa, "LogNormwithMetadata_R1_Pooled.txt", sep ="")
	myT <-read.csv(inFileName,header=TRUE,sep="", na.strings="BLAH")
	numCols <- ncol(myT)
        numMetadataCols <- 20
        ## Reprocessing for correct interpretation
        ## myColClasses <- c("character", rep("numeric", numCols - 16), rep("character", 17))
        ## myT <-read.csv(inFileName, header=TRUE, sep="", colClasses=myColClasses, na.strings="BLAH")
        ## Drop unneeded rows

        removeControls<-c( "C1", "C2", "N1", "N2", "Neg", "Pos")
        myT<-myT[!(myT$Sample_ID %in% removeControls),]
        removetrs<-c("04_125_tr", "04_101_tr", "04_103_tr", "04_74_tr", "04_70_tr", "04_40_tr", "04_41_tr", "04_84_tr")
        myT<-myT[!(myT$Sample_ID %in% removetrs),]
        removeDups<-c("04-04_S63_L001_R1_001")
        ## Somewhat arbitrarily here
        myT<-myT[!(myT$MatchFile %in% removeDups),]
        ## removeLow<-c("04-55_S32_L001_R1_001")
        ## myT<-myT[!(myT$MatchFile %in% removeLow),]

        ## Have to manually drop these for some reason
        manualDrop <- c("Neg_S40_L001_R1_001", "PCR1Neg_S65_L001_R1_001")
        myT<-myT[!(myT$MatchFile %in% manualDrop),]

        myT<-myT[myT$SpreadsheetGrouping == groupNum,]
        lowSeqDrop <- c("04-55_S32_L001_R1_001")
        myT<-myT[!(myT$MatchFile %in% lowSeqDrop),]


        ## print("Got through Processing")

	# our initial model not worrying about confounders except cage
	names <- vector()
	pValuesSex<- vector()
	pValuesAcuteChronic<- vector()
	pValuesCage<- vector()
        iccCage <- vector()
        iccKeptCounts <- vector()
        pValuesBatch<- vector()
        pValuesTreatment<- vector()
        ## pValuesShannon<- vector()
        pValuesKeptCounts<- vector()
	## WARNING:  EXPERIMENT IS CONFOUNDED WITH AC  + SEX - INTERPRET WITH CAUTION!!!!!
	pValuesExperiment <- vector()
        acConf <- vector()
        sexConf <- vector()
        time <- vector()
        pValuesTime <- vector()

	index <- 1
	pdf( paste(taxa, "_", groupNum,"_Treatment_batch_Cage_eachGroup_boxplots.pdf", sep=""))
        print(groupNum)
	for( i in 2:(ncol(myT)-numMetadataCols))
 		if( sum(myT[,i] != 0 ) > nrow(myT) / 4 )
		{
			bug <- myT[,i]
			ac <- myT$Condition
			sex <- myT$Sex
			cage <- myT$Cage
                        batch <- myT$Sample_Project
                        date <- myT$Date
                        time <- myT$StressLength
                        mo <- myT$MouseOrigin
                        treatment <- myT$Treatment

                        myFrame <- data.frame(bug, ac, sex, cage, treatment, batch, date, mo)

                        ##fullModel <- lm(bug ~ treatment + batch, x=TRUE)

			fullModel <- gls( bug~   treatment + batch, method="REML",correlation=corCompSymm(form=~1|factor(cage)), data = myFrame )
                        reducedModel <- gls( bug~  treatment + batch, method="REML", data = myFrame )
                        fullModelLME <- lme(bug~  treatment + batch, method="REML", random = ~1|factor(cage), data = myFrame)
                        ## It seems like reducing the anova calls could speed things up a bit

      			pValuesTreatment[index] <- anova(fullModelLME)$"p-value"[2]
                        ##pValuesTime[index] <- anova(fullModelLME)$"p-value"[5]
			## pValuesSex[index] <- anova(fullModelLME)$"p-value"[5]
			## pValuesExperiment[index] <- anova(fullModelLME)$"p-value"[5]
                        ## pValuesStressLength[index] <- anova(fullModel)$"Pr(>F)"[2]
                        pValuesBatch[index] <- anova(fullModelLME)$"p-value"[3]

                        ## Why do you mix model functions here?

			pValuesCage[index] <-  anova(fullModelLME, reducedModel)$"p-value"[2]
			iccCage[index]<- coef(fullModel$modelStruct[1]$corStruct,unconstrained=FALSE)[[1]]

			names[index] = names(myT)[i]

			graphMain =  paste( names(myT)[i], "\n",
                            ## " pSex=", format( pValuesSex[index], digits=3),
                            ## " pAcuteChronic= ", format( pValuesAcuteChronic[index],digits=3),
                            " pBatch= ", format(pValuesBatch[index], digits=3),
                            " pTreatment= ", format(pValuesTreatment[index], digits=3), "\n",
                            ## " pExperiment= ", format(pValuesExperiment[index], digits=3),
                            " pCage= " , format( pValuesCage[index], digits=3),
                            " icc= " , format( iccCage[index], digits=3 ), sep=""
                                           )
			par(mfrow=c(3,1),
                            oma = c(1,1,0,0) + 0.1,
                            mar = c(1,4,2.5,0) + 0.1)

			plot( bug ~ factor(batch), ylab = names[index],main = graphMain )
                        points(factor(batch), bug)

			## plot ( bug ~ factor(ac) )
                        ## points(factor(ac), bug)

                        plot( bug ~ factor(c( paste( myT$Sex, treatment,sep=""))))
                        points(factor(c( paste( myT$Sex, treatment,sep=""))), bug)

                        ## plot ( bug ~ factor(treatment) )
                        ## points(factor(treatment), bug)

                        plot( bug ~ factor(cage), ylab=names[index])
                        points(factor(cage), bug)
			index=index+1
		}

	dFrame <- data.frame( names, pValuesTreatment, pValuesBatch, pValuesCage, iccCage)#, #pValuesTreatment)#, pValuesBatch)#, pValuesExperiment)

	## dFrame <- dFrame[order(pValuesAcuteChronic),]
	## dFrame$adjustedAcuteChronic <- p.adjust( dFrame$pValuesAcuteChronic, method = "BH" )
	dFrame$adjustedTreatment<- p.adjust( dFrame$pValuesTreatment, method = "BH" )
        dFrame$adjustedBatch<- p.adjust( dFrame$pValuesBatch, method = "BH" )
        ## dFrame$adjustedTreatment<- p.adjust( dFrame$pValuesTreatment, method = "BH" )

	dFrame$adjustedCage <- p.adjust( dFrame$pValuesCage, method = "BH" )
	## dFrame$adjustedExperiment <- p.adjust( dFrame$pValuesExperiment, method = "BH" )

        write.table(dFrame, file=paste("pValuesForTaxa_bug_treatment_batch_cage_eachgroup_", taxa, "_", groupNum, ".txt",sep=""),
                    sep="\t",row.names=FALSE)

##        keepVector <- grep("adj", names(dFrame))
##        sigdFrame <-dFrame[which(dFrame[,keepVector] < 0.05,arr.ind=TRUE),]
##        write.table(sigdFrame, file=paste("pValuesForTaxa_bug_treatment_batch_nocage_eachgroup_sig_", taxa, "_", groupNum,".txt",sep=""), sep="\t",row.names=FALSE)

        dev.off()
    }
}

rm(list=ls())

library("pscl")
library("lmtest")
library("nlme")
# Below is what I need for the Shannon diversity.
library("vegan")

# for experiment, treatment, and batch, and no confounder

setwd("/Users/mbrown67/Documents/Fodor/Datasets/MarkExperiment/Pooled/")

taxaLevels <- c( "phylum", "class", "order", "family", "genus")
# All of this data should be present in any analysis, so there is no reason to make it optional or subject to a switch/case statement.

#inforShannon<-read.table("otuTaxaAsColumnsLogNormWithMetadata.txt.temp", header=TRUE, sep="\t")
#numColsS <- ncol(inforShannon)
#myColClassesS <- c(rep("character",8), rep("numeric", numColsS-8))
#inforShannon <-read.table("otuTaxaAsColumnsLogNormWithMetadata.txt.temp", header=TRUE,sep="\t",row.names=1,colClasses=myColClassesS)
for(groupNum in 7:8){
    for(taxa in taxaLevels ){
	inFileName <- paste( taxa, "LogNormwithMetadata_R1_Pooled.txt", sep ="")
	myT <-read.csv(inFileName,header=TRUE,sep="", na.strings="BLAH")
	numCols <- ncol(myT)
        numMetadataCols <- 20
        ## Reprocessing for correct interpretation
        ## myColClasses <- c("character", rep("numeric", numCols - 16), rep("character", 17))
        ## myT <-read.csv(inFileName, header=TRUE, sep="", colClasses=myColClasses, na.strings="BLAH")
        ## Drop unneeded rows

        removeControls<-c( "C1", "C2", "N1", "N2", "Neg", "Pos")
        myT<-myT[!(myT$Sample_ID %in% removeControls),]
        removetrs<-c("04_125_tr", "04_101_tr", "04_103_tr", "04_74_tr", "04_70_tr", "04_40_tr", "04_41_tr", "04_84_tr")
        myT<-myT[!(myT$Sample_ID %in% removetrs),]
        removeDups<-c("04-04_S63_L001_R1_001")
        ## Somewhat arbitrarily here
        myT<-myT[!(myT$MatchFile %in% removeDups),]
        ## removeLow<-c("04-55_S32_L001_R1_001")
        ## myT<-myT[!(myT$MatchFile %in% removeLow),]

        ## Have to manually drop these for some reason
        manualDrop <- c("Neg_S40_L001_R1_001", "PCR1Neg_S65_L001_R1_001")
        myT<-myT[!(myT$MatchFile %in% manualDrop),]

        myT<-myT[myT$SpreadsheetGrouping == groupNum,]
        lowSeqDrop <- c("04-55_S32_L001_R1_001")
        myT<-myT[!(myT$MatchFile %in% lowSeqDrop),]


        ## print("Got through Processing")

	# our initial model not worrying about confounders except cage
	names <- vector()
	pValuesSex<- vector()
	pValuesAcuteChronic<- vector()
	pValuesCage<- vector()
        iccCage <- vector()
        iccKeptCounts <- vector()
        pValuesBatch<- vector()
        pValuesTreatment<- vector()
        ## pValuesShannon<- vector()
        pValuesKeptCounts<- vector()
	## WARNING:  EXPERIMENT IS CONFOUNDED WITH AC  + SEX - INTERPRET WITH CAUTION!!!!!
	pValuesExperiment <- vector()
        acConf <- vector()
        sexConf <- vector()
        time <- vector()
        pValuesTime <- vector()

	index <- 1
	pdf( paste(taxa, "_", groupNum,"_Treatment_batch_Cage_eachGroup_boxplots.pdf", sep=""))
        print(groupNum)
	for( i in 2:(ncol(myT)-numMetadataCols))
 		if( sum(myT[,i] != 0 ) > nrow(myT) / 4 )
		{
			bug <- myT[,i]
			ac <- myT$Condition
			sex <- myT$Sex
			cage <- myT$Cage
                        batch <- myT$Sample_Project
                        date <- myT$Date
                        time <- myT$StressLength
                        mo <- myT$MouseOrigin
                        treatment <- myT$Treatment

                        myFrame <- data.frame(bug, ac, sex, cage, treatment, batch, date, mo)

                        ##fullModel <- lm(bug ~ treatment + batch, x=TRUE)

			fullModel <- gls( bug~   treatment + batch, method="REML",correlation=corCompSymm(form=~1|factor(cage)), data = myFrame )
                        reducedModel <- gls( bug~  treatment + batch, method="REML", data = myFrame )
                        fullModelLME <- lme(bug~  treatment + batch, method="REML", random = ~1|factor(cage), data = myFrame)
                        ## It seems like reducing the anova calls could speed things up a bit

      			pValuesTreatment[index] <- anova(fullModelLME)$"p-value"[2]
                        ##pValuesTime[index] <- anova(fullModelLME)$"p-value"[5]
			## pValuesSex[index] <- anova(fullModelLME)$"p-value"[5]
			## pValuesExperiment[index] <- anova(fullModelLME)$"p-value"[5]
                        ## pValuesStressLength[index] <- anova(fullModel)$"Pr(>F)"[2]
                        pValuesBatch[index] <- anova(fullModelLME)$"p-value"[3]

                        ## Why do you mix model functions here?

			pValuesCage[index] <-  anova(fullModelLME, reducedModel)$"p-value"[2]
			iccCage[index]<- coef(fullModel$modelStruct[1]$corStruct,unconstrained=FALSE)[[1]]

			names[index] = names(myT)[i]

			graphMain =  paste( names(myT)[i], "\n",
                            ## " pSex=", format( pValuesSex[index], digits=3),
                            ## " pAcuteChronic= ", format( pValuesAcuteChronic[index],digits=3),
                            " pBatch= ", format(pValuesBatch[index], digits=3),
                            " pTreatment= ", format(pValuesTreatment[index], digits=3), "\n",
                            ## " pExperiment= ", format(pValuesExperiment[index], digits=3),
                            " pCage= " , format( pValuesCage[index], digits=3),
                            " icc= " , format( iccCage[index], digits=3 ), sep=""
                                           )
			par(mfrow=c(3,1),
                            oma = c(1,1,0,0) + 0.1,
                            mar = c(1,4,2.5,0) + 0.1)

			plot( bug ~ factor(batch), ylab = names[index],main = graphMain )
                        points(factor(batch), bug)

			## plot ( bug ~ factor(ac) )
                        ## points(factor(ac), bug)

                        plot( bug ~ factor(c( paste( myT$Sex, treatment,sep=""))))
                        points(factor(c( paste( myT$Sex, treatment,sep=""))), bug)

                        ## plot ( bug ~ factor(treatment) )
                        ## points(factor(treatment), bug)

                        plot( bug ~ factor(cage), ylab=names[index])
                        points(factor(cage), bug)
			index=index+1
		}

	dFrame <- data.frame( names, pValuesTreatment, pValuesBatch, pValuesCage, iccCage)#, #pValuesTreatment)#, pValuesBatch)#, pValuesExperiment)

	## dFrame <- dFrame[order(pValuesAcuteChronic),]
	## dFrame$adjustedAcuteChronic <- p.adjust( dFrame$pValuesAcuteChronic, method = "BH" )
	dFrame$adjustedTreatment<- p.adjust( dFrame$pValuesTreatment, method = "BH" )
        dFrame$adjustedBatch<- p.adjust( dFrame$pValuesBatch, method = "BH" )
        ## dFrame$adjustedTreatment<- p.adjust( dFrame$pValuesTreatment, method = "BH" )

	dFrame$adjustedCage <- p.adjust( dFrame$pValuesCage, method = "BH" )
	## dFrame$adjustedExperiment <- p.adjust( dFrame$pValuesExperiment, method = "BH" )

        write.table(dFrame, file=paste("pValuesForTaxa_bug_treatment_batch_cage_eachgroup_", taxa, "_", groupNum, ".txt",sep=""),
                    sep="\t",row.names=FALSE)

##        keepVector <- grep("adj", names(dFrame))
##        sigdFrame <-dFrame[which(dFrame[,keepVector] < 0.05,arr.ind=TRUE),]
##        write.table(sigdFrame, file=paste("pValuesForTaxa_bug_treatment_batch_nocage_eachgroup_sig_", taxa, "_", groupNum,".txt",sep=""), sep="\t",row.names=FALSE)

        dev.off()
    }
}

treatment
fullModel <- lm(bug ~ treatment + batch, x=TRUE)
anova(fullModel)
rm(list=ls())

library("pscl")
library("lmtest")
library("nlme")
# Below is what I need for the Shannon diversity.
library("vegan")

# for experiment, treatment, and batch, and no confounder

setwd("/Users/mbrown67/Documents/Fodor/Datasets/MarkExperiment/Pooled/")

taxaLevels <- c( "phylum", "class", "order", "family", "genus")
# All of this data should be present in any analysis, so there is no reason to make it optional or subject to a switch/case statement.

#inforShannon<-read.table("otuTaxaAsColumnsLogNormWithMetadata.txt.temp", header=TRUE, sep="\t")
#numColsS <- ncol(inforShannon)
#myColClassesS <- c(rep("character",8), rep("numeric", numColsS-8))
#inforShannon <-read.table("otuTaxaAsColumnsLogNormWithMetadata.txt.temp", header=TRUE,sep="\t",row.names=1,colClasses=myColClassesS)
for(groupNum in 2:8){
    for(taxa in taxaLevels ){
	inFileName <- paste( taxa, "LogNormwithMetadata_R1_Pooled.txt", sep ="")
	myT <-read.csv(inFileName,header=TRUE,sep="", na.strings="BLAH")
	numCols <- ncol(myT)
        numMetadataCols <- 20
        ## Reprocessing for correct interpretation
        ## myColClasses <- c("character", rep("numeric", numCols - 16), rep("character", 17))
        ## myT <-read.csv(inFileName, header=TRUE, sep="", colClasses=myColClasses, na.strings="BLAH")
        ## Drop unneeded rows

        removeControls<-c( "C1", "C2", "N1", "N2", "Neg", "Pos")
        myT<-myT[!(myT$Sample_ID %in% removeControls),]
        removetrs<-c("04_125_tr", "04_101_tr", "04_103_tr", "04_74_tr", "04_70_tr", "04_40_tr", "04_41_tr", "04_84_tr")
        myT<-myT[!(myT$Sample_ID %in% removetrs),]
        removeDups<-c("04-04_S63_L001_R1_001")
        ## Somewhat arbitrarily here
        myT<-myT[!(myT$MatchFile %in% removeDups),]
        ## removeLow<-c("04-55_S32_L001_R1_001")
        ## myT<-myT[!(myT$MatchFile %in% removeLow),]

        ## Have to manually drop these for some reason
        manualDrop <- c("Neg_S40_L001_R1_001", "PCR1Neg_S65_L001_R1_001")
        myT<-myT[!(myT$MatchFile %in% manualDrop),]

        myT<-myT[myT$SpreadsheetGrouping == groupNum,]
        lowSeqDrop <- c("04-55_S32_L001_R1_001")
        myT<-myT[!(myT$MatchFile %in% lowSeqDrop),]


        ## print("Got through Processing")

	# our initial model not worrying about confounders except cage
	names <- vector()
	pValuesSex<- vector()
	pValuesAcuteChronic<- vector()
	pValuesCage<- vector()
        iccCage <- vector()
        iccKeptCounts <- vector()
        pValuesBatch<- vector()
        pValuesTreatment<- vector()
        ## pValuesShannon<- vector()
        pValuesKeptCounts<- vector()
	## WARNING:  EXPERIMENT IS CONFOUNDED WITH AC  + SEX - INTERPRET WITH CAUTION!!!!!
	pValuesExperiment <- vector()
        acConf <- vector()
        sexConf <- vector()
        time <- vector()
        pValuesTime <- vector()

	index <- 1
	pdf( paste(taxa, "_", groupNum,"_Treatment_batch_eachGroup_boxplots.pdf", sep=""))
        print(groupNum)
	for( i in 2:(ncol(myT)-numMetadataCols))
 		if( sum(myT[,i] != 0 ) > nrow(myT) / 4 )
		{
			bug <- myT[,i]
			ac <- myT$Condition
			sex <- myT$Sex
			cage <- myT$Cage
                        batch <- myT$Sample_Project
                        date <- myT$Date
                        time <- myT$StressLength
                        mo <- myT$MouseOrigin
                        treatment <- myT$Treatment

                        myFrame <- data.frame(bug, ac, sex, cage, treatment, batch, date, mo)

                        fullModel <- lm(bug ~ treatment + batch, x=TRUE)

			##fullModel <- gls( bug~   treatment + batch, method="REML",correlation=corCompSymm(form=~1|factor(cage)), data = myFrame )
                        ##reducedModel <- gls( bug~  treatment + batch, method="REML", data = myFrame )
                        ##fullModelLME <- lme(bug~  treatment + batch, method="REML", random = ~1|factor(cage), data = myFrame)
                        ## It seems like reducing the anova calls could speed things up a bit
                        pValuesTreatment[index] <- anova(fullModel)$"Pr(>F)"[1]
                        pValuesBatch[index] <- anova(fullModel)$"Pr(>F)"[2]
      			##pValuesTreatment[index] <- anova(fullModelLME)$"p-value"[2]
                        ##pValuesTime[index] <- anova(fullModelLME)$"p-value"[5]
			## pValuesSex[index] <- anova(fullModelLME)$"p-value"[5]
			## pValuesExperiment[index] <- anova(fullModelLME)$"p-value"[5]
                        ## pValuesStressLength[index] <- anova(fullModel)$"Pr(>F)"[2]
                        ##pValuesBatch[index] <- anova(fullModelLME)$"p-value"[3]

                        ## Why do you mix model functions here?

			## pValuesCage[index] <-  anova(fullModelLME, reducedModel)$"p-value"[2]
			## iccCage[index]<- coef(fullModel$modelStruct[1]$corStruct,unconstrained=FALSE)[[1]]

			names[index] = names(myT)[i]

			graphMain =  paste( names(myT)[i], "\n",
                            ## " pSex=", format( pValuesSex[index], digits=3),
                            ## " pAcuteChronic= ", format( pValuesAcuteChronic[index],digits=3),
                            " pBatch= ", format(pValuesBatch[index], digits=3),
                            " pTreatment= ", format(pValuesTreatment[index], digits=3)#, "\n",
                            ## " pExperiment= ", format(pValuesExperiment[index], digits=3),
                            ##" pCage= " , format( pValuesCage[index], digits=3),
                            ##" icc= " , format( iccCage[index], digits=3 ), sep=""
                                           )
			par(mfrow=c(2,1),
                            oma = c(1,1,0,0) + 0.1,
                            mar = c(1,4,2.5,0) + 0.1)

			plot( bug ~ factor(batch), ylab = names[index],main = graphMain )
                        points(factor(batch), bug)

			## plot ( bug ~ factor(ac) )
                        ## points(factor(ac), bug)

                        plot( bug ~ factor(c( paste( myT$Sex, treatment,sep=""))))
                        points(factor(c( paste( myT$Sex, treatment,sep=""))), bug)

                        ## plot ( bug ~ factor(treatment) )
                        ## points(factor(treatment), bug)

                        ## plot( bug ~ factor(cage), ylab=names[index])
                        ## points(factor(cage), bug)
			index = index+1
		}

	dFrame <- data.frame( names, pValuesTreatment, pValuesBatch)#, pValuesCage, iccCage)#, #pValuesTreatment)#, pValuesBatch)#, pValuesExperiment)

	## dFrame <- dFrame[order(pValuesAcuteChronic),]
	## dFrame$adjustedAcuteChronic <- p.adjust( dFrame$pValuesAcuteChronic, method = "BH" )
	dFrame$adjustedTreatment<- p.adjust( dFrame$pValuesTreatment, method = "BH" )
        dFrame$adjustedBatch<- p.adjust( dFrame$pValuesBatch, method = "BH" )
        ## dFrame$adjustedTreatment<- p.adjust( dFrame$pValuesTreatment, method = "BH" )

##	dFrame$adjustedCage <- p.adjust( dFrame$pValuesCage, method = "BH" )
	## dFrame$adjustedExperiment <- p.adjust( dFrame$pValuesExperiment, method = "BH" )

        write.table(dFrame, file=paste("pValuesForTaxa_bug_treatment_batch_eachgroup_", taxa, "_", groupNum, ".txt",sep=""),
                    sep="\t",row.names=FALSE)

##        keepVector <- grep("adj", names(dFrame))
##        sigdFrame <-dFrame[which(dFrame[,keepVector] < 0.05,arr.ind=TRUE),]
##        write.table(sigdFrame, file=paste("pValuesForTaxa_bug_treatment_batch_nocage_eachgroup_sig_", taxa, "_", groupNum,".txt",sep=""), sep="\t",row.names=FALSE)

        dev.off()
    }
}

rm(list=ls())

library("pscl")
library("lmtest")
library("nlme")
library("vegan")

setwd("/Users/mbrown67/Documents/Fodor/Datasets/MarkExperiment/Pooled/")

taxaLevels <- c( "phylum", "class", "order", "family", "genus")

filePrefix <- "_treatment*time + treatment*batch_8_"
mlm<- FALSE

dropBatch <- "Lyte_Batch04_Run01_repeat"
dropTime <- 14
dropTreatment <- "Exp"

divider <- 4
divider <- 8

for(taxa in taxaLevels){

    inFileName <- paste( taxa, "LogNormwithMetadata_R1_Pooled.txt", sep ="")
    myT <-read.csv(inFileName,header=TRUE,sep="", na.strings="BLAH")

    numCols <- ncol(myT)
    numMetadataCols <- 20

    ## Reprocessing for correct column data type
    myColClasses <- c("character", rep("numeric", numCols - numMetadataCols - 1), rep("character", 11), "numeric", "numeric", "numeric", "character", "character", "character", "character", "character", "character")
    myT <-read.csv(inFileName, header=TRUE, sep="", colClasses=myColClasses, na.strings="BLAH", comment.char ="@")

    ## Removing unwanted samples {controls, replicates, duplicates, poor quality samples}
    removeControls<-c( "C1", "C2", "N1", "N2", "Neg", "Pos")
    myT<-myT[!(myT$Sample_ID %in% removeControls),]

    removetrs<-c("04_125_tr", "04_101_tr", "04_103_tr", "04_74_tr", "04_70_tr", "04_40_tr", "04_41_tr", "04_84_tr")
    myT<-myT[!(myT$Sample_ID %in% removetrs),]

    removeDups<-c("04-04_S63_L001_R1_001")
    myT<-myT[!(myT$MatchFile %in% removeDups),]

    ## Controls not dropped earlier
    manualDrop <- c("Neg_S40_L001_R1_001", "PCR1Neg_S65_L001_R1_001")
    myT<-myT[!(myT$MatchFile %in% manualDrop),]

    labDrop <- c("Harlan Labs")
    myT<-myT[!(myT$MouseOrigin %in% labDrop),]

    lowSeqDrop <- c("04-55_S32_L001_R1_001")
    myT<-myT[!(myT$MatchFile %in% lowSeqDrop),]
    ## Not sure what to do about this though.
    ### myT$Condition[which(myT$Treatment == "Ctrl", arr.ind = TRUE)]<-"Control"

##    myT<-myT[!(myT$Sample_Plate == dropBatch),]
##    myT<-myT[myT$StressLength == dropTime,]

    names <- vector()
    pValuesSex<- vector()
    pValuesAcuteChronic<- vector()
    pValuesCage<- vector()
    iccCage <- vector()
    iccKeptCounts <- vector()
    pValuesBatch<- vector()
    pValuesTreatment<- vector()
    pValuesTime <- vector()
    pValuesStressLength <- vector()
    pValuesInteraction <- vector()
    allpvals <- list()

    index <- 1
    pdf( paste(taxa, filePrefix, "boxplots.pdf", sep=""))

    for( i in 2:(ncol(myT) - numMetadataCols))
        if( sum(myT[,i] != 0 ) > nrow(myT) / divider ){
            ## Easy access names
            bug <- myT[,i]
            ac <- myT$Condition
            sex <- myT$Sex
            cage <- myT$Cage
            batch <- myT$Sample_Plate
            date <- myT$Date
            mo <- myT$MouseOrigin
            group <- myT$SpreadsheetGrouping
            treatment <- myT$Treatment
            time <- myT$StressLength
            multiWay <- paste(ac, myT$StressLength)
            multiWay[which(myT$Treatment == "Ctrl", arr.ind = TRUE)]<-"Control"
            names[index] = names(myT)[i]
            ## Some kind of vector for the variables of interest
            myFrame <- data.frame(bug, ac, time, multiWay, sex, cage, treatment, batch, date, mo, date)
            ## M1 <- lm(bug ~ sex + treatment + time + batch + group + date, data = myFrame)
            ## M2 <- lm(bug ~ sex + treatment + time + batch, data = myFrame)
            ## M3 <- lm(bug ~ sex*treatment*time*batch, data = myFrame)
            ## M4 <- lm(bug ~ treatment*batch + sex*time*batch, data = myFrame)
            ## M5 <- lm(bug ~ treatment*time, data = myFrame)
            ## M6 <- lm(bug ~ sex + time + batch, data = myFrame)
            ## M7 <- lm(bug ~ sex + batch, data = myFrame)
            ## drop1(M1, test=
            if(mlm == TRUE){
                fullModel <- gls( bug~ treatment + batch, method="REML",correlation=corCompSymm(form=~1|factor(group)),	data = myFrame )
                reducedModel <- gls( bug~ treatment + batch, method="REML", data = myFrame )
                fullModelLME <- lme(bug~ treatment + batch, method="REML", random = ~1|factor(group), data = myFrame)
            }
            else{
                fullModelLME <- lm(bug~ sex*time*batch, x=TRUE)
            }
            ## Potential save time by reducing anova calls
            ## Introduce the goodness of fit tests here
            ## Can streamline vectors to be automatically responsive to changes to the model
            if(mlm == TRUE){
                allNames <- rownames(anova(fullModelLME))[-1]
                allpvals[[index]] <- anova(fullModelLME)$"p-value"[-1]
            }
            else {
                allNames <- rownames(anova(fullModelLME))[-dim(anova(fullModelLME))[1]]
                allpvals[[index]]<-as.data.frame(anova(fullModelLME))[1:dim(anova(fullModelLME))[1]-1,5]
            }

            ## Random Effects and Interclass Correlation Coefficient
            if(mlm == TRUE){
                allNames<-c(allNames, "cage", "iccCage")
                allpvals[[index]]<-c(allpvals[[index]], anova(fullModelLME, reducedModel)$"p-value"[2], coef(fullModel$modelStruct[1]$corStruct,unconstrained=FALSE)[[1]])
                pValuesCage[index] <-  anova(fullModelLME, reducedModel)$"p-value"[2]
                ## This is different as it is not corrected for multiple hypothesis testing.
                iccCage[index]<- coef(fullModel$modelStruct[1]$corStruct,unconstrained=FALSE)[[1]]
            }
    ## Nice plotting
            ## Correct so that it uses corrected p-values
            if(mlm == TRUE){
                graphMain = c(names[i], paste(c(rep("p-",length(allNames)-1),""), allNames, " = ", format(allpvals[[index]], digits=3), sep=""))
            }
            else {
                graphMain = c(names[i], paste(c(rep("p-",length(allNames)),""), allNames, " = ", format(allpvals[[index]], digits=3), sep=""))

            }

            ## mlm is boolean 1/0 value. Basically, don't graph on icc
            ## need a correction for interaction terms as well
            numPlots <- length(allNames) - mlm
            par(mfrow=c(numPlots, 1),
                oma = c(1,1,0,0) + 0.1,
                mar = c(1,4,3,0) + 0.1)

            for(j in 1:numPlots){
                if(j == 1){
                    plot( bug ~ factor(get(allNames[j])), ylab = names[i], main = c(names[index],toString(graphMain[-1])) )
                    points(factor(get(allNames[j])), bug)
                }
                else{
                    testInteract <- grep(":", allNames)
                    if(length(testInteract) > 0){
                        if(j %in% testInteract){
                            intSplit <- unlist(strsplit(allNames[grep(":",allNames)[which(grep(":", allNames) == j)]],split=":"))
                            if(length(intSplit) == 2){
                                plot( bug ~ factor(c( paste( get(intSplit[1]), get(intSplit[2]),sep=""))))
                                points(factor(c( paste( get(intSplit[1]), get(intSplit[2]),sep=""))), bug)
                            }
                            else{
                                plot( bug ~ factor(c( paste( get(intSplit[1]), get(intSplit[2]), get(intSplit[3]),sep=""))))
                                points(factor(c( paste( get(intSplit[1]), get(intSplit[2]), get(intSplit[3]),sep=""))), bug)
                            }
                        }
                    }
                    else{
                        plot( bug ~ factor(get(allNames[j])), ylab = names[i])
                        points(factor(get(allNames[j])), bug)
                    }
                }
            }

            index <- index + 1
	}

    ## This should also be dynamic
    dFrame <- as.data.frame(matrix(unlist(allpvals), nrow= length(allpvals), byrow=TRUE))
    colnames(dFrame) <- unlist(allNames)
    rownames(dFrame) <- names
    orgCol <- ncol(dFrame)

    for(k in 1:(orgCol-mlm)){
        dFrame[, k + orgCol]<-p.adjust(dFrame[,k], method = "BH")
    }
    colnames(dFrame)[(orgCol + 1):length(dFrame)]<-paste0(rep("adjusted_"),colnames(dFrame)[1:(orgCol - mlm)])

    dFrame <- cbind(names, dFrame)
    ## Try and dynamically generate the name of the plot here...
    write.table(dFrame, file=paste("pValues", filePrefix, taxa, ".txt",sep=""), sep="\t",row.names=FALSE)

    ## Get the sig table working
    ## It would also be nice to have a sig-picker for the plots and a combination of all sig results into one plot.
    keepVector <- grep("adj", names(dFrame))
    sigdFrame <-dFrame[which(dFrame[,keepVector] < 0.05,arr.ind=TRUE),]
    write.table(sigdFrame, file=paste("SIGpValues", filePrefix, taxa, ".txt",sep=""), sep="\t",row.names=FALSE)

    dev.off()
}

rm(list=ls())

library("pscl")
library("lmtest")
library("nlme")
library("vegan")

setwd("/Users/mbrown67/Documents/Fodor/Datasets/MarkExperiment/Pooled/")

taxaLevels <- c( "phylum", "class", "order", "family", "genus")

filePrefix <- "_treatment*batch_8_"
mlm<- FALSE

dropBatch <- "Lyte_Batch04_Run01_repeat"
dropTime <- 14
dropTreatment <- "Exp"

divider <- 4
divider <- 8

for(taxa in taxaLevels){

    inFileName <- paste( taxa, "LogNormwithMetadata_R1_Pooled.txt", sep ="")
    myT <-read.csv(inFileName,header=TRUE,sep="", na.strings="BLAH")

    numCols <- ncol(myT)
    numMetadataCols <- 20

    ## Reprocessing for correct column data type
    myColClasses <- c("character", rep("numeric", numCols - numMetadataCols - 1), rep("character", 11), "numeric", "numeric", "numeric", "character", "character", "character", "character", "character", "character")
    myT <-read.csv(inFileName, header=TRUE, sep="", colClasses=myColClasses, na.strings="BLAH", comment.char ="@")

    ## Removing unwanted samples {controls, replicates, duplicates, poor quality samples}
    removeControls<-c( "C1", "C2", "N1", "N2", "Neg", "Pos")
    myT<-myT[!(myT$Sample_ID %in% removeControls),]

    removetrs<-c("04_125_tr", "04_101_tr", "04_103_tr", "04_74_tr", "04_70_tr", "04_40_tr", "04_41_tr", "04_84_tr")
    myT<-myT[!(myT$Sample_ID %in% removetrs),]

    removeDups<-c("04-04_S63_L001_R1_001")
    myT<-myT[!(myT$MatchFile %in% removeDups),]

    ## Controls not dropped earlier
    manualDrop <- c("Neg_S40_L001_R1_001", "PCR1Neg_S65_L001_R1_001")
    myT<-myT[!(myT$MatchFile %in% manualDrop),]

    labDrop <- c("Harlan Labs")
    myT<-myT[!(myT$MouseOrigin %in% labDrop),]

    lowSeqDrop <- c("04-55_S32_L001_R1_001")
    myT<-myT[!(myT$MatchFile %in% lowSeqDrop),]
    ## Not sure what to do about this though.
    ### myT$Condition[which(myT$Treatment == "Ctrl", arr.ind = TRUE)]<-"Control"

##    myT<-myT[!(myT$Sample_Plate == dropBatch),]
##    myT<-myT[myT$StressLength == dropTime,]

    names <- vector()
    pValuesSex<- vector()
    pValuesAcuteChronic<- vector()
    pValuesCage<- vector()
    iccCage <- vector()
    iccKeptCounts <- vector()
    pValuesBatch<- vector()
    pValuesTreatment<- vector()
    pValuesTime <- vector()
    pValuesStressLength <- vector()
    pValuesInteraction <- vector()
    allpvals <- list()

    index <- 1
    pdf( paste(taxa, filePrefix, "boxplots.pdf", sep=""))

    for( i in 2:(ncol(myT) - numMetadataCols))
        if( sum(myT[,i] != 0 ) > nrow(myT) / divider ){
            ## Easy access names
            bug <- myT[,i]
            ac <- myT$Condition
            sex <- myT$Sex
            cage <- myT$Cage
            batch <- myT$Sample_Plate
            date <- myT$Date
            mo <- myT$MouseOrigin
            group <- myT$SpreadsheetGrouping
            treatment <- myT$Treatment
            time <- myT$StressLength
            multiWay <- paste(ac, myT$StressLength)
            multiWay[which(myT$Treatment == "Ctrl", arr.ind = TRUE)]<-"Control"
            names[index] = names(myT)[i]
            ## Some kind of vector for the variables of interest
            myFrame <- data.frame(bug, ac, time, multiWay, sex, cage, treatment, batch, date, mo, date)
            ## M1 <- lm(bug ~ sex + treatment + time + batch + group + date, data = myFrame)
            ## M2 <- lm(bug ~ sex + treatment + time + batch, data = myFrame)
            ## M3 <- lm(bug ~ sex*treatment*time*batch, data = myFrame)
            ## M4 <- lm(bug ~ treatment*batch + sex*time*batch, data = myFrame)
            ## M5 <- lm(bug ~ treatment*time, data = myFrame)
            ## M6 <- lm(bug ~ sex + time + batch, data = myFrame)
            ## M7 <- lm(bug ~ sex + batch, data = myFrame)
            ## drop1(M1, test=
            if(mlm == TRUE){
                fullModel <- gls( bug~ treatment + batch, method="REML",correlation=corCompSymm(form=~1|factor(group)),	data = myFrame )
                reducedModel <- gls( bug~ treatment + batch, method="REML", data = myFrame )
                fullModelLME <- lme(bug~ treatment + batch, method="REML", random = ~1|factor(group), data = myFrame)
            }
            else{
                fullModelLME <- lm(bug~ treatment*batch, x=TRUE)
            }
            ## Potential save time by reducing anova calls
            ## Introduce the goodness of fit tests here
            ## Can streamline vectors to be automatically responsive to changes to the model
            if(mlm == TRUE){
                allNames <- rownames(anova(fullModelLME))[-1]
                allpvals[[index]] <- anova(fullModelLME)$"p-value"[-1]
            }
            else {
                allNames <- rownames(anova(fullModelLME))[-dim(anova(fullModelLME))[1]]
                allpvals[[index]]<-as.data.frame(anova(fullModelLME))[1:dim(anova(fullModelLME))[1]-1,5]
            }

            ## Random Effects and Interclass Correlation Coefficient
            if(mlm == TRUE){
                allNames<-c(allNames, "cage", "iccCage")
                allpvals[[index]]<-c(allpvals[[index]], anova(fullModelLME, reducedModel)$"p-value"[2], coef(fullModel$modelStruct[1]$corStruct,unconstrained=FALSE)[[1]])
                pValuesCage[index] <-  anova(fullModelLME, reducedModel)$"p-value"[2]
                ## This is different as it is not corrected for multiple hypothesis testing.
                iccCage[index]<- coef(fullModel$modelStruct[1]$corStruct,unconstrained=FALSE)[[1]]
            }
    ## Nice plotting
            ## Correct so that it uses corrected p-values
            if(mlm == TRUE){
                graphMain = c(names[i], paste(c(rep("p-",length(allNames)-1),""), allNames, " = ", format(allpvals[[index]], digits=3), sep=""))
            }
            else {
                graphMain = c(names[i], paste(c(rep("p-",length(allNames)),""), allNames, " = ", format(allpvals[[index]], digits=3), sep=""))

            }

            ## mlm is boolean 1/0 value. Basically, don't graph on icc
            ## need a correction for interaction terms as well
            numPlots <- length(allNames) - mlm
            par(mfrow=c(numPlots, 1),
                oma = c(1,1,0,0) + 0.1,
                mar = c(1,4,3,0) + 0.1)

            for(j in 1:numPlots){
                if(j == 1){
                    plot( bug ~ factor(get(allNames[j])), ylab = names[i], main = c(names[index],toString(graphMain[-1])) )
                    points(factor(get(allNames[j])), bug)
                }
                else{
                    testInteract <- grep(":", allNames)
                    if(length(testInteract) > 0){
                        if(j %in% testInteract){
                            intSplit <- unlist(strsplit(allNames[grep(":",allNames)[which(grep(":", allNames) == j)]],split=":"))
                            if(length(intSplit) == 2){
                                plot( bug ~ factor(c( paste( get(intSplit[1]), get(intSplit[2]),sep=""))))
                                points(factor(c( paste( get(intSplit[1]), get(intSplit[2]),sep=""))), bug)
                            }
                            else{
                                plot( bug ~ factor(c( paste( get(intSplit[1]), get(intSplit[2]), get(intSplit[3]),sep=""))))
                                points(factor(c( paste( get(intSplit[1]), get(intSplit[2]), get(intSplit[3]),sep=""))), bug)
                            }
                        }
                    }
                    else{
                        plot( bug ~ factor(get(allNames[j])), ylab = names[i])
                        points(factor(get(allNames[j])), bug)
                    }
                }
            }

            index <- index + 1
	}

    ## This should also be dynamic
    dFrame <- as.data.frame(matrix(unlist(allpvals), nrow= length(allpvals), byrow=TRUE))
    colnames(dFrame) <- unlist(allNames)
    rownames(dFrame) <- names
    orgCol <- ncol(dFrame)

    for(k in 1:(orgCol-mlm)){
        dFrame[, k + orgCol]<-p.adjust(dFrame[,k], method = "BH")
    }
    colnames(dFrame)[(orgCol + 1):length(dFrame)]<-paste0(rep("adjusted_"),colnames(dFrame)[1:(orgCol - mlm)])

    dFrame <- cbind(names, dFrame)
    ## Try and dynamically generate the name of the plot here...
    write.table(dFrame, file=paste("pValues", filePrefix, taxa, ".txt",sep=""), sep="\t",row.names=FALSE)

    ## Get the sig table working
    ## It would also be nice to have a sig-picker for the plots and a combination of all sig results into one plot.
    keepVector <- grep("adj", names(dFrame))
    sigdFrame <-dFrame[which(dFrame[,keepVector] < 0.05,arr.ind=TRUE),]
    write.table(sigdFrame, file=paste("SIGpValues", filePrefix, taxa, ".txt",sep=""), sep="\t",row.names=FALSE)

    dev.off()
}

rm(list=ls())

library("pscl")
library("lmtest")
library("nlme")
library("vegan")

setwd("/Users/mbrown67/Documents/Fodor/Datasets/MarkExperiment/Pooled/")

taxaLevels <- c( "phylum", "class", "order", "family", "genus")

filePrefix <- "_treatment*batch_bygroup_8_"
mlm<- TRUE

dropBatch <- "Lyte_Batch04_Run01_repeat"
dropTime <- 14
dropTreatment <- "Exp"

divider <- 4
divider <- 8

for(taxa in taxaLevels){

    inFileName <- paste( taxa, "LogNormwithMetadata_R1_Pooled.txt", sep ="")
    myT <-read.csv(inFileName,header=TRUE,sep="", na.strings="BLAH")

    numCols <- ncol(myT)
    numMetadataCols <- 20

    ## Reprocessing for correct column data type
    myColClasses <- c("character", rep("numeric", numCols - numMetadataCols - 1), rep("character", 11), "numeric", "numeric", "numeric", "character", "character", "character", "character", "character", "character")
    myT <-read.csv(inFileName, header=TRUE, sep="", colClasses=myColClasses, na.strings="BLAH", comment.char ="@")

    ## Removing unwanted samples {controls, replicates, duplicates, poor quality samples}
    removeControls<-c( "C1", "C2", "N1", "N2", "Neg", "Pos")
    myT<-myT[!(myT$Sample_ID %in% removeControls),]

    removetrs<-c("04_125_tr", "04_101_tr", "04_103_tr", "04_74_tr", "04_70_tr", "04_40_tr", "04_41_tr", "04_84_tr")
    myT<-myT[!(myT$Sample_ID %in% removetrs),]

    removeDups<-c("04-04_S63_L001_R1_001")
    myT<-myT[!(myT$MatchFile %in% removeDups),]

    ## Controls not dropped earlier
    manualDrop <- c("Neg_S40_L001_R1_001", "PCR1Neg_S65_L001_R1_001")
    myT<-myT[!(myT$MatchFile %in% manualDrop),]

    labDrop <- c("Harlan Labs")
    myT<-myT[!(myT$MouseOrigin %in% labDrop),]

    lowSeqDrop <- c("04-55_S32_L001_R1_001")
    myT<-myT[!(myT$MatchFile %in% lowSeqDrop),]
    ## Not sure what to do about this though.
    ### myT$Condition[which(myT$Treatment == "Ctrl", arr.ind = TRUE)]<-"Control"

##    myT<-myT[!(myT$Sample_Plate == dropBatch),]
##    myT<-myT[myT$StressLength == dropTime,]

    names <- vector()
    pValuesSex<- vector()
    pValuesAcuteChronic<- vector()
    pValuesCage<- vector()
    iccCage <- vector()
    iccKeptCounts <- vector()
    pValuesBatch<- vector()
    pValuesTreatment<- vector()
    pValuesTime <- vector()
    pValuesStressLength <- vector()
    pValuesInteraction <- vector()
    allpvals <- list()

    index <- 1
    pdf( paste(taxa, filePrefix, "boxplots.pdf", sep=""))

    for( i in 2:(ncol(myT) - numMetadataCols))
        if( sum(myT[,i] != 0 ) > nrow(myT) / divider ){
            ## Easy access names
            bug <- myT[,i]
            ac <- myT$Condition
            sex <- myT$Sex
            cage <- myT$Cage
            batch <- myT$Sample_Plate
            date <- myT$Date
            mo <- myT$MouseOrigin
            group <- myT$SpreadsheetGrouping
            treatment <- myT$Treatment
            time <- myT$StressLength
            multiWay <- paste(ac, myT$StressLength)
            multiWay[which(myT$Treatment == "Ctrl", arr.ind = TRUE)]<-"Control"
            names[index] = names(myT)[i]
            ## Some kind of vector for the variables of interest
            myFrame <- data.frame(bug, ac, time, multiWay, sex, cage, treatment, batch, date, mo, date)
            ## M1 <- lm(bug ~ sex + treatment + time + batch + group + date, data = myFrame)
            ## M2 <- lm(bug ~ sex + treatment + time + batch, data = myFrame)
            ## M3 <- lm(bug ~ sex*treatment*time*batch, data = myFrame)
            ## M4 <- lm(bug ~ treatment*batch + sex*time*batch, data = myFrame)
            ## M5 <- lm(bug ~ treatment*time, data = myFrame)
            ## M6 <- lm(bug ~ sex + time + batch, data = myFrame)
            ## M7 <- lm(bug ~ sex + batch, data = myFrame)
            ## drop1(M1, test=
            if(mlm == TRUE){
                fullModel <- gls( bug~ treatment + batch, method="REML",correlation=corCompSymm(form=~1|factor(group)),	data = myFrame )
                reducedModel <- gls( bug~ treatment + batch, method="REML", data = myFrame )
                fullModelLME <- lme(bug~ treatment + batch, method="REML", random = ~1|factor(group), data = myFrame)
            }
            else{
                fullModelLME <- lm(bug~ treatment*batch, x=TRUE)
            }
            ## Potential save time by reducing anova calls
            ## Introduce the goodness of fit tests here
            ## Can streamline vectors to be automatically responsive to changes to the model
            if(mlm == TRUE){
                allNames <- rownames(anova(fullModelLME))[-1]
                allpvals[[index]] <- anova(fullModelLME)$"p-value"[-1]
            }
            else {
                allNames <- rownames(anova(fullModelLME))[-dim(anova(fullModelLME))[1]]
                allpvals[[index]]<-as.data.frame(anova(fullModelLME))[1:dim(anova(fullModelLME))[1]-1,5]
            }

            ## Random Effects and Interclass Correlation Coefficient
            if(mlm == TRUE){
                allNames<-c(allNames, "cage", "iccCage")
                allpvals[[index]]<-c(allpvals[[index]], anova(fullModelLME, reducedModel)$"p-value"[2], coef(fullModel$modelStruct[1]$corStruct,unconstrained=FALSE)[[1]])
                pValuesCage[index] <-  anova(fullModelLME, reducedModel)$"p-value"[2]
                ## This is different as it is not corrected for multiple hypothesis testing.
                iccCage[index]<- coef(fullModel$modelStruct[1]$corStruct,unconstrained=FALSE)[[1]]
            }
    ## Nice plotting
            ## Correct so that it uses corrected p-values
            if(mlm == TRUE){
                graphMain = c(names[i], paste(c(rep("p-",length(allNames)-1),""), allNames, " = ", format(allpvals[[index]], digits=3), sep=""))
            }
            else {
                graphMain = c(names[i], paste(c(rep("p-",length(allNames)),""), allNames, " = ", format(allpvals[[index]], digits=3), sep=""))

            }

            ## mlm is boolean 1/0 value. Basically, don't graph on icc
            ## need a correction for interaction terms as well
            numPlots <- length(allNames) - mlm
            par(mfrow=c(numPlots, 1),
                oma = c(1,1,0,0) + 0.1,
                mar = c(1,4,3,0) + 0.1)

            for(j in 1:numPlots){
                if(j == 1){
                    plot( bug ~ factor(get(allNames[j])), ylab = names[i], main = c(names[index],toString(graphMain[-1])) )
                    points(factor(get(allNames[j])), bug)
                }
                else{
                    testInteract <- grep(":", allNames)
                    if(length(testInteract) > 0){
                        if(j %in% testInteract){
                            intSplit <- unlist(strsplit(allNames[grep(":",allNames)[which(grep(":", allNames) == j)]],split=":"))
                            if(length(intSplit) == 2){
                                plot( bug ~ factor(c( paste( get(intSplit[1]), get(intSplit[2]),sep=""))))
                                points(factor(c( paste( get(intSplit[1]), get(intSplit[2]),sep=""))), bug)
                            }
                            else{
                                plot( bug ~ factor(c( paste( get(intSplit[1]), get(intSplit[2]), get(intSplit[3]),sep=""))))
                                points(factor(c( paste( get(intSplit[1]), get(intSplit[2]), get(intSplit[3]),sep=""))), bug)
                            }
                        }
                    }
                    else{
                        plot( bug ~ factor(get(allNames[j])), ylab = names[i])
                        points(factor(get(allNames[j])), bug)
                    }
                }
            }

            index <- index + 1
	}

    ## This should also be dynamic
    dFrame <- as.data.frame(matrix(unlist(allpvals), nrow= length(allpvals), byrow=TRUE))
    colnames(dFrame) <- unlist(allNames)
    rownames(dFrame) <- names
    orgCol <- ncol(dFrame)

    for(k in 1:(orgCol-mlm)){
        dFrame[, k + orgCol]<-p.adjust(dFrame[,k], method = "BH")
    }
    colnames(dFrame)[(orgCol + 1):length(dFrame)]<-paste0(rep("adjusted_"),colnames(dFrame)[1:(orgCol - mlm)])

    dFrame <- cbind(names, dFrame)
    ## Try and dynamically generate the name of the plot here...
    write.table(dFrame, file=paste("pValues", filePrefix, taxa, ".txt",sep=""), sep="\t",row.names=FALSE)

    ## Get the sig table working
    ## It would also be nice to have a sig-picker for the plots and a combination of all sig results into one plot.
    keepVector <- grep("adj", names(dFrame))
    sigdFrame <-dFrame[which(dFrame[,keepVector] < 0.05,arr.ind=TRUE),]
    write.table(sigdFrame, file=paste("SIGpValues", filePrefix, taxa, ".txt",sep=""), sep="\t",row.names=FALSE)

    dev.off()
}

rm(list=ls())

library("pscl")
library("lmtest")
library("nlme")
library("vegan")

setwd("/Users/mbrown67/Documents/Fodor/Datasets/MarkExperiment/Pooled/")

taxaLevels <- c( "phylum", "class", "order", "family", "genus")

filePrefix <- "_treatment*batch_bygroup_8_"
mlm<- TRUE

dropBatch <- "Lyte_Batch04_Run01_repeat"
dropTime <- 14
dropTreatment <- "Exp"

divider <- 4
divider <- 8

for(taxa in taxaLevels){

    inFileName <- paste( taxa, "LogNormwithMetadata_R1_Pooled.txt", sep ="")
    myT <-read.csv(inFileName,header=TRUE,sep="", na.strings="BLAH")

    numCols <- ncol(myT)
    numMetadataCols <- 20

    ## Reprocessing for correct column data type
    myColClasses <- c("character", rep("numeric", numCols - numMetadataCols - 1), rep("character", 11), "numeric", "numeric", "numeric", "character", "character", "character", "character", "character", "character")
    myT <-read.csv(inFileName, header=TRUE, sep="", colClasses=myColClasses, na.strings="BLAH", comment.char ="@")

    ## Removing unwanted samples {controls, replicates, duplicates, poor quality samples}
    removeControls<-c( "C1", "C2", "N1", "N2", "Neg", "Pos")
    myT<-myT[!(myT$Sample_ID %in% removeControls),]

    removetrs<-c("04_125_tr", "04_101_tr", "04_103_tr", "04_74_tr", "04_70_tr", "04_40_tr", "04_41_tr", "04_84_tr")
    myT<-myT[!(myT$Sample_ID %in% removetrs),]

    removeDups<-c("04-04_S63_L001_R1_001")
    myT<-myT[!(myT$MatchFile %in% removeDups),]

    ## Controls not dropped earlier
    manualDrop <- c("Neg_S40_L001_R1_001", "PCR1Neg_S65_L001_R1_001")
    myT<-myT[!(myT$MatchFile %in% manualDrop),]

    labDrop <- c("Harlan Labs")
    myT<-myT[!(myT$MouseOrigin %in% labDrop),]

    lowSeqDrop <- c("04-55_S32_L001_R1_001")
    myT<-myT[!(myT$MatchFile %in% lowSeqDrop),]
    ## Not sure what to do about this though.
    ### myT$Condition[which(myT$Treatment == "Ctrl", arr.ind = TRUE)]<-"Control"

##    myT<-myT[!(myT$Sample_Plate == dropBatch),]
##    myT<-myT[myT$StressLength == dropTime,]

    names <- vector()
    pValuesSex<- vector()
    pValuesAcuteChronic<- vector()
    pValuesCage<- vector()
    iccCage <- vector()
    iccKeptCounts <- vector()
    pValuesBatch<- vector()
    pValuesTreatment<- vector()
    pValuesTime <- vector()
    pValuesStressLength <- vector()
    pValuesInteraction <- vector()
    allpvals <- list()

    index <- 1
    pdf( paste(taxa, filePrefix, "boxplots.pdf", sep=""))

    for( i in 2:(ncol(myT) - numMetadataCols))
        if( sum(myT[,i] != 0 ) > nrow(myT) / divider ){
            ## Easy access names
            bug <- myT[,i]
            ac <- myT$Condition
            sex <- myT$Sex
            cage <- myT$Cage
            batch <- myT$Sample_Plate
            date <- myT$Date
            mo <- myT$MouseOrigin
            group <- myT$SpreadsheetGrouping
            treatment <- myT$Treatment
            time <- myT$StressLength
            multiWay <- paste(ac, myT$StressLength)
            multiWay[which(myT$Treatment == "Ctrl", arr.ind = TRUE)]<-"Control"
            names[index] = names(myT)[i]
            ## Some kind of vector for the variables of interest
            myFrame <- data.frame(bug, ac, time, multiWay, sex, cage, treatment, batch, date, mo, date)
            ## M1 <- lm(bug ~ sex + treatment + time + batch + group + date, data = myFrame)
            ## M2 <- lm(bug ~ sex + treatment + time + batch, data = myFrame)
            ## M3 <- lm(bug ~ sex*treatment*time*batch, data = myFrame)
            ## M4 <- lm(bug ~ treatment*batch + sex*time*batch, data = myFrame)
            ## M5 <- lm(bug ~ treatment*time, data = myFrame)
            ## M6 <- lm(bug ~ sex + time + batch, data = myFrame)
            ## M7 <- lm(bug ~ sex + batch, data = myFrame)
            ## drop1(M1, test=
            if(mlm == TRUE){
                fullModel <- gls( bug~ treatment*batch, method="REML",correlation=corCompSymm(form=~1|factor(group)),	data = myFrame )
                reducedModel <- gls( bug~ treatment*batch, method="REML", data = myFrame )
                fullModelLME <- lme(bug~ treatment*batch, method="REML", random = ~1|factor(group), data = myFrame)
            }
            else{
                fullModelLME <- lm(bug~ treatment*batch, x=TRUE)
            }
            ## Potential save time by reducing anova calls
            ## Introduce the goodness of fit tests here
            ## Can streamline vectors to be automatically responsive to changes to the model
            if(mlm == TRUE){
                allNames <- rownames(anova(fullModelLME))[-1]
                allpvals[[index]] <- anova(fullModelLME)$"p-value"[-1]
            }
            else {
                allNames <- rownames(anova(fullModelLME))[-dim(anova(fullModelLME))[1]]
                allpvals[[index]]<-as.data.frame(anova(fullModelLME))[1:dim(anova(fullModelLME))[1]-1,5]
            }

            ## Random Effects and Interclass Correlation Coefficient
            if(mlm == TRUE){
                allNames<-c(allNames, "cage", "iccCage")
                allpvals[[index]]<-c(allpvals[[index]], anova(fullModelLME, reducedModel)$"p-value"[2], coef(fullModel$modelStruct[1]$corStruct,unconstrained=FALSE)[[1]])
                pValuesCage[index] <-  anova(fullModelLME, reducedModel)$"p-value"[2]
                ## This is different as it is not corrected for multiple hypothesis testing.
                iccCage[index]<- coef(fullModel$modelStruct[1]$corStruct,unconstrained=FALSE)[[1]]
            }
    ## Nice plotting
            ## Correct so that it uses corrected p-values
            if(mlm == TRUE){
                graphMain = c(names[i], paste(c(rep("p-",length(allNames)-1),""), allNames, " = ", format(allpvals[[index]], digits=3), sep=""))
            }
            else {
                graphMain = c(names[i], paste(c(rep("p-",length(allNames)),""), allNames, " = ", format(allpvals[[index]], digits=3), sep=""))

            }

            ## mlm is boolean 1/0 value. Basically, don't graph on icc
            ## need a correction for interaction terms as well
            numPlots <- length(allNames) - mlm
            par(mfrow=c(numPlots, 1),
                oma = c(1,1,0,0) + 0.1,
                mar = c(1,4,3,0) + 0.1)

            for(j in 1:numPlots){
                if(j == 1){
                    plot( bug ~ factor(get(allNames[j])), ylab = names[i], main = c(names[index],toString(graphMain[-1])) )
                    points(factor(get(allNames[j])), bug)
                }
                else{
                    testInteract <- grep(":", allNames)
                    if(length(testInteract) > 0){
                        if(j %in% testInteract){
                            intSplit <- unlist(strsplit(allNames[grep(":",allNames)[which(grep(":", allNames) == j)]],split=":"))
                            if(length(intSplit) == 2){
                                plot( bug ~ factor(c( paste( get(intSplit[1]), get(intSplit[2]),sep=""))))
                                points(factor(c( paste( get(intSplit[1]), get(intSplit[2]),sep=""))), bug)
                            }
                            else{
                                plot( bug ~ factor(c( paste( get(intSplit[1]), get(intSplit[2]), get(intSplit[3]),sep=""))))
                                points(factor(c( paste( get(intSplit[1]), get(intSplit[2]), get(intSplit[3]),sep=""))), bug)
                            }
                        }
                    }
                    else{
                        plot( bug ~ factor(get(allNames[j])), ylab = names[i])
                        points(factor(get(allNames[j])), bug)
                    }
                }
            }

            index <- index + 1
	}

    ## This should also be dynamic
    dFrame <- as.data.frame(matrix(unlist(allpvals), nrow= length(allpvals), byrow=TRUE))
    colnames(dFrame) <- unlist(allNames)
    rownames(dFrame) <- names
    orgCol <- ncol(dFrame)

    for(k in 1:(orgCol-mlm)){
        dFrame[, k + orgCol]<-p.adjust(dFrame[,k], method = "BH")
    }
    colnames(dFrame)[(orgCol + 1):length(dFrame)]<-paste0(rep("adjusted_"),colnames(dFrame)[1:(orgCol - mlm)])

    dFrame <- cbind(names, dFrame)
    ## Try and dynamically generate the name of the plot here...
    write.table(dFrame, file=paste("pValues", filePrefix, taxa, ".txt",sep=""), sep="\t",row.names=FALSE)

    ## Get the sig table working
    ## It would also be nice to have a sig-picker for the plots and a combination of all sig results into one plot.
    keepVector <- grep("adj", names(dFrame))
    sigdFrame <-dFrame[which(dFrame[,keepVector] < 0.05,arr.ind=TRUE),]
    write.table(sigdFrame, file=paste("SIGpValues", filePrefix, taxa, ".txt",sep=""), sep="\t",row.names=FALSE)

    dev.off()
}

rm(list=ls())

library("pscl")
library("lmtest")
library("nlme")
library("vegan")

setwd("/Users/mbrown67/Documents/Fodor/Datasets/MarkExperiment/Pooled/")

taxaLevels <- c( "phylum", "class", "order", "family", "genus")

filePrefix <- "_treatment*batch_bytime_4_"
mlm<- TRUE

dropBatch <- "Lyte_Batch04_Run01_repeat"
dropTime <- 14
dropTreatment <- "Exp"

divider <- 4
## divider <- 8

for(taxa in taxaLevels){

    inFileName <- paste( taxa, "LogNormwithMetadata_R1_Pooled.txt", sep ="")
    myT <-read.csv(inFileName,header=TRUE,sep="", na.strings="BLAH")

    numCols <- ncol(myT)
    numMetadataCols <- 20

    ## Reprocessing for correct column data type
    myColClasses <- c("character", rep("numeric", numCols - numMetadataCols - 1), rep("character", 11), "numeric", "numeric", "numeric", "character", "character", "character", "character", "character", "character")
    myT <-read.csv(inFileName, header=TRUE, sep="", colClasses=myColClasses, na.strings="BLAH", comment.char ="@")

    ## Removing unwanted samples {controls, replicates, duplicates, poor quality samples}
    removeControls<-c( "C1", "C2", "N1", "N2", "Neg", "Pos")
    myT<-myT[!(myT$Sample_ID %in% removeControls),]

    removetrs<-c("04_125_tr", "04_101_tr", "04_103_tr", "04_74_tr", "04_70_tr", "04_40_tr", "04_41_tr", "04_84_tr")
    myT<-myT[!(myT$Sample_ID %in% removetrs),]

    removeDups<-c("04-04_S63_L001_R1_001")
    myT<-myT[!(myT$MatchFile %in% removeDups),]

    ## Controls not dropped earlier
    manualDrop <- c("Neg_S40_L001_R1_001", "PCR1Neg_S65_L001_R1_001")
    myT<-myT[!(myT$MatchFile %in% manualDrop),]

    labDrop <- c("Harlan Labs")
    myT<-myT[!(myT$MouseOrigin %in% labDrop),]

    lowSeqDrop <- c("04-55_S32_L001_R1_001")
    myT<-myT[!(myT$MatchFile %in% lowSeqDrop),]
    ## Not sure what to do about this though.
    ### myT$Condition[which(myT$Treatment == "Ctrl", arr.ind = TRUE)]<-"Control"

##    myT<-myT[!(myT$Sample_Plate == dropBatch),]
##    myT<-myT[myT$StressLength == dropTime,]

    names <- vector()
    pValuesSex<- vector()
    pValuesAcuteChronic<- vector()
    pValuesCage<- vector()
    iccCage <- vector()
    iccKeptCounts <- vector()
    pValuesBatch<- vector()
    pValuesTreatment<- vector()
    pValuesTime <- vector()
    pValuesStressLength <- vector()
    pValuesInteraction <- vector()
    allpvals <- list()

    index <- 1
    pdf( paste(taxa, filePrefix, "boxplots.pdf", sep=""))

    for( i in 2:(ncol(myT) - numMetadataCols))
        if( sum(myT[,i] != 0 ) > nrow(myT) / divider ){
            ## Easy access names
            bug <- myT[,i]
            ac <- myT$Condition
            sex <- myT$Sex
            cage <- myT$Cage
            batch <- myT$Sample_Plate
            date <- myT$Date
            mo <- myT$MouseOrigin
            group <- myT$SpreadsheetGrouping
            treatment <- myT$Treatment
            time <- myT$StressLength
            multiWay <- paste(ac, myT$StressLength)
            multiWay[which(myT$Treatment == "Ctrl", arr.ind = TRUE)]<-"Control"
            names[index] = names(myT)[i]
            ## Some kind of vector for the variables of interest
            myFrame <- data.frame(bug, ac, time, multiWay, sex, cage, treatment, batch, date, mo, date)
            ## M1 <- lm(bug ~ sex + treatment + time + batch + group + date, data = myFrame)
            ## M2 <- lm(bug ~ sex + treatment + time + batch, data = myFrame)
            ## M3 <- lm(bug ~ sex*treatment*time*batch, data = myFrame)
            ## M4 <- lm(bug ~ treatment*batch + sex*time*batch, data = myFrame)
            ## M5 <- lm(bug ~ treatment*time, data = myFrame)
            ## M6 <- lm(bug ~ sex + time + batch, data = myFrame)
            ## M7 <- lm(bug ~ sex + batch, data = myFrame)
            ## drop1(M1, test=
            if(mlm == TRUE){
                fullModel <- gls( bug~ treatment*batch, method="REML",correlation=corCompSymm(form=~1|factor(time)),	data = myFrame )
                reducedModel <- gls( bug~ treatment*batch, method="REML", data = myFrame )
                fullModelLME <- lme(bug~ treatment*batch, method="REML", random = ~1|factor(time), data = myFrame)
            }
            else{
                fullModelLME <- lm(bug~ treatment*batch, x=TRUE)
            }
            ## Potential save time by reducing anova calls
            ## Introduce the goodness of fit tests here
            ## Can streamline vectors to be automatically responsive to changes to the model
            if(mlm == TRUE){
                allNames <- rownames(anova(fullModelLME))[-1]
                allpvals[[index]] <- anova(fullModelLME)$"p-value"[-1]
            }
            else {
                allNames <- rownames(anova(fullModelLME))[-dim(anova(fullModelLME))[1]]
                allpvals[[index]]<-as.data.frame(anova(fullModelLME))[1:dim(anova(fullModelLME))[1]-1,5]
            }

            ## Random Effects and Interclass Correlation Coefficient
            if(mlm == TRUE){
                allNames<-c(allNames, "cage", "iccCage")
                allpvals[[index]]<-c(allpvals[[index]], anova(fullModelLME, reducedModel)$"p-value"[2], coef(fullModel$modelStruct[1]$corStruct,unconstrained=FALSE)[[1]])
                pValuesCage[index] <-  anova(fullModelLME, reducedModel)$"p-value"[2]
                ## This is different as it is not corrected for multiple hypothesis testing.
                iccCage[index]<- coef(fullModel$modelStruct[1]$corStruct,unconstrained=FALSE)[[1]]
            }
    ## Nice plotting
            ## Correct so that it uses corrected p-values
            if(mlm == TRUE){
                graphMain = c(names[i], paste(c(rep("p-",length(allNames)-1),""), allNames, " = ", format(allpvals[[index]], digits=3), sep=""))
            }
            else {
                graphMain = c(names[i], paste(c(rep("p-",length(allNames)),""), allNames, " = ", format(allpvals[[index]], digits=3), sep=""))

            }

            ## mlm is boolean 1/0 value. Basically, don't graph on icc
            ## need a correction for interaction terms as well
            numPlots <- length(allNames) - mlm
            par(mfrow=c(numPlots, 1),
                oma = c(1,1,0,0) + 0.1,
                mar = c(1,4,3,0) + 0.1)

            for(j in 1:numPlots){
                if(j == 1){
                    plot( bug ~ factor(get(allNames[j])), ylab = names[i], main = c(names[index],toString(graphMain[-1])) )
                    points(factor(get(allNames[j])), bug)
                }
                else{
                    testInteract <- grep(":", allNames)
                    if(length(testInteract) > 0){
                        if(j %in% testInteract){
                            intSplit <- unlist(strsplit(allNames[grep(":",allNames)[which(grep(":", allNames) == j)]],split=":"))
                            if(length(intSplit) == 2){
                                plot( bug ~ factor(c( paste( get(intSplit[1]), get(intSplit[2]),sep=""))))
                                points(factor(c( paste( get(intSplit[1]), get(intSplit[2]),sep=""))), bug)
                            }
                            else{
                                plot( bug ~ factor(c( paste( get(intSplit[1]), get(intSplit[2]), get(intSplit[3]),sep=""))))
                                points(factor(c( paste( get(intSplit[1]), get(intSplit[2]), get(intSplit[3]),sep=""))), bug)
                            }
                        }
                    }
                    else{
                        plot( bug ~ factor(get(allNames[j])), ylab = names[i])
                        points(factor(get(allNames[j])), bug)
                    }
                }
            }

            index <- index + 1
	}

    ## This should also be dynamic
    dFrame <- as.data.frame(matrix(unlist(allpvals), nrow= length(allpvals), byrow=TRUE))
    colnames(dFrame) <- unlist(allNames)
    rownames(dFrame) <- names
    orgCol <- ncol(dFrame)

    for(k in 1:(orgCol-mlm)){
        dFrame[, k + orgCol]<-p.adjust(dFrame[,k], method = "BH")
    }
    colnames(dFrame)[(orgCol + 1):length(dFrame)]<-paste0(rep("adjusted_"),colnames(dFrame)[1:(orgCol - mlm)])

    dFrame <- cbind(names, dFrame)
    ## Try and dynamically generate the name of the plot here...
    write.table(dFrame, file=paste("pValues", filePrefix, taxa, ".txt",sep=""), sep="\t",row.names=FALSE)

    ## Get the sig table working
    ## It would also be nice to have a sig-picker for the plots and a combination of all sig results into one plot.
    keepVector <- grep("adj", names(dFrame))
    sigdFrame <-dFrame[which(dFrame[,keepVector] < 0.05,arr.ind=TRUE),]
    write.table(sigdFrame, file=paste("SIGpValues", filePrefix, taxa, ".txt",sep=""), sep="\t",row.names=FALSE)

    dev.off()
}

